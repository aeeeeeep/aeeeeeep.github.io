<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021亚太数学建模竞赛A题简要思路</title>
    <url>/2021/11/29/2021%E4%BA%9A%E5%A4%AA%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9BA%E9%A2%98/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>小记一下第一次参加数模赛</p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="/image/2021亚太数学建模竞赛A题/mind.png" alt="1"></p>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>用高斯滤波对图像 Pic1_1 和 Pic1_2 进行降噪处理，用灰度值开运算降低图像 Pic1_ 3的噪声；对三个图像进行二值化处理，将灰度图像转化为二值化图像，其次用圆形元素对区域进行膨胀，再用改进的 canny 方法提取亚像素精确边缘，对 XLD 轮廓用最小二乘近似线平滑，再根据斜率以及拐点将 XLD 轮廓分割为直线段和圆弧段或椭圆弧，最后根据轮廓的相对位置对轮廓进行排序，并获取XLD轮廓的长度及区域位置</p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>为达到自标定消除畸变的目的，通过最小二乘近似线平滑、均值滤波降噪、局部阈值分割等算法，将输出的XLD轮廓分割，连接两个标志性的对象元组重复问题一的步骤得到最佳的校准径向畸变参数，用来校准图像的径向畸变由轮廓的相对位置对轮廓进行排序并获取XLD轮廓的长度，最后根据轮廓长度以及实际的物理坐标计算出6个轮廓的真实长度</p>
<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>依据问题一的模型将 XLD 轮廓分割为直线段和圆弧段或椭圆弧。当分割轮廓为直线段时，用最小二乘法进行直线拟合并用多边形生成XLD轮廓；圆弧段或圆，用 algebraic 方法使轮廓点与生成的圆之间的代数距离最小化；椭圆弧或椭圆，基于 tukey 的算法对轮廓点进行加权并忽略异常值</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="问题一-1"><a href="#问题一-1" class="headerlink" title="问题一"></a>问题一</h3><p><img src="/image/2021亚太数学建模竞赛A题/ContoursSplit1.png" alt="1_1"></p>
<p><img src="/image/2021亚太数学建模竞赛A题/ContoursSplit2.png" alt="1_2"></p>
<p><img src="/image/2021亚太数学建模竞赛A题/ContoursSplit3.png" alt="1_3"></p>
<h3 id="问题二-1"><a href="#问题二-1" class="headerlink" title="问题二"></a>问题二</h3><p><img src="/image/2021亚太数学建模竞赛A题/Borders.png" alt="2"></p>
<h3 id="问题三-1"><a href="#问题三-1" class="headerlink" title="问题三"></a>问题三</h3><p><img src="/image/2021亚太数学建模竞赛A题/SortedContours.png" alt="3"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">问题一</summary><pre><code class="halcon">
read_image (Img, 'Pic1_1.bmp')
dev_close_window ()
get_image_size (Img, Width, Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
gauss_filter(Img, ImgGauss, 11)
binary_threshold (ImgGauss, Region,  'smooth_histo', 'dark', UsedThreshold)
boundary (Region, RegionBorder, 'inner')
dilation_circle (RegionBorder, RegionDread_image (Img, 'Pic1_1.bmp')
dev_close_window ()
get_image_size (Img, Width, Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
gauss_filter(Img, ImgGauss, 11)
binary_threshold (ImgGauss, Region,  'smooth_histo', 'dark', UsedThreshold)
boundary (Region, RegionBorder, 'inner')
dilation_circle (RegionBorder, RegionDilation, 2.5)
reduce_domain (ImgGauss, RegionDilation, ImgReduced)
edges_sub_pix (ImgReduced, Edges, 'canny', 2, 20, 60)
smooth_contours_xld(Edges, ImgSmoothed, 9)
segment_contours_xld (ImgSmoothed, ContoursSplit, 'lines_circles', 5, 4, 3)
count_obj (ContoursSplit, Number)
dev_display (Img)
dev_set_draw ('margin')
dev_set_color ('white')
dev_update_window ('off')
dev_set_colored (12)
dev_set_line_width (3)
dev_display (ContoursSplit)
sort_contours_xld (ContoursSplit, SortedContours, 'upper_left', 'true', 'column')
count_obj (ContoursSplit, Number)
length_xld(SortedContours,Length)
gen_empty_obj (Line)
for i := 1 to 24 by 1
    select_obj (SortedContours, ObjectSelected, i)
    get_contour_xld (ObjectSelected, Row, Col)
    gen_region_polygon (Region, Row,Col)
    concat_obj (Line, Region, Line)
endfor
X := Col
Y := Rowilation, 2.5)
reduce_domain (ImgGauss, RegionDilation, ImgReduced)
edges_sub_pix (ImgReduced, Edges, 'canny', 2, 20, 60)
smooth_contours_xld(Edges, ImgSmoothed, 9)
segment_contours_xld (ImgSmoothed, ContoursSplit, 'lines_circles', 5, 4, 3)
count_obj (ContoursSplit, Number)
dev_display (Img)
dev_set_draw ('margin')
dev_set_color ('white')
dev_update_window ('off')
dev_set_colored (12)
dev_set_line_width (3)
dev_display (ContoursSplit)
sort_contours_xld (ContoursSplit, SortedContours, 'upper_left', 'true', 'column')
count_obj (ContoursSplit, Number)
length_xld(SortedContours,Length)
gen_empty_obj (Line)
for i := 1 to 24 by 1
    select_obj (SortedContours, ObjectSelected, i)
    get_contour_xld (ObjectSelected, Row, Col)
    gen_region_polygon (Region, Row,Col)
    concat_obj (Line, Region, Line)
endfor
X := Col
Y := Row
read_image (Img, 'Pic1_2.bmp')
dev_close_window ()
get_image_size (Img, Width, Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
gauss_filter(Img, ImgGauss, 11)
binary_threshold (ImgGauss, Region,  'smooth_histo', 'dark', UsedThreshold)
boundary (Region, RegionBorder, 'inner')
dilation_circle (RegionBorder, RegionDilation, 2.5)
reduce_domain (ImgGauss, RegionDilation, ImgReduced)
edges_sub_pix (ImgReduced, Edges, 'canny', 2, 20, 60)
smooth_contours_xld(Edges, ImgSmoothed, 9)
segment_contours_xld (ImgSmoothed, ContoursSplit, 'lines_circles', 5, 4, 3)
count_obj (ContoursSplit, Number)
dev_display (Img)
dev_set_draw ('margin')
dev_set_color ('white')
dev_update_window ('off')
dev_set_colored (12)
dev_set_line_width (3)
dev_display (ContoursSplit)
sort_contours_xld (ContoursSplit, SortedContours, 'upper_left', 'true', 'column')
count_obj (ContoursSplit, Number)
length_xld(SortedContours,Length)
gen_empty_obj (Line)
for i := 1 to 84 by 1
    select_obj (SortedContours, ObjectSelected, i)
    get_contour_xld (ObjectSelected, Row, Col)
    gen_region_polygon (Region, Row,Col)
    concat_obj (Line, Region, Line)
endfor
x := round(Col)
y := round(Row)
read_image (Img, 'Pic1_3.bmp')
dev_close_window ()
get_image_size (Img, Width, Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
gray_opening_shape (Img, ImgOpen, 16, 16, 'octagon')
mean_image(ImgOpen, ImgMean, 9.3, 9.3)
binary_threshold (ImgMean, Region,  'smooth_histo', 'dark',  UsedThreshold)
boundary (Region, RegionBorder, 'inner')
dilation_circle (RegionBorder, RegionDilation, 4.6)
reduce_domain (ImgMean, RegionDilation, ImgReduced)
edges_sub_pix (ImgReduced, Edges, 'canny', 2, 20, 60)
union_cotangential_contours_xld (Edges, UnionContours, 2, 5, 3.14, 25.0, 10, 2.0, 'attr_forget')
smooth_contours_xld(UnionContours, ImgSmoothed, 9)
segment_contours_xld (ImgSmoothed, ContoursSplit, 'lines_circles', 5, 4, 3)
count_obj (ContoursSplit, Number)
dev_display (Img)
dev_set_draw ('margin')
dev_set_color ('white')
dev_update_window ('off')
dev_set_colored (12)
dev_set_line_width (3)
dev_display (ContoursSplit)
sort_contours_xld (ContoursSplit, SortedContours, 'upper_left', 'true', 'column')
count_obj (ContoursSplit, Number)
length_xld(SortedContours,Length)
gen_empty_obj (Line)
for i := 1 to 120 by 1
    select_obj (SortedContours, ObjectSelected, i)
    get_contour_xld (ObjectSelected, Row, Col)
    gen_region_polygon (Region, Row,Col)
    concat_obj (Line, Region, Line)
endfor
x := round(Col)
y := round(Row)
</code></pre></details>

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">问题二</summary><pre><code class="halcon">
dev_update_off ()
read_image (Img, 'Pic2_4.bmp')
dev_close_window ()
dev_open_window_fit_image (Img, 0, 0, -1, -1, WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
dev_display (Img)
disp_message (WindowHandle, 'Img with radial distortions', 'window', 0, 0, 'black', 'true')
disp_continue_message (WindowHandle, 'black', 'true')
gen_empty_obj (Borders)
for N := 1 to 4 by 1
    read_image (Img, 'Pic2_' + N$'d' + '.bmp')
    edges_sub_pix (Img, ImgBorders, 'canny', 1, 10, 40)
    smooth_contours_xld(ImgBorders, ImgSmoothed, 9)
    segment_contours_xld (ImgSmoothed, SplitBorders, 'lines_circles', 5, 4, 2)
    select_shape_xld (SplitBorders, SelectedBorders, 'contlength', 'and', 30, 100000)
    concat_obj (Borders, SelectedBorders, Borders)
    dev_display (Img)
    dev_set_colored (12)
    dev_display (SelectedBorders)
    disp_message (WindowHandle, 'Edges extracted from image ' + N$'d', 'window', 0, 0, 'black', 'true')
endfor
dev_clear_window ()
dev_set_colored (12)
dev_display (Borders)
disp_message (WindowHandle, 'Collected edges from multiple images', 'window', 0, 0, 'black', 'true')
disp_continue_message (WindowHandle, 'black', 'true')
dev_clear_window ()
disp_message (WindowHandle, 'Performing self-calibration...', 'window', 0, 0, 'black', 'true')
radial_distortion_self_calibration (Borders, CalibrationBorders, 1296, 972, 0.08, 42, 'division', 'fixed', 0, CamParMultiImage)
dev_clear_window ()
dev_set_colored (12)
dev_display (CalibrationBorders)
disp_message (WindowHandle, 'Edges used for calibration', 'window', 0, 0, 'black', 'true')
disp_continue_message (WindowHandle, 'black', 'true')
change_radial_distortion_cam_par ('fixed', CamParMultiImage, 0, CamParMultiImageRect)
read_image (ImgCir, 'Pic2_1.bmp')
get_domain (ImgCir, Domain)
change_radial_distortion_image (ImgCir, Domain, ImgCirRectified, CamParMultiImage, CamParMultiImageRect)
get_image_size (ImgCir, WidthCir, HeightCir)
dev_open_window_fit_image (ImgCir, 0, 0, -1, -1, WindowHandleCir)
set_display_font (WindowHandleCir, 16, 'mono', 'true', 'false')
dev_display (ImgCir)
mean_image(ImgCir, MeanCir, 61, 61)
dyn_threshold(ImgCir, MeanCir, SegCir, 5, 'dark')
fill_up(SegCir, SegFillUpCir)
connection(SegFillUpCir, segConnectCir)
select_shape(segConnectCir, SelectedRegionsCir, ['area','circularity'], 'and', [500, 0.7], [20000, 1])
smallest_circle(SelectedRegionsCir, RowCir, ColumnCir, RadiusCir)
area_center(SelectedRegionsCir, AreaCir, Row1Cir, Column1Cir)
CRadius:=sqrt(AreaCir/3.1415926)
RowSize := mean(0.5 / CRadius)
read_image (Img, 'Pic2_4.bmp')
get_domain (Img, Domain)
change_radial_distortion_image (Img, Domain, ImageRectified, CamParMultiImage, CamParMultiImageRect)
dev_close_window ()
get_image_size (ImageRectified, Width, Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
gauss_filter(Img, ImgGauss, 11)
binary_threshold (ImgGauss, Region,  'smooth_histo', 'dark', UsedThreshold)
boundary (Region, RegionBorder, 'inner')
dilation_circle (RegionBorder, RegionDilation, 2.5)
reduce_domain (ImgGauss, RegionDilation, ImgReduced)
edges_sub_pix (ImgReduced, Borders, 'canny', 2, 20, 60)
smooth_contours_xld(Borders, ImgSmoothed, 9)
dev_display (ImgSmoothed)
dev_set_draw ('margin')
dev_set_color ('white')
dev_update_window ('off')
dev_set_colored (12)
dev_set_line_width (3)
sort_contours_xld (ImgSmoothed, SortedContours, 'upper_left', 'true', 'column')
count_obj (ImgSmoothed, Number)
length_xld(SortedContours,Length)
RealSize := Length * RowSize
AllSzie := sum(RealSize)
</code></pre></details>

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">问题三</summary><pre><code class="halcon">
read_contour_xld_dxf (DxfContours, 'EdgeContour.dxf', [], [], DxfStatus)
segment_contours_xld (DxfContours, ContoursSplit, 'lines_circles', 5, 4, 3)
sort_contours_xld (ContoursSplit, SortedContours, 'upper_left', 'true', 'column')
count_obj (SortedContours, Number)
dev_display (DxfContours)
dev_set_draw ('margin')
dev_set_color ('white')
dev_update_window ('off')
dev_set_colored (12)
dev_set_line_width (3)
dev_display (SortedContours)
dev_set_colored (3)
dev_set_line_width (3)
ColBL := []
RowsBL := []
ColEL := []
RowsEL := []
Lines := []
ColsC := []
RowsC := []
RadiiC := []
PhisC := []
ColsSC := []
RowsSC := []
ColsEC := []
RowsEC := []
ColsE := []
RowsE := []
RadiiE := []
PhisE := []
ColsSE := []
RowsSE := []
ColsEE := []
RowsEE := []
k:=0
J := []
for I := 1 to Number by 1
   select_obj (SortedContours, ObjectSelected, I)
   get_contour_global_attrib_xld (ObjectSelected, 'cont_approx', Attrib)
    if(Attrib == -1)
        k := k+1
        J := [J,k]
        fit_line_contour_xld (ObjectSelected, 'tukey', -1, 2, 6, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)
        gen_contour_polygon_xld (ContLine, [RowBegin,RowEnd], [ColBegin,ColEnd])
        RowsBL := [RowsBL,RowBegin]
        RowsEL := [RowsEL,RowEnd]
        ColBL := [ColBL,ColBegin]
        ColEL := [ColEL,ColEnd]
        length_xld(ContLine,LengthL)
        Lines := [Lines, LengthL]
        dev_display (ContLine)
    elseif(Attrib == 1)
        J := [J,0]
        fit_circle_contour_xld (ObjectSelected, 'algebraic', -1, 6, 0, 3, 2, RowC, ColumnC, RadiusC, StartPhiC, EndPhiC, PointOrderC)
        gen_circle_contour_xld (ContCircle, RowC, ColumnC, RadiusC, 0, rad(360), PointOrderC, 1.0)
        RowsC := [RowsC,RowC]
        ColsC := [ColsC,ColumnC]
        RadiiC := [RadiiC,RadiusC]
        PhisC := [PhisC,(EndPhiC-StartPhiC)*180/3.14159]
        ColsSC := [ColsSC,ColumnC+RadiusC*cos(StartPhiC)]
        RowsSC := [RowsSC,RowC+RadiusC*sin(StartPhiC)]
        ColsEC := [ColsEC,ColumnC+RadiusC*cos(EndPhiC)]
        RowsEC := [RowsEC,RowC+RadiusC*sin(EndPhiC)]
        dev_display (ContCircle)
    else
        fit_ellipse_contour_xld(ObjectSelected, 'ftukey',-1, 6, 0, 2, 3, 2, RowE, ColumnE, RadiusE, RaE, RbE, StartPhiE, EndPhiE, PointOrderE)
        gen_ellipse_contour_xld(ContEllipse, RowE, ColumnE, RadiusE, RaE, RbE, 0, rad(360), PointOrderE, 1.0)
        RowsE := [RowsE,RowE]
        ColsE := [ColsE,ColumnE]
        RadiiE := [RadiiE,RadiusE]
        PhisE := [PhisE,(EndPhiE-StartPhiE)*180/3.14159]
        ColsSE := [ColsSE,ColumnE+RadiusE*cos(StartPhiE)]
        RowsSE := [RowsSE,RowE+RadiusE*sin(StartPhiE)]
        ColsEE := [ColsEE,ColumnE+RadiusE*cos(EndPhiE)]
        RowsEE := [RowsEE,RowE+RadiusE*sin(EndPhiE)]
        dev_display (ContEllipse)
        J:=[J,-1]
    endif
endfor
</code></pre></details>

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">matlab代码</summary><pre><code class="matlab">
clear;
clc;
a = xlsread('Edge1.xlsx');
b = xlsread('Edge2.xlsx');
FID = dxf_open('EdgeContour.dxf');
dxf_polyline(FID, a(:,1), a(:,2), zeros(length(a),1));
dxf_polyline(FID, b(:,1), b(:,2), zeros(length(b),1));
dxf_close(FID);
</code></pre></details>

<blockquote>
<p>DXFLib 库地址: <a href="https://www.mathworks.com/matlabcentral/fileexchange/33884-dxflib">https://www.mathworks.com/matlabcentral/fileexchange/33884-dxflib</a></p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>康宇,赵冬青,上官鹏,储成群.基于FPGA的图像边缘保护高斯滤波算法实现[J].电子设计工程,2021,29(06):94-98+110.DOI:10.14022/j.issn1674-6236.2021.06.020.</li>
<li>梁义涛,孟亚敏,朱玲艳,张猛,李永刚.二维Otsu拟合线阈值图像分割方法[J].科学技术与工程,2021,21(09):3689-3697.</li>
<li>王先传,江岩,赵佳,张岩.基于切比雪夫多项式的函数插值逼近[J].阜阳师范学院学报(自然科学版),2017,34(04):7-11+20.DOI:10.14096/j.cnki.cn34-1069/n/1004-4329(2017)04-04-007-05.</li>
<li>吴曦. 基于MATLAB的图像边缘检测算法的研究和实现[D].吉林大学,2014.</li>
<li>苗莉,王昱煜,于小燕.基于FPGA的双线性插值视频缩放算法实现[J].信息与电脑(理论版),2021,33(08):84-86.</li>
</ul>
]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>CT-Windowing医学CT图像增强</title>
    <url>/2022/10/06/CT-Windowing%E5%8C%BB%E5%AD%A6CT%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>CT winding 是CT扫描的一项图像处理任务，它有助于突出关键的组织结构，通过修改 HU (Hounsfield Units) 参数，使图像更易于分析。</p>
<span id="more"></span>
<p><img src="/image/CT-Windowing医学CT图像增强/0.png" style="zoom:50%;" /></p>
<h2 id="Hounsfield-Unit-HU"><a href="#Hounsfield-Unit-HU" class="headerlink" title="Hounsfield Unit (HU)"></a>Hounsfield Unit (HU)</h2><p>亨氏量表（Hounsfield scale）阻射率的数量尺度单位，命名自X射线电脑断层扫描的发明人高弗雷·豪斯费尔德（Godfrey Newbold Hounsfield）。亨氏单位常用于X射线电脑断层扫描，因此又称为CT值（CT number）。</p>
<p>HU 值与组织的组成和性质有关，因此代表各种组织的密度，HU 值越高，材料越致密，反之亦然。</p>
<p>以下为各组织在 HU 量表上的一些值</p>
<p><img src="/image/CT-Windowing医学CT图像增强/1.png" style="zoom:80%;" /></p>
<h2 id="Window-Width-amp-Window-Level"><a href="#Window-Width-amp-Window-Level" class="headerlink" title="Window Width &amp; Window Level"></a>Window Width &amp; Window Level</h2><h3 id="Window-Width-WW"><a href="#Window-Width-WW" class="headerlink" title="Window Width (WW)"></a>Window Width (WW)</h3><p>是 CT 图像包含的 HU 值范围的度量，任何低于 WW 下限值的 HU 值将在扫描中显示为黑色，而高于 WW 上限值的 HU 值将显示为白色。</p>
<p>随着 WW 的增加，将需要更大的密度变化来改变代表某个 HU 单位的灰色阴影。这会导致对比度损失，因为随着 HU 值的增加，更多的结构将看起来相似（尽管具有不同的密度）。</p>
<p>随着 WW 的减小，较小的密度变化将导致 CT 图像上的颜色发生变化，导致密度接近的结构将分配给不同的灰度，这将增加对比度。</p>
<p><img src="/image/CT-Windowing医学CT图像增强/3.png" style="zoom: 67%;" /></p>
<h3 id="Window-Level-WL"><a href="#Window-Level-WL" class="headerlink" title="Window Level (WL)"></a>Window Level (WL)</h3><p>表示窗口中心或中点的 HU 值，为图像设置的 WL 越低，整个图像将变得越亮。</p>
<p>随着 WL 的降低，较低的 HU 值就能将组织表示为白色，这将允许更多的白色通过，从而使图像更亮。因此，WL 影响图像的亮度。</p>
<p><img src="/image/CT-Windowing医学CT图像增强/4.png" style="zoom:67%;" /></p>
<h3 id="WW-amp-WL-计算"><a href="#WW-amp-WL-计算" class="headerlink" title="WW &amp; WL 计算"></a>WW &amp; WL 计算</h3><p>灰度上限：WL + (WW / 2)<br>灰度下限：WL - (WW / 2)</p>
<p><img src="/image/CT-Windowing医学CT图像增强/2.png" style="zoom:80%;" /></p>
<h3 id="WW-amp-WL-示例"><a href="#WW-amp-WL-示例" class="headerlink" title="WW &amp; WL 示例"></a>WW &amp; WL 示例</h3><p>在 CT 图像查看软件中，通常有各种标准 WL 和 WW。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Tissue</th>
<th>WW</th>
<th>WL</th>
</tr>
</thead>
<tbody>
<tr>
<td>骨头</td>
<td>2000</td>
<td>500</td>
</tr>
<tr>
<td>肺</td>
<td>1600</td>
<td>-600</td>
</tr>
<tr>
<td>腹</td>
<td>400</td>
<td>40</td>
</tr>
<tr>
<td>脑</td>
<td>70</td>
<td>30</td>
</tr>
<tr>
<td>软组织</td>
<td>350</td>
<td>50</td>
</tr>
<tr>
<td>肝</td>
<td>160</td>
<td>60</td>
</tr>
<tr>
<td>纵隔膜（胸腔）</td>
<td>500</td>
<td>50</td>
</tr>
<tr>
<td>中风（低密度脑成像）</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>血管成像</td>
<td>600</td>
<td>170</td>
</tr>
</tbody>
</table>
</div>
<h3 id="WW-amp-WL-选择"><a href="#WW-amp-WL-选择" class="headerlink" title="WW &amp; WL  选择"></a>WW &amp; WL  选择</h3><p>一、根据所需部位的 HU 值（对于CT图像而言）分布范围选取，若是增强 CT 的话 HU 值会有一些差别，可以观察直方图，自定义 WW 和 WL</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform_ctdata</span>(<span class="params">self, windowWidth, windowLevel, normal=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        注意，这个函数的self.image一定得是float类型的，否则就无效！</span></span><br><span class="line"><span class="string">        return: trucated image according to window level and window width</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        minWindow = <span class="built_in">float</span>(windowLevel) - <span class="number">0.5</span>*<span class="built_in">float</span>(windowWidth)</span><br><span class="line">        newimg = (self.image - minWindow) / <span class="built_in">float</span>(windowWidth)</span><br><span class="line">        newimg[newimg &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        newimg[newimg &gt; <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> normal:</span><br><span class="line">            newimg = (newimg * <span class="number">255</span>).astype(<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> newimg</span><br></pre></td></tr></table></figure>
<p>二、根据图像的统计信息，例如图像均值作为窗口中心，$\pm \delta$ 的方差作为 WW</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleITK <span class="keyword">as</span> sitk</span><br><span class="line"><span class="keyword">import</span> torchvision <span class="keyword">as</span> tv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatisticalNormalization</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Normalize an image by mapping intensity with intensity distribution</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sigma</span>):</span></span><br><span class="line">        self.name = <span class="string">&#x27;StatisticalNormalization&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(sigma, <span class="built_in">float</span>)</span><br><span class="line">        self.sigma = sigma</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, sample</span>):</span></span><br><span class="line">        image, label = sample[<span class="string">&#x27;image&#x27;</span>], sample[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">        statisticsFilter = sitk.StatisticsImageFilter()</span><br><span class="line">        statisticsFilter.Execute(image)</span><br><span class="line"></span><br><span class="line">        intensityWindowingFilter = v.IntensityWindowingImageFilter()</span><br><span class="line">        intensityWindowingFilter.SetOutputMaximum(<span class="number">255</span>)</span><br><span class="line">        intensityWindowingFilter.SetOutputMinimum(<span class="number">0</span>)</span><br><span class="line">        intensityWindowingFilter.SetWindowMaximum(</span><br><span class="line">            statisticsFilter.GetMean() + self.sigma * statisticsFilter.GetSigma())</span><br><span class="line">        intensityWindowingFilter.SetWindowMinimum(</span><br><span class="line">            statisticsFilter.GetMean() - self.sigma * statisticsFilter.GetSigma())</span><br><span class="line"></span><br><span class="line">        image = intensityWindowingFilter.Execute(image)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;image&#x27;</span>: image, <span class="string">&#x27;label&#x27;</span>: label&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%A8%E6%B0%8F%E5%96%AE%E4%BD%8D">https://zh.wikipedia.org/wiki/%E4%BA%A8%E6%B0%8F%E5%96%AE%E4%BD%8D</a></p>
<p><a href="https://www.stepwards.com/?page_id=21646">https://www.stepwards.com/?page_id=21646</a></p>
<p><a href="https://myctregistryreview.com/courses/my-ct-registry-review-demo/lessons/ct-physics/">https://myctregistryreview.com/courses/my-ct-registry-review-demo/lessons/ct-physics/</a></p>
<p><a href="https://blog.csdn.net/normol/article/details/88313888">https://blog.csdn.net/normol/article/details/88313888</a></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Faster-RCNN原理笔记</title>
    <url>/2022/03/30/Faster-RCNN%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>详细记录了 Faster RCNN 网络原理和个人的理解</p>
<span id="more"></span>
<ul>
<li><a href="https://arxiv.org/abs/1506.01497">论文下载</a></li>
<li><a href="https://github.com/rbgirshick/py-faster-rcnn">论文源码</a></li>
</ul>
<h2 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h2><p><a href="https://trickygo.github.io/Dive-into-DL-TensorFlow2.0/#/">Tensorflow 2.0 基础</a></p>
<p><a href="https://blog.csdn.net/hjimce/article/details/50187029">RCNN 原理</a></p>
<p><a href="https://www.cnblogs.com/dxscode/p/11443752.html">Fast RCNN 原理</a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="论文中的网络结构图解"><a href="#论文中的网络结构图解" class="headerlink" title="论文中的网络结构图解"></a>论文中的网络结构图解</h3><p><img src="/image/Faster-RCNN原理笔记/faster-rcnn-network.png" style="zoom:30%;" /></p>
<p>主要步骤是</p>
<ol>
<li>输入图片</li>
<li>对图片进行卷积，提取特征</li>
<li>使用 RPN 网络生成 Anchor box，对其裁剪过滤后，通过 softmax 对前景和后景分类，同时，bounding box regression 修正 anchor box，形成校正后的 proposals</li>
<li>将 proposals 映射到 feature maps 上</li>
<li>通过 RoI pooling 层使每个 RoI 生成固定尺寸的 feature map</li>
<li>利用 Softmax Loss 和 Smooth L1 Loss 对分类概率和边框回归联合训练</li>
</ol>
<h3 id="Faster-RCNN-具体的网络结构图"><a href="#Faster-RCNN-具体的网络结构图" class="headerlink" title="Faster RCNN 具体的网络结构图"></a>Faster RCNN 具体的网络结构图</h3><p><img src="/image/Faster-RCNN原理笔记/construction.png" alt="construction"></p>
<h3 id="主干特征提取网络"><a href="#主干特征提取网络" class="headerlink" title="主干特征提取网络"></a>主干特征提取网络</h3><p>可选 ResNet，MobileNet，VGG16 等网络，本模型使用的是 VGG16 网络，由卷积层模块后接全连接层模块构成，每个卷积层的参数分别为 <code>kernel_size=(3,3), padding=&#39;same&#39;, activation=&#39;relu&#39;, kernel_regularizer=&#39;l2&#39;</code>，最大池化层的参数为 <code>pool_size=(2,2), padding=&#39;same&#39;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">____________________________________________________________________________________________________</span><br><span class="line">Layer (<span class="built_in">type</span>)                                 Output Shape                            Param <span class="comment">#        </span></span><br><span class="line">====================================================================================================</span><br><span class="line">input_1 (InputLayer)                         [(<span class="literal">None</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">3</span>)]                   <span class="number">0</span>              </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d (Conv2D)                              (<span class="literal">None</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">64</span>)                    <span class="number">1792</span>           </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_1 (Conv2D)                            (<span class="literal">None</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">64</span>)                    <span class="number">36928</span>          </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">max_pooling2d (MaxPooling2D)                 (<span class="literal">None</span>, <span class="number">250</span>, <span class="number">250</span>, <span class="number">64</span>)                    <span class="number">0</span>              </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_2 (Conv2D)                            (<span class="literal">None</span>, <span class="number">250</span>, <span class="number">250</span>, <span class="number">128</span>)                   <span class="number">73856</span>          </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_3 (Conv2D)                            (<span class="literal">None</span>, <span class="number">250</span>, <span class="number">250</span>, <span class="number">128</span>)                   <span class="number">147584</span>         </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">max_pooling2d_1 (MaxPooling2D)               (<span class="literal">None</span>, <span class="number">125</span>, <span class="number">125</span>, <span class="number">128</span>)                   <span class="number">0</span>              </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_4 (Conv2D)                            (<span class="literal">None</span>, <span class="number">125</span>, <span class="number">125</span>, <span class="number">256</span>)                   <span class="number">295168</span>         </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_5 (Conv2D)                            (<span class="literal">None</span>, <span class="number">125</span>, <span class="number">125</span>, <span class="number">256</span>)                   <span class="number">590080</span>         </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_6 (Conv2D)                            (<span class="literal">None</span>, <span class="number">125</span>, <span class="number">125</span>, <span class="number">256</span>)                   <span class="number">590080</span>         </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">max_pooling2d_2 (MaxPooling2D)               (<span class="literal">None</span>, <span class="number">63</span>, <span class="number">63</span>, <span class="number">256</span>)                     <span class="number">0</span>              </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_7 (Conv2D)                            (<span class="literal">None</span>, <span class="number">63</span>, <span class="number">63</span>, <span class="number">512</span>)                     <span class="number">1180160</span>        </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_8 (Conv2D)                            (<span class="literal">None</span>, <span class="number">63</span>, <span class="number">63</span>, <span class="number">512</span>)                     <span class="number">2359808</span>        </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_9 (Conv2D)                            (<span class="literal">None</span>, <span class="number">63</span>, <span class="number">63</span>, <span class="number">512</span>)                     <span class="number">2359808</span>        </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">max_pooling2d_3 (MaxPooling2D)               (<span class="literal">None</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">512</span>)                     <span class="number">0</span>              </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_10 (Conv2D)                           (<span class="literal">None</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">512</span>)                     <span class="number">2359808</span>        </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_11 (Conv2D)                           (<span class="literal">None</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">512</span>)                     <span class="number">2359808</span>        </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">conv2d_12 (Conv2D)                           (<span class="literal">None</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">512</span>)                     <span class="number">2359808</span>        </span><br><span class="line">____________________________________________________________________________________________________</span><br><span class="line">dense (Dense)                                (<span class="literal">None</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">10</span>)                      <span class="number">5130</span>           </span><br><span class="line">====================================================================================================</span><br><span class="line">Total params: <span class="number">14</span>,<span class="number">719</span>,<span class="number">818</span></span><br><span class="line">Trainable params: <span class="number">14</span>,<span class="number">719</span>,<span class="number">818</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">____________________________________________________________________________________________________</span><br></pre></td></tr></table></figure>
<p>使用 VGG16 网络不像resnet那么复杂，更深的网络理论上效果也更好</p>
<h3 id="RPN-Region-Proposal-Networks"><a href="#RPN-Region-Proposal-Networks" class="headerlink" title="RPN (Region Proposal Networks)"></a>RPN (Region Proposal Networks)</h3><p>在图像中产生所有可能为目标的候选区域，用来解决生成检测框耗时较多的问题。RPN 根据 CNN 生成的特征图，在 img 的尺度上生成多个锚框，对生成的锚框进行分类和回归。</p>
<p><img src="/image/Faster-RCNN原理笔记/rpn.png" alt="rpn" style="zoom:67%;" /></p>
<p>网络分为2条线，上面一条通过softmax分类 anchors 获得positive 和 negative 分类，下面一条用于计算对于 anchors 的 bounding box regression 偏移量，获得精确的 proposal。最后的 Proposal layer 负责综合 positive anchors 和对应 bounding box regression 偏移量获取 proposals，同时剔除太小和超出边界的 proposals</p>
<h4 id="ahchors"><a href="#ahchors" class="headerlink" title="ahchors"></a>ahchors</h4><p>是一种多尺度方法，以一个像素点为中心，生成一组描述 9 个矩形的矩阵，每行4个值 $(x_min, y_min, x_max, y_max)$ 表示矩形左上和右下角点坐标，长宽比为 $ width:height \in \{ 1:1, 1:2, 2:1 \} $ </p>
<p><img src="/image/Faster-RCNN原理笔记/anchors.jpg" alt="anchors"></p>
<p>其中，anchors size 是根据检测图像设置的，Faster RCNN网络会把所有输入的图像 reshape 成固定大小，在论文中，会为 feature map 中的每个像素点生成 anchors，后面的2次 bounding box regression 会修正 anchors 检测框位置</p>
<p><img src="/image/Faster-RCNN原理笔记/anchors.png" alt="anchors" style="zoom:67%;" /></p>
<p>上图截取自论文，其中</p>
<ul>
<li>256-d: 论文中主干特征提取网络的最后一层 num_output=256，对应生成的 feature map 是256维的</li>
<li>sliding window: feature map 在进入 RPN 网络后，又进行了一次 3x3 的卷积，256-d 没有变</li>
<li>$cls \quad layer$: 已知每个像素点上有 k 个 anchor(图中 k = 9)，每个 anchor 要分前景(positive)和背景(negative)，所以每个点由 256-d 的 feature map 转化为 2k scores</li>
<li>$reg \quad layer$: 已知每个像素点上有 k 个 anchor(图中 k = 9)，每个 anchor 有 $(x, y, w, h)$ 对应的4个偏移量，所以每个点由 256-d 的 feature map 转化为 4k coordinates</li>
</ul>
<p><img src="/image/Faster-RCNN原理笔记/gernerate_anchors.jpg" alt="gernerate_anchors" style="zoom:60%;" /></p>
<p>上图以 图片大小 500x500 为例，计算生成的 gernerate anchors 的数量</p>
<script type="math/tex; mode=display">
\operatorname{ceil}(500 / 16) \times \operatorname{ceil}(500 / 16) \times 9=32 \times 32 \times 9= 9216</script><p>ceil()为向上取整，因为图中VGG16网络输出的 feature map size 为整数</p>
<h4 id="判定-positive-negative"><a href="#判定-positive-negative" class="headerlink" title="判定 positive/negative"></a>判定 positive/negative</h4><p>主要步骤：</p>
<ol>
<li>RPN 网络图中上面一条输入为共享层卷积的输出</li>
<li>进行通道数为2k(k=num_anchors)的 1x1 卷积</li>
<li>reshape 成两个通道</li>
<li>对通道层做归一化，使类别预测的概率和为 1</li>
<li>取最终的预测类别和概率</li>
<li>reshape 回复原状 <code>[1, h, w, 9*2]</code></li>
</ol>
<p>论文作者在源码中的 softmax_loss_layer.cpp 对最后 reshape层 的解释:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Number of labels must match number of predictions; &quot;</span></span><br><span class="line"><span class="string">&quot;e.g., if softmax axis == 1 and prediction shape is (N, C, H, W), &quot;</span></span><br><span class="line"><span class="string">&quot;label count (number of labels) must be N*H*W, &quot;</span></span><br><span class="line"><span class="string">&quot;with integer values in &#123;0, 1, ..., C-1&#125;.&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="bounding-box-regression"><a href="#bounding-box-regression" class="headerlink" title="bounding box regression"></a>bounding box regression</h4><p>图中所示，绿色框为苹果的 ground truth，红色为提取的 positive anchors，即便红色的框被分类器识别为苹果，但是由于红色的框定位不准，这张图相当于没有正确的检测出苹果。所以需要采用一种方法对红色的框进行微调，使得 positive anchors 和 ground truth 更加接近</p>
<p><img src="/image/Faster-RCNN原理笔记/bounding.png" alt="bounding" style="zoom:75%;" /></p>
<p>对于窗口一般使用四维向量 $(x, y, w, h)$ 表示，分别表示窗口的中心点坐标和宽高，红框代表原始的positive anchors，绿框代表目标的 ground truth，使得输入原始的 anchor 经过映射得到一个跟 ground truth 更接近的回归窗口，即</p>
<p>positive anchors:  $A = (A_x, A_y, A_w, A_h)$</p>
<p>ground truth:  $GT = (G_x, G_y, G_w, G_h)$</p>
<p>寻找 $F$，使 $F(A) = (G_{x}^{\prime}, G_{y}^{\prime}, G_{w}^{\prime}, G_{h}^{\prime})$</p>
<p>其中 $(G_{x}^{\prime}, G_{y}^{\prime}, G_{w}^{\prime}, G_{h}^{\prime}) \approx (G_{x}, G_{y}, G_{w}, G_{h})$</p>
<p><img src="/image/Faster-RCNN原理笔记/fag.png" alt="fag" style="zoom:33%;" /></p>
<p>通过变换 $F$从 $A$ 变换到 $G’$，我们要做的是</p>
<p>平移</p>
<script type="math/tex; mode=display">
G_x^\prime = A_w \cdot d_x(A) + A_x \\
G_y^\prime = A_h \cdot d_y(A) + A_y</script><p>缩放</p>
<script type="math/tex; mode=display">
G_w^\prime = A_w \cdot exp(d_w(A))\\
G_h^\prime = A_h \cdot exp(d_h(A))</script><p>需要学习的是 $d_x(A), d_y(A), d_w(A) ,d_h(A)$ 这四个变换。当输入的 $A$ 与 $GT$ 相差较小时，认为这种变换是一种线性变换， 用线性回归来建模对窗口进行微调，当 $A$ 和 $GT$ 比较接近时，认为是复杂的非线性问题</p>
<p>已知线性回归公式 $Y = WX$，$X$ 为 feature map，定义为 $\phi$，训练传入$A$与$GT$之间的变换量 $(t_x, t_y, t_w, t_h, )$，$Y$为 $(d_x(A), d_y(A), d_w(A) ,d_h(A))$，则目标函数为</p>
<script type="math/tex; mode=display">
d_*(A) = W_*^T\phi(A)</script><p>其中 $\phi(A)$ 是对应 anchor 的 feature map 组成的特征向量，$W_{<em>}$ 是需要学习的参数，$d_{</em>}(A)$ 是得到的预测值</p>
<p>在 Faster RCNN 论文中，positive anchor 与 ground truth 之间的平移量 $(t_x, t_y)$ 与尺度因子 $(t_w, t_h)$  如下</p>
<script type="math/tex; mode=display">
t_x = (x-x_a)/w_a \quad t_y = (y-y_a)/h_a \\
t_w = \log(w/w_a) \quad t_h = \log(h/h_a)</script><p>为了让预测值 $ {d_{*}(A) }$ 与真实值差距最小， ${\operatorname{smooth}_{L_{1}}}$ 损失函数为</p>
<script type="math/tex; mode=display">
Loss = \begin{cases} 
0.5 \cdot (\sum_i^N (t_*^i -W_*^T \cdot \phi(A^i))^2 & \text{if}|x| <1 \\
\sum_i^N |t_*^i -W_*^T \cdot \phi(A^i)| - 0.5 & \text{otherwise} \\
\end{cases}</script><p>优化目标函数为</p>
<script type="math/tex; mode=display">
\hat{W}_* = {argmin}_{W_*} \sum_i^n (t_*^i -W_*^T \cdot \phi(A^i))^2 + \lambda \| W_* \|</script><p>之后可通过梯度下降等方法修正 anchor 位置，注意当 $A$ 和 $GT$ 比较接近时，才可近似认为上述线性变换及优化目标函数成立</p>
<h4 id="对-proposals-进行-bounding-box-regression"><a href="#对-proposals-进行-bounding-box-regression" class="headerlink" title="对 proposals 进行 bounding box regression"></a>对 proposals 进行 bounding box regression</h4><p>在第二条线路中，num_output=36，即经过该卷积输出图像为 WxHx36，存储为 <code>[1, 4x9, H, W]</code>，这里相当于 feature maps 每个点都有9个 anchors，每个 anchors 又都有4个用于回归的 $(d_x(A), d_y(A), d_w(A) ,d_h(A))$ 变换量</p>
<p>VGG16 网络输出 $32 <em> 32 </em> 512$ 的特征，对应设置 $32<em>32</em>k$ 个 anchors，因此RPN输出</p>
<ul>
<li><p>大小为 $32 <em> 32 </em> 2k$ 的 positive/negative softmax 分类特征矩阵</p>
</li>
<li><p>大小为 $32 <em> 32 </em> 4k$ 的 regression 坐标回归特征矩阵</p>
</li>
</ul>
<p>对应 RPN 的 positive/negative 分类和 bounding box regression 坐标回归</p>
<h4 id="Proposal-Layer"><a href="#Proposal-Layer" class="headerlink" title="Proposal Layer"></a>Proposal Layer</h4><p>Proposal Layer负责综合所有 $(d_x(A), d_y(A), d_w(A), d_h(A))$ 变换量和 positive anchors，计算出精准的proposal，送入后续 RoI Pooling Layer</p>
<p><img src="/image/Faster-RCNN原理笔记/proposal_layer.png" style="zoom:67%;" /></p>
<p>Proposal Layer有3个输入：positive/negative anchors 分类器结果 rpn_cls_score，$(d_x(A), d_y(A), d_w(A), d_h(A))$ 的变换量 rpn_bbox_pred，img_info(包含 feat_stride = 16)</p>
<p>img_info: 对于一副任意大小 PxQ 图像，传入 Faster RCNN 前_prob概首先reshape到固定 MxN，im_info=[M, N, scale_factor] 保存了此次缩放的所有信息。然后经过 VGG16，经过4次 max_pooling2d 变为 WxH=(M/16)x(N/16) 大小，其中 feature_stride=16 则保存了该信息，用于计算 anchor 偏移量</p>
<p>Proposal Layer forward（前传函数）按照以下顺序依次处理: </p>
<ol>
<li>生成anchors，利用 $ (d_x(A), d_y(A), d_w(A), d_h(A)) $ 对所有的 anchors 做 bbox regression 回归（这里的 anchors 生成和训练时相同）</li>
<li>按照输入的 positive softmax scores 由大到小排序 anchors，提取前 pre_nms_top N(e.g. 5000) 个anchors，即提取修正位置后的 positive anchors</li>
<li>限定超出图像边界的 positive anchors 为图像边界，防止后续 ROIpooling 时 proposal 超出图像边界</li>
<li>剔除尺寸非常小的 positive anchors</li>
<li>对剩余的 positive anchors 进行NMS(极大值抑制)</li>
<li>Proposal Layer 有3个输入: positive 和 negative anchors 分类器结果 rpn_cls_score，对应的 bbox reg 的 (e.g. 300) 结果作为 proposal 输出</li>
</ol>
<p>输出 proposal 为 <code>[x_min, y_min, x_max, y_max]</code>，由于需要将 anchors 映射回原图判断是否超出边界，所以 proposal 对应的图像尺度为 MxN</p>
<h3 id="ROIHead"><a href="#ROIHead" class="headerlink" title="ROIHead"></a>ROIHead</h3><p>在传统的CNN网络中，当训练好后输入的图像尺寸必须是固定值，同时网络输出也是固定大小的 vector or matrix，如果输入图像大小不定，过去有2种解决办法:</p>
<ul>
<li>从图像中 crop 一部分传入网络</li>
<li>将图像warp成需要的大小后传入网络</li>
</ul>
<p><img src="/image/Faster-RCNN原理笔记/crop_warp.png" alt="crop_warp" style="zoom:67%;" /></p>
<p>crop后破坏了图像的完整结构，warp后破坏了图像原始形状信息，两种方法都不好</p>
<p>为了使网络可以接收不同大小的图像，Faster RCNN 中提出了 ROIPooling，ROIPooling 从 <a href="https://arxiv.org/abs/1406.4729">Spatial Pyramid Pooling</a> 发展而来，这里不展开讨论</p>
<h4 id="ROI-pooling"><a href="#ROI-pooling" class="headerlink" title="ROI pooling"></a>ROI pooling</h4><p>ROIpooling 对 proposal 对 feature map 裁剪后的 ROIs 进行 maxpooling 使输入的 shape 相同，生成 proposal feature maps，它有3个参数: </p>
<ul>
<li>pooled_w: proposal feature maps 的 width</li>
<li>pooled_h: proposal feature maps 的 width</li>
<li>spatial_scale: 是 VGG16 提取 feature map 后对图像尺度的改变，也就是 feature_stride=16</li>
</ul>
<p>由于 proposal 是对应 MxN 尺度的，所以首先使用 spatial_scale 将其映射回  (M/16)x(N/16) 大小的 feature map 尺度，再将每个 proposal 对应的 feature map 区域水平分为 pooled_w x pooled_h 的网格，对网格的每一份都进行max pooling处理</p>
<p>例:</p>
<p>假定输入 feature map 为</p>
<p><img src="/image/Faster-RCNN原理笔记/pool_sample1.png" alt="pool_sample1" style="zoom:35%;" /></p>
<p>假定区域建议为</p>
<p><img src="/image/Faster-RCNN原理笔记/pool_sample2.png" alt="pool_sample2" style="zoom:35%;" /></p>
<p>假定 pooled_w=2, pooled_h=2</p>
<p><img src="/image/Faster-RCNN原理笔记/pool_sample3.png" alt="pool_sample3" style="zoom:35%;" /></p>
<p>对网格的每一份都进行 max pooling 处理</p>
<p><img src="/image/Faster-RCNN原理笔记/pool_sample4.png" alt="pool_sample4" style="zoom:40%;" /></p>
<p>这种方法显著加快了训练和测试时间</p>
<h4 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h4><p><img src="/image/Faster-RCNN原理笔记/classfication.png" alt="classfication" style="zoom:67%;" /></p>
<p>利用 ROIpooling 输出的 proposal feature maps，通过 1x1的conv2d 层与 softmax 计算每个 proposal 具体属于那个类别，输出 cls_prob 概率向量，同时再次利用 bounding box regression 获得每个 proposal 的位置偏移量 bbox_pred，用于回归更加精确的目标检测框</p>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>论文源码中训练 Faster RCNN 有两种方式，一种是四步交替训练法，一种是 end-to-end 训练法，本文只讨论四步交替训练法</p>
<p>由前面我们可知，Faster RCNN 大概可以分为 RPN 网络和 Fast RCNN 网络部分</p>
<ol>
<li><p>训练 RPN，用 feature map 初始化 RPN 网络，并端到端微调，生成 region proposal</p>
</li>
<li><p>用 feature map 初始化 Fast RCNN 网络部分，利用第一步的 RPN 生成的 region proposals 作为输入数据，接着训练 Fast RCNN部分，这时两个网络没有共享卷积层</p>
</li>
<li><p>用第二步的 Fast RCNN model 初始化 RPN 第二次进行训练，但固定共享的卷积层，并且只微调 RPN 独有的层，现在两个网络共享卷积层</p>
</li>
<li><p>由第三步的 RPN model 初始化 Fast RCNN 网络部分，输入数据为第三步生成的 proposals，保持共享的卷积层固定，微调 Fast RCNN 网络部分 Classification 中的卷积层，两个网络共享相同的卷积层，构成一个统一的网络，也就是论文中的 unified network</p>
</li>
</ol>
<p>文中提到的共享卷积层的方法为迁移学习中的技术: <a href="https://trickygo.github.io/Dive-into-DL-TensorFlow2.0/#/chapter09_computer-vision/9.2_fine-tuning?id=_92-%e5%be%ae%e8%b0%83">微调(fine tunin)</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks Shaoqing Ren; Kaiming He; Ross B. Girshick; Jian Sun 0001</li>
<li>Fast R-CNN Ross Girshick; Microsoft Research</li>
<li>Research on Apple Detection Classification and Location Technology in Complex Environment Based on Deep Learning Tian Bokai; Professor Yue Youjun</li>
<li><p>Apple Target Detection Based on Improved Faster - RCNN Framework of Deep Learning LI Linsheng; ZENG Pingping</p>
</li>
<li><p><a href="https://github.com/FurkanOM/tf-faster-rcnn">https://github.com/FurkanOM/tf-faster-rcnn</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_43198141/article/details/90178512">https://blog.csdn.net/weixin_43198141/article/details/90178512</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/31426458">https://zhuanlan.zhihu.com/p/31426458</a></p>
</li>
<li><p><a href="https://github.com/jinfagang/keras_frcnn">https://github.com/jinfagang/keras_frcnn</a></p>
</li>
<li><p><a href="https://github.com/bubbliiiing/faster-rcnn-keras">https://github.com/bubbliiiing/faster-rcnn-keras</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_40449426/article/details/78141635">https://blog.csdn.net/weixin_40449426/article/details/78141635</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>懵逼的深度学习</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>GroupFormer简要学习笔记</title>
    <url>/2022/08/31/GroupFormer%E7%AE%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>快速记录下 GroupFormer 网络的核心思想。</p>
<span id="more"></span>
<p>paper: <a href="https://arxiv.org/abs/2108.12630">https://arxiv.org/abs/2108.12630</a></p>
<p>code: <a href="https://github.com/xueyee/GroupFormer">https://github.com/xueyee/GroupFormer</a></p>
<h2 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h2><p><img src="https://github.com/xueyee/GroupFormer/blob/main/figs/img.png?raw=true" alt="figure1"></p>
<ol>
<li>提取视频clip的特征表示的<strong>CNN主干</strong>;</li>
<li>用于个体和场景特征初始化的<strong>群体表示生成器 (Group Representation Generator，GRG)</strong>;</li>
<li>用于建模时空关系，细化群体表示和个体表示的<strong>聚类时空Transformer (CSTT)</strong>;</li>
</ol>
<h2 id="特征提取器"><a href="#特征提取器" class="headerlink" title="特征提取器"></a>特征提取器</h2><p>Kinetics预训练的3D网络 (I3D) 作为Backbone</p>
<h2 id="群体表示生成器"><a href="#群体表示生成器" class="headerlink" title="群体表示生成器"></a>群体表示生成器</h2><p>是一个在模型中用于初始化群体表示的预处理组件，将场景特征和个体特征分别转换为视觉token，将它们聚合以生成群体表示</p>
<h2 id="聚类时空Transformer"><a href="#聚类时空Transformer" class="headerlink" title="聚类时空Transformer"></a>聚类时空Transformer</h2><h3 id="时空Transformer"><a href="#时空Transformer" class="headerlink" title="时空Transformer"></a>时空Transformer</h3><p>为群体活动识别而设计的时空Transformer(STT)增强了个体表征和群体表征。它包括两个并行的编码器（一个空间编码器和时间编码器 ），分别生成空间和时间特征。并引入交叉的个体解码器 来解码时空上下文信息。最后，用一个群体解码器 来增强群体的表示。</p>
<h4 id="Encoders"><a href="#Encoders" class="headerlink" title="Encoders"></a>Encoders</h4><p>采用了两个并行编码器来embed上下文特征。在一个分支中，作者采用了一个基于Transformer的空间编码器 来学习个体的上下文信息。将时间维度视为Batch维度，并应用一个编码器来建模所有帧的空间上下文。</p>
<p>另一种并行时间编码器 利用时间动态线索增强输入特征，通过突出每个个体沿时间维度的信息特征来丰富时间上下文。时间编码器遵循空间编码器的操作。与上述空间编码器的不同之处在于，时间编码器将空间维度视为一个Batch维度。</p>
<h4 id="Individual-Decoders"><a href="#Individual-Decoders" class="headerlink" title="Individual Decoders"></a>Individual Decoders</h4><p>作者提出了个体解码器 来综合考虑空间和时空上下文信息。个体解码器遵循标准Transformer的解码器的设计，来互补利用时空上下文。</p>
<p>对于空间解码器 ，空间编码器的输出结果被视为 actor query，时间编码器输出结果的embedding被视为key和value。actor query和key、value进行cross-attention，捕获时间动态，并输出更新后的上下文特征。</p>
<p>同样的，对于时间解码器 ，空间编码器的输出结果将时间维度与空间维度进行转换，可以看作是解码器使用的key和value。解码器将时间上下文视为time query，然后进行cross-attention的过程，时间解码器有助于查找视频中感兴趣的帧。</p>
<p>最后，将这两个交叉解码器的输出embedding进行融合，生成增强的个体表示。这两种交叉解码器是利用了基于空间上下文和时间上下文的语义关联来增强个体表征。</p>
<h4 id="Group-Decoder"><a href="#Group-Decoder" class="headerlink" title="Group Decoder"></a>Group Decoder</h4><p>引入了一个群体解码器 （Group Decoder）来通过个体表示来增强群体表示。群体解码器也遵循Transformer的解码器设计。与原Transformer的区别在于，群体解码器只包含多头交叉注意机制和一个前馈网络，不包含Self-Attention。</p>
<h3 id="Clustered-Attention-Mechanism"><a href="#Clustered-Attention-Mechanism" class="headerlink" title="Clustered Attention Mechanism"></a>Clustered Attention Mechanism</h3><p>虽然基于全连接注意机制的时空Transformer(STT)能够建模个体的关系，但它包含了许多不相关个体的关系。为了使模型能够关注关键的群体关系，作者将全连接的注意力替换为聚类的注意力，并将整个模块称之为聚类时空Transformer(Clustered Spatial-Temporal Transformer，CSTT) 。它可以对个体进行分组，并利用组内和组间的关系来捕获全局活动上下文。</p>
<p>首先将个体分组为C个聚类，然后计算一下两种类型的注意：</p>
<ol>
<li>组内注意（intra-group attention） ：只有来自同一个聚类内的query和key才会被考虑。</li>
<li>组间注意（inter-group attention） ：考虑了聚类之间成对的加权连接。</li>
</ol>
<h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>本文提出的CSTT以端到端的方式进行训练。在CSTT中，可以直接从群体表示生成群体活动分数。同样，采用另一个分类器，使用CSTT生成的个体表示来预测个体的动作得分。对于这两个任务，作者都选择了交叉熵损失函数来指导优化过程：</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，作者提出了一种新的基于Transformer的结构，称为GroupFormer，它联合建模了时空上下文表示来推断群体活动。此外，作者还引入了聚类注意机制来对个体进行分组，并利用组内和组间的关系获得更好的群体特征表示。作者在两个数据集上进行了广泛的实验。结果表明，GroupFormer的表现超过了大多数目前的SOTA方法。</p>
]]></content>
      <categories>
        <category>懵逼的深度学习</category>
      </categories>
      <tags>
        <tag>群体行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>labelImg闪退错误修复</title>
    <url>/2021/12/05/labelImg%E9%97%AA%E9%80%80%E9%94%99%E8%AF%AF%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>使用labelImg时，在未选中数据标签时按<code>Ctrl+D</code>时会闪退，在终端中有以下报错</p>
<span id="more"></span>
<p><img src="/image/labelImg闪退错误修复/1.png" alt="1"></p>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>在<code>/usr/lib/python3.9/site-packages/labelImg/labelImg.py</code> 第784行，没有数据标签选中时<code>shape</code>对象没有<code>paint_label</code>属性，添加一个条件过滤就好</p>
<p>第783行<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_label</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">    shape.paint_label = self.display_label_option.isChecked()</span><br><span class="line">    item = HashableQListWidgetItem(shape.label)</span><br><span class="line">    item.setFlags(item.flags() | Qt.ItemIsUserCheckable)</span><br><span class="line">    item.setCheckState(Qt.Checked)</span><br><span class="line">    item.setBackground(generate_color_by_text(shape.label))</span><br><span class="line">    self.items_to_shapes[item] = shape</span><br><span class="line">    self.shapes_to_items[shape] = item</span><br><span class="line">    self.label_list.addItem(item)</span><br><span class="line">    <span class="keyword">for</span> action <span class="keyword">in</span> self.actions.onShapesPresent:</span><br><span class="line">        action.setEnabled(<span class="literal">True</span>)</span><br><span class="line">    self.update_combo_box()</span><br></pre></td></tr></table></figure></p>
<p>改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_label</span>(<span class="params">self, shape</span>):</span></span><br><span class="line">    <span class="keyword">if</span> shape <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add empty label&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    shape.paint_label = self.display_label_option.isChecked()</span><br><span class="line">    item = HashableQListWidgetItem(shape.label)</span><br><span class="line">    item.setFlags(item.flags() | Qt.ItemIsUserCheckable)</span><br><span class="line">    item.setCheckState(Qt.Checked)</span><br><span class="line">    item.setBackground(generate_color_by_text(shape.label))</span><br><span class="line">    self.items_to_shapes[item] = shape</span><br><span class="line">    self.shapes_to_items[shape] = item</span><br><span class="line">    self.label_list.addItem(item)</span><br><span class="line">    <span class="keyword">for</span> action <span class="keyword">in</span> self.actions.onShapesPresent:</span><br><span class="line">        action.setEnabled(<span class="literal">True</span>)</span><br><span class="line">    self.update_combo_box()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>懵逼的深度学习</category>
      </categories>
      <tags>
        <tag>labelImg</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab画图功能再探</title>
    <url>/2021/10/08/matlab%E7%94%BB%E5%9B%BE%E5%8A%9F%E8%83%BD%E5%86%8D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>复习了一下 matlab 里面的基本画图函数的属性</p>
<span id="more"></span>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all;</span><br><span class="line">th = <span class="built_in">linspace</span>()<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">fig1 = <span class="built_in">plot</span>(th,<span class="built_in">sin</span>(th),<span class="string">&#x27;g&#x27;</span>,th,<span class="built_in">cos</span>(th),<span class="string">&#x27;b:&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/image/matlab使用方法再探/1.svg" alt="1"></p>
<p>plot 命令返回一个标识图形目标的向量，其元素称为句柄，这些句柄可以确定目标的特性.若想知道第一条曲线的特性，输入<code>get(fig1(1))</code>，不要关闭Figure 1窗口.</p>
<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">输出</summary><pre><code class="matlab">
    AlignVertexCenters: off
            Annotation: [1×1 matlab.graphics.eventdata.Annotation]
          BeingDeleted: off
            BusyAction: 'queue'
         ButtonDownFcn: ''
              Children: [0×0 GraphicsPlaceholder]
              Clipping: on
                 Color: [0 1 0]
             ColorMode: 'manual'
           ContextMenu: [0×0 GraphicsPlaceholder]
             CreateFcn: ''
       DataTipTemplate: [1×1 matlab.graphics.datatip.DataTipTemplate]
             DeleteFcn: ''
           DisplayName: ''
      HandleVisibility: 'on'
               HitTest: on
         Interruptible: on
              LineJoin: 'round'
             LineStyle: '-'
         LineStyleMode: 'auto'
             LineWidth: 0.5000
                Marker: 'none'
       MarkerEdgeColor: 'auto'
       MarkerFaceColor: 'none'
         MarkerIndices: [1×100 uint64]
            MarkerMode: 'auto'
            MarkerSize: 6
                Parent: [1×1 Axes]
         PickableParts: 'visible'
              Selected: off
    SelectionHighlight: on
           SeriesIndex: 1
                   Tag: ''
                  Type: 'line'
              UserData: []
               Visible: on
                 XData: [1×100 double]
             XDataMode: 'manual'
           XDataSource: ''
                 YData: [1×100 double]
           YDataSource: ''
                 ZData: [1×0 double]
           ZDataSource: ''
</code></pre></details>

<p>若想了解第二第曲线的特性，输入<code>get(fig1(2))</code>，不要关闭Figure 1窗口.</p>
<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">输出</summary><pre><code class="matlab">    AlignVertexCenters: off
            Annotation: [1×1 matlab.graphics.eventdata.Annotation]
          BeingDeleted: off
            BusyAction: 'queue'
         ButtonDownFcn: ''
              Children: [0×0 GraphicsPlaceholder]
              Clipping: on
                 Color: [0 0 1]
             ColorMode: 'manual'
           ContextMenu: [0×0 GraphicsPlaceholder]
             CreateFcn: ''
       DataTipTemplate: [1×1 matlab.graphics.datatip.DataTipTemplate]
             DeleteFcn: ''
           DisplayName: ''
      HandleVisibility: 'on'
               HitTest: on
         Interruptible: on
              LineJoin: 'round'
             LineStyle: ':'
         LineStyleMode: 'manual'
             LineWidth: 0.5000
                Marker: 'none'
       MarkerEdgeColor: 'auto'
       MarkerFaceColor: 'none'
         MarkerIndices: [1×100 uint64]
            MarkerMode: 'manual'
            MarkerSize: 6
                Parent: [1×1 Axes]
         PickableParts: 'visible'
              Selected: off
    SelectionHighlight: on
           SeriesIndex: 2
                   Tag: ''
                  Type: 'line'
              UserData: []
               Visible: on
                 XData: [1×100 double]
             XDataMode: 'manual'
           XDataSource: ''
                 YData: [1×100 double]
           YDataSource: ''
                 ZData: [1×0 double]
           ZDataSource: ''</code></pre></details>

<p>对于图形本身，由于是第一的图形，所以句柄是1，输入<code>get(1)</code></p>
<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">输出</summary><pre><code class="matlab">
                 Alphamap: [1×64 double]
             BeingDeleted: off
               BusyAction: 'queue'
            ButtonDownFcn: ''
                 Children: [1×1 Axes]
                 Clipping: on
          CloseRequestFcn: 'closereq'
                    Color: [0.9400 0.9400 0.9400]
                 Colormap: [256×3 double]
              ContextMenu: [0×0 GraphicsPlaceholder]
                CreateFcn: ''
              CurrentAxes: [1×1 Axes]
         CurrentCharacter: ''
            CurrentObject: [1×1 Line]
             CurrentPoint: [408 289]
                DeleteFcn: ''
             DockControls: on
                 FileName: '/home/pacaep/aepBlog/source/image/plot使用方法再探/1.svg'
        GraphicsSmoothing: on
         HandleVisibility: 'on'
                     Icon: ''
            InnerPosition: [200 200 600 472]
            IntegerHandle: on
            Interruptible: on
           InvertHardcopy: on
              KeyPressFcn: ''
            KeyReleaseFcn: ''
                  MenuBar: 'figure'
                     Name: ''
                 NextPlot: 'add'
                   Number: 1
              NumberTitle: on
            OuterPosition: [200 200 600 557]
         PaperOrientation: 'portrait'
            PaperPosition: [1.1250 3.0417 6.2500 4.9167]
        PaperPositionMode: 'auto'
                PaperSize: [8.5000 11]
                PaperType: 'usletter'
               PaperUnits: 'inches'
                   Parent: [1×1 Root]
                  Pointer: 'arrow'
        PointerShapeCData: [16×16 double]
      PointerShapeHotSpot: [8 8]
                 Position: [200 200 600 472]
                 Renderer: 'opengl'
             RendererMode: 'auto'
                   Resize: on
               Scrollable: off
            SelectionType: 'alt'
           SizeChangedFcn: ''
                      Tag: ''
                  ToolBar: 'auto'
                     Type: 'figure'
                    Units: 'pixels'
                 UserData: []
                  Visible: on
      WindowButtonDownFcn: ''
    WindowButtonMotionFcn: ''
        WindowButtonUpFcn: ''
        WindowKeyPressFcn: ''
      WindowKeyReleaseFcn: ''
     WindowScrollWheelFcn: ''
              WindowState: 'normal'
              WindowStyle: 'normal'
                 XDisplay: ':0'</code></pre></details>
为了解图形窗口的设置，输入`set(1)`
`set(H,Name,Value)` 为 H 标识的对象指定其 Name 属性的值
从图像中删去余弦曲线，输入`delete(fig1(2))`
`refresh`命令可以刷新图像.
建立一个新的图形窗口，保留前一个图形窗口，输入`H=figure`，将打开新的图形窗口并设定为活动，输入`gcf`获得当前图形的句柄.

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">输出</summary><pre><code class="matlab">
  Figure (2) - 属性:
      Number: 2
        Name: ''
       Color: [0.9400 0.9400 0.9400]
    Position: [200 200 600 472]
       Units: 'pixels'
</code></pre></details>]]></content>
      <categories>
        <category>使用教程</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>伽马函数</title>
    <url>/2021/10/17/%E4%BC%BD%E9%A9%AC%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>遇到了这个伽马函数， 许多博客说对考研很重要，就浅浅记录一下</p>
<span id="more"></span>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在数学中，$\Gamma$函数（伽玛函数；Gamma函数），是阶乘函数在实数与复数域上的扩展。如果$n$为正整数，则：</p>
<script type="math/tex; mode=display">\Gamma (n) = (n-1)!</script><p>对于实数部分为正的复数$\alpha$，伽玛函数为：</p>
<script type="math/tex; mode=display">\Gamma(\alpha) = \int_0^{+\infty} x^{\alpha-1}e^{-x}dx(a>0)</script><script type="math/tex; mode=display">\Gamma(\alpha+1) = \alpha \Gamma(\alpha)</script><h2 id="常用的数值"><a href="#常用的数值" class="headerlink" title="常用的数值"></a>常用的数值</h2><script type="math/tex; mode=display">\Gamma(1) = 1</script><script type="math/tex; mode=display">\Gamma(\frac{1}{2}) = \sqrt{\pi}</script><script type="math/tex; mode=display">\Gamma(n+1) = n!</script>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>使用平行线段的相机标定[计划更新]</title>
    <url>/2022/04/16/%E4%BD%BF%E7%94%A8%E5%B9%B3%E8%A1%8C%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一种使用平行线段来进行相机标定以及形状重建的方法</p>
<span id="more"></span>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>监控摄像机标定一直是计算机视觉工业应用的一个重要课题。内部和外部参数都必须精确校准，才能从记录的 2D 图像或视频中识别出 3D 场景中发生的事情，相机标定的一般方法是使用标定对象，如棋盘标定。然而，这些方法对于监控摄像机来说往往是不切实际的，因为它们需要一个足够大的校准对象来覆盖整个拍摄区域。</p>
<blockquote>
<p> 原论文下载：<a href="https://aeeeeeep.github.io/papers/icpr2020_nakano.pdf">https://aeeeeeep.github.io/papers/icpr2020_nakano.pdf</a></p>
</blockquote>
<h2 id="直线提取"><a href="#直线提取" class="headerlink" title="直线提取"></a>直线提取</h2><h3 id="Canny"><a href="#Canny" class="headerlink" title="Canny"></a>Canny</h3><h3 id="Hough-Transform"><a href="#Hough-Transform" class="headerlink" title="Hough Transform"></a>Hough Transform</h3><h2 id="形状重建"><a href="#形状重建" class="headerlink" title="形状重建"></a>形状重建</h2><h3 id="Affine-Rectification"><a href="#Affine-Rectification" class="headerlink" title="Affine Rectification"></a>Affine Rectification</h3><h3 id="Euclidean-Rectification"><a href="#Euclidean-Rectification" class="headerlink" title="Euclidean Rectification"></a>Euclidean Rectification</h3><h2 id="度量指标属性"><a href="#度量指标属性" class="headerlink" title="度量指标属性"></a>度量指标属性</h2><h2 id="相机标定"><a href="#相机标定" class="headerlink" title="相机标定"></a>相机标定</h2><h2 id="世界坐标定位"><a href="#世界坐标定位" class="headerlink" title="世界坐标定位"></a>世界坐标定位</h2><h2 id="3D-形状重构"><a href="#3D-形状重构" class="headerlink" title="3D 形状重构"></a>3D 形状重构</h2><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="Fitting-Vanishing-Point"><a href="#Fitting-Vanishing-Point" class="headerlink" title="Fitting Vanishing Point"></a>Fitting Vanishing Point</h3><h3 id="Fitting-Line-at-Infinity"><a href="#Fitting-Line-at-Infinity" class="headerlink" title="Fitting Line at Infinity"></a>Fitting Line at Infinity</h3><h3 id="Fitting-Conics"><a href="#Fitting-Conics" class="headerlink" title="Fitting Conics"></a>Fitting Conics</h3><h2 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h2><h2 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/EmanueleGhelfi/iacv">https://github.com/EmanueleGhelfi/iacv</a> (matlab)</li>
</ul>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Opencv+Python的AR小demo</title>
    <url>/2022/02/23/%E4%BD%BF%E7%94%A8Opencv+Python%E7%9A%84AR%E5%B0%8Fdemo/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>浅浅了解一下 Python OpenCV，试着给自己的 iphone 8 做一下相机标定</p>
<span id="more"></span>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>增强现实( AR ) 是一种真实世界环境的交互式体验，其中存在于现实世界中的对象通过计算机生成的感知信息得到增强，有时跨越多种感官模式，包括视觉、听觉、触觉、体感和嗅觉。AR 可以定义为一个包含三个基本特征的系统：真实和虚拟世界的结合、实时交互以及虚拟和真实对象的准确 3D 配准。重叠的感觉信息可以是建设性的（即对自然环境的补充）或破坏性的（即对自然环境的掩蔽）。这种体验与物理世界无缝交织，因此被视为真实环境的沉浸式体验。[4]通过这种方式，增强现实改变了人们对现实世界环境的持续感知，而虚拟现实完全用模拟环境取代了用户的现实世界环境。增强现实与两个主要同义词相关：混合现实和计算机介导的现实。</p>
<p align="right">——以上内容来自Wiki百科</p>

</blockquote>
<h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h3 id="Vision-based-AR（基于计算机视觉的AR）"><a href="#Vision-based-AR（基于计算机视觉的AR）" class="headerlink" title="Vision based AR（基于计算机视觉的AR）"></a>Vision based AR（基于计算机视觉的AR）</h3><h4 id="Marker-Based-AR-（基于标定的AR）"><a href="#Marker-Based-AR-（基于标定的AR）" class="headerlink" title="Marker-Based AR （基于标定的AR）"></a>Marker-Based AR （基于标定的AR）</h4><p>如：</p>
<p><img src="/image/使用Opencv+Python的AR小demo/6.png" alt=""></p>
<h4 id="Marker-Less-AR（基于特征点的AR"><a href="#Marker-Less-AR（基于特征点的AR" class="headerlink" title="Marker-Less AR（基于特征点的AR)"></a>Marker-Less AR（基于特征点的AR)</h4><p>如：</p>
<p><img src="/image/使用Opencv+Python的AR小demo/7.png" alt=""></p>
<h3 id="LBS-based-AR（基于地理位置信息的AR）"><a href="#LBS-based-AR（基于地理位置信息的AR）" class="headerlink" title="LBS based AR（基于地理位置信息的AR）"></a>LBS based AR（基于地理位置信息的AR）</h3><p>如：</p>
<p><img src="/image/使用Opencv+Python的AR小demo/8.png" alt=""></p>
<blockquote>
<p>本文将具体讲解和实验基于特征点的AR技术 </p>
</blockquote>
<h2 id="Demo-演示"><a href="#Demo-演示" class="headerlink" title="Demo 演示"></a>Demo 演示</h2><h3 id="演示环境"><a href="#演示环境" class="headerlink" title="演示环境"></a>演示环境</h3><ul>
<li><p>iphone 8 手机：App Store 下载 Focus [+] # 手动对焦拍摄</p>
</li>
<li><p>计算机：vim，python和 conda</p>
</li>
<li><p>OpenCV 棋盘标定纸</p>
</li>
</ul>
<p><img src="/image/使用Opencv+Python的AR小demo/calibration_img/9.png" alt=""></p>
<h3 id="准备图片"><a href="#准备图片" class="headerlink" title="准备图片"></a>准备图片</h3><ul>
<li>参考图片</li>
</ul>
<p><img src="/image/使用Opencv+Python的AR小demo/referenceImage.png" alt=""></p>
<ul>
<li>用例图片</li>
</ul>
<p><img src="/image/使用Opencv+Python的AR小demo/sourceImage.png" alt=""></p>
<h3 id="相机标定原理"><a href="#相机标定原理" class="headerlink" title="相机标定原理"></a>相机标定原理</h3><p>从世界坐标系转换到图像坐标系，求投影矩阵 $P$ 的过程</p>
<p>分为两步</p>
<ul>
<li>从世界坐标系转换为相机坐标系，这一步是三维点到三维点的转换，包括 $R,t$ （相机外参）等参数</li>
</ul>
<p><img src="/image/使用Opencv+Python的AR小demo/5.png" alt="5"></p>
<script type="math/tex; mode=display">
\widetilde{X}_{c a m}=R(\widetilde{X}-\widetilde{C})</script><pre><code>* $ \widetilde&#123;X&#125; $ 为 $X$ 在世界坐标中的位置
* $ R $ 为旋转矩阵
* $ \widetilde&#123;C&#125; $ 为相机原点 $C$ 所在世界坐标中的位置
* $ \widetilde&#123;X&#125;_&#123;c a m&#125; $ 为 $ X $ 在相机坐标系中的位置
</code></pre><ul>
<li>从相机坐标系转换为图像坐标系，这一步是三维点到二维点的转换，包括 $K$（相机内参）等参数</li>
</ul>
<p><img src="/image/使用Opencv+Python的AR小demo/9.png" alt=""></p>
<ul>
<li><p>$C$为相机的中心点，也是相机坐标系的中心点</p>
</li>
<li><p>$Z$为相机的主轴</p>
</li>
<li><p>$p$为相机的像平面，也就是图片坐标系所在的二维平面</p>
</li>
<li><p>$C$ 点到 $p$点的距离$f$，为相机的焦距</p>
</li>
</ul>
<p>可得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
x &=f X / Z \\
y &=f Y / Z \\
(X, \quad Y, \quad Z) & \mapsto(f X / Z, \quad f Y / Z)
\end{aligned}</script><p>由图可知偏移量</p>
<p><img src="/image/使用Opencv+Python的AR小demo/10.png" alt=""></p>
<script type="math/tex; mode=display">
(X, \quad Y, \quad Z) \mapsto\left(f X / Z+p_{x}, \quad f Y / Z+p_{y}\right)</script><p>矩阵形式为</p>
<script type="math/tex; mode=display">
\left(\begin{array}{c}
X \\
Y \\
Z \\
    1
\end{array}\right) \mapsto\left(\begin{array}{c}
f X+Z p_{x} \\
f Y+Z p_{y} \\
Z
\end{array}\right)=\left[\begin{array}{ccc}
f & p_{x} & 0 \\
& f & p_{y} & 0 \\
& & 1 & 0
\end{array}\right]\left(\begin{array}{c}
X \\
Y \\
Z \\
1
\end{array}\right)</script><p>化简得</p>
<script type="math/tex; mode=display">
\left(\begin{array}{c}
f X+Z p_{x} \\
f Y+Z p_{y} \\
Z
\end{array}\right)=\left[\begin{array}{cc}
f & p_{x} \\
& f & p_{y} \\
& & 1
\end{array}\right]\left[\begin{array}{llll}
1 & & & 0 \\
& 1 & & 0 \\
& & 1 & 0
\end{array}\right]\left(\begin{array}{l}
X \\
Y \\
Z \\
1
\end{array}\right)</script><p>则</p>
<script type="math/tex; mode=display">
K=\left[\begin{array}{ccc}
f & & p_{x} \\
& f & p_{y} \\
& & 1
\end{array}\right]</script><p>设旋转矩阵 $R$ 为单位矩阵 $I$，平移矩阵 $t$ 为0</p>
<script type="math/tex; mode=display">
\begin{aligned}
P &=K[R \mid t] \\
&=K[I \mid 0]
\end{aligned}</script><blockquote>
<p>畸变参数本例未考虑到，不作讨论</p>
</blockquote>
<h3 id="获得相机标定矩阵"><a href="#获得相机标定矩阵" class="headerlink" title="获得相机标定矩阵"></a>获得相机标定矩阵</h3><h4 id="手动对焦，固定焦距，拍摄各个方面的标定板"><a href="#手动对焦，固定焦距，拍摄各个方面的标定板" class="headerlink" title="手动对焦，固定焦距，拍摄各个方面的标定板"></a>手动对焦，固定焦距，拍摄各个方面的标定板</h4><p><img src="/image/使用Opencv+Python的AR小demo/11.png" alt=""></p>
<h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ul>
<li>提取角点 本例使用的标定板来自 <a href="https://calib.io/pages/camera-calibration-pattern-generator">calib</a>  有13 * 9 个角点</li>
<li>提取亚像素角点 提高精度</li>
<li>角点绘制</li>
<li>标定</li>
</ul>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/image/使用Opencv+Python的AR小demo/13.png" alt=""></p>
<p>得到 iphone 8 的相机标定矩阵为 (代码见camera_calibration.py)</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1.09358481e+03</span> <span class="number">0.00000000e+00</span> <span class="number">5.12119524e+02</span>]</span><br><span class="line">[<span class="number">0.00000000e+00</span> <span class="number">1.08983166e+03</span> <span class="number">6.61345525e+02</span>]</span><br><span class="line">[<span class="number">0.00000000e+00</span> <span class="number">0.00000000e+00</span> <span class="number">1.00000000e+00</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h3><h4 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a>特征检测</h4><p>使用ORB法进行特征检测，ORB基于FAST算法，FAST算法的原理如下</p>
<p><img src="/image/使用Opencv+Python的AR小demo/12.png" alt=""></p>
<p>任选图像中的一点 $P$，以该点为圆形，$r$为半径确定一个圆，在圆上均匀取$m$个像素点，设定一个阈值$t$，如果$m$个像素点中，有连续$N$个像素点的大小均大于或小于$t$，则这个点就是角点。但是在进行FAST进行角点检测时，边缘位置的部分易混淆，针对这种情况，ORB算法通过增加图像金字塔和计算角度的方法，用Harris角点检测器把$N$个关键点进行等级排序，使用者可提取前n个自己需要的点。不同的是，ORB在进行特征点匹配时，检测出的角点需要满足尺度不变形和旋转不变性。</p>
<ul>
<li>尺度不变形</li>
</ul>
<p>通过对初始图像的按1/2的比例不断下采样(即按1/2的比例不断缩放)，得到一系列图像，形成图像金字塔。对每层图像，进行FAST角点检测</p>
<ul>
<li>旋转不变形</li>
</ul>
<p>采用灰度质心法进行计算每个特征点的主方向</p>
<script type="math/tex; mode=display">
\mathrm{m}_{p q}=\sum_{x, y} x^{p} y^{q} I(x, y)</script><p>其中$x,y$分别表示像素点周围圆上所选取点的横坐标和纵坐标，$I(x,y)$表示灰度值大小，$p,q$表示指数，角度计算的方法如下</p>
<script type="math/tex; mode=display">
\theta=\operatorname{atan} 2(\mathrm{m_{01}}, \mathrm{m_{10}})</script><h4 id="特征描述"><a href="#特征描述" class="headerlink" title="特征描述"></a>特征描述</h4><p>ORB法采用BRIEF描述子计算算法实现，BRIEF算法可分为两步</p>
<ul>
<li>特征点大小的对比</li>
</ul>
<p>以特征点为中心，取邻域窗口，在窗口上选择两个点p(x)和p(y)，比较两个点像素值的大小</p>
<script type="math/tex; mode=display">
\tau(p ; x, y):=\left\{\begin{array}{cc}
1 & if\quad p(x)<p(y) \\
0 & \text { otherwise }
\end{array}\right.</script><ul>
<li>重复第一步进行像素值大小的比较，形成二进制编码</li>
</ul>
<p>OBR算法对BRIEF有两种改变，分别为 steer BRIEF 和 rBRIEF</p>
<ul>
<li>steer BRIEF具备旋转不变形的特征，已知 $ /theta $，将该点周围的点旋转 $ /theta $ 度，得到新的点对<script type="math/tex; mode=display">
D_{\theta}=R_{\theta} D</script></li>
</ul>
<p>$R$ 为旋转矩阵<br>旋转后，在新的位置上比较像素值的大小，得到描述子</p>
<ul>
<li>rBRIEF算法通过改变描述子的计算方法，进一步减弱同一图像中特征点的描述子的相关性，对每个角点，考虑其 $31X31$ 的邻域，使用领域中每个点周围的 $5X5$ 的邻域的像素值平均值作为该点的像素值，进而比较点对的大小。上面计算可得到 $(31-5+1)*(31-5+1)=729$ 个子窗口，提取点对的方法有 $729X728=265356$ 种，通过在这 $265356$ 中方法中选取 $256$ 种取法，形成描述子</li>
</ul>
<p>结果</p>
<p><img src="/image/使用Opencv+Python的AR小demo/1.png" alt=""></p>
<h4 id="特征匹配"><a href="#特征匹配" class="headerlink" title="特征匹配"></a>特征匹配</h4><p>本例使用 Brute-Force Matcher 进行特征匹配，也就是暴力匹配</p>
<p>结果</p>
<p><img src="/image/使用Opencv+Python的AR小demo/2.png" alt=""></p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>将参考图像表面的平面的点映射到用例图像的平面上，也就是单应性变换，单应性变换是将一个平面（齐次坐标）中的点映射到另一个平面的二维投影变换</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
z^{\prime}
\end{array}\right]=\left[\begin{array}{lll}
h_{1} & h_{2} & h_{3} \\
h_{4} & h_{5} & h_{6} \\
h_{7} & h_{8} & h_{9}
\end{array}\right]\left[\begin{array}{l}
x \\
y \\
z
\end{array}\right]</script><p>从两个图像中传递点集，它将找到该对象的透视变换，至少需要四个正确的点才能找到转换，但两幅图像之间的单应性变换包含不适合的点。会导致匹配时出现错误，影响结果，使用 RANSAC 迭代法验证拟合</p>
<p>结果</p>
<p><img src="/image/使用Opencv+Python的AR小demo/3.png" alt=""></p>
<h4 id="3D-绘制"><a href="#3D-绘制" class="headerlink" title="3D 绘制"></a>3D 绘制</h4><p>使用 <a href="https://github.com/yarolig/OBJFileLoader">yarolig的OBJFileLoader</a> 加载 3D obj 模型 (代码见 objloader_simple.py)</p>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="/image/使用Opencv+Python的AR小demo/4.png" alt="4"></p>
<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">ar_python_opencv.py</summary><pre><code class="python">
import cv2
import numpy as np
import math
import matplotlib.pyplot as plt
from objloader_simple import *
referenceImage = cv2.imread('/home/pacaep/Tests/OpenCvArDemo/img/referenceImage.png',0)
plt.imshow(referenceImage, cmap = 'gray')
sourceImage = cv2.imread('/home/pacaep/Tests/OpenCvArDemo/img/sourceImage.png',0)
plt.imshow(sourceImage, cmap='gray')

orb = cv2.ORB_create()

referenceImagePts = orb.detect(referenceImage, None)
sourceImagePts = orb.detect(sourceImage, None)

referenceImagePts, referenceImageDsc = orb.compute(referenceImage, referenceImagePts)
sourceImagePts, sourceImageDsc = orb.compute(sourceImage, sourceImagePts)

referenceImageFeatures = cv2.drawKeypoints(referenceImage, referenceImagePts,
                                                                                        referenceImage, color = (0,255,0), flags = 0)
sourceImageFeatures = cv2.drawKeypoints(sourceImage, sourceImagePts,
                                                                                        sourceImage, color = (0,255,0), flags = 0)

plt.figure(figsize=(10,5))
plt.subplot(1,2,1)
plt.axis("off")
plt.imshow(referenceImageFeatures, cmap = 'gray')
plt.title('Reference Image Features')
plt.subplot(1,2,2)
plt.axis("off")
plt.imshow(sourceImageFeatures,cmap='gray')
plt.title('Source Image Features')
plt.tight_layout()
plt.show()

MIN_MATCHES = 30
bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck = True)
referenceImagePts, referenceImageDsc = orb.detectAndCompute(referenceImage, None)
sourceImagePts, sourceImageDsc = orb.detectAndCompute(sourceImage, None)
matches = bf.match(referenceImageDsc, sourceImageDsc)
matches = sorted(matches, key = lambda x: x.distance)

if len(matches) > MIN_MATCHES:
    idxPairs = cv2.drawMatches(referenceImage, referenceImagePts,
                                sourceImage, sourceImagePts, matches[:MIN_MATCHES],0,flags =2)

    plt.figure(figsize=(12,6))
    plt.axis('off')
    plt.imshow(idxPairs, cmap='gray')
    plt.title('Matching between features')
    plt.show()

else:
    print("Not enough matches have been found - %d/%d" %(len(matches), MIN_MATCHES))
    matchesMask = None

if len(matches) > MIN_MATCHES:
    sourcePoints = np.float32([referenceImagePts[m.queryIdx].pt for m in matches]).reshape(-1,1,2)
    destinationPoints = np.float32([sourceImagePts[m.trainIdx].pt for m in matches]).reshape(-1,1,2)
    homography, mask = cv2.findHomography(sourcePoints, destinationPoints, cv2.RANSAC, 5.0)
    matchesMask = mask.ravel().tolist()

    h, w = referenceImage.shape
    corners = np.float32([[0, 0], [0, h - 1], [w - 1, h - 1], [w - 1, 0]]).reshape(-1, 1, 2)
    transformedCorners = cv2.perspectiveTransform(corners, homography)

    sourceImageMarker = cv2.polylines(sourceImage, [np.int32(transformedCorners)], True,
                                      255, 5, cv2.LINE_AA)

else:
    print("Not enough matches are found - %d/%d" % (len(matches), MIN_MATCHES))
    matchesMask = None

drawParameters = dict(matchColor=(0, 255, 0), singlePointColor=None,
                      matchesMask=matchesMask, flags=2)
result = cv2.drawMatches(referenceImage, referenceImagePts, sourceImageMarker,
                         sourceImagePts, matches, None, **drawParameters)

plt.figure(figsize=(12, 6))
plt.imshow(result, cmap='gray')
plt.show()

camera_parameters = np.array([[1108.38916, 0,          513.796472],
                              [0,          1111.41724, 661.637500],
                              [0,          0,          1]])

obj = OBJ('/home/pacaep/Tests/OpenCvArDemo/models/fox.obj', swapyz = True)

def projection_matrix(camera_parameters, homography):
    homography = homography * (-1)
    rot_and_transl = np.dot(np.linalg.inv(camera_parameters), homography )
    col_1 = rot_and_transl[:,0]
    col_2 = rot_and_transl[:,1]
    col_3 = rot_and_transl[:,2]

    l = math.sqrt(np.linalg.norm(col_1, 2) * np.linalg.norm(col_2, 2))
    rot_1 = col_1 / l
    rot_2 = col_2 / l
    translation = col_3 / l

    c = rot_1 + rot_2
    p = np.cross(rot_1, rot_2)
    d = np.cross(c,p)
    rot_1 = np.dot(c/np.linalg.norm(c,2) + d / np.linalg.norm(d,2), 1/math.sqrt(2))
    rot_2 = np.dot(c/np.linalg.norm(c,2) - d / np.linalg.norm(d,2), 1/math.sqrt(2))
    rot_3 = np.cross(rot_1, rot_2)

    projection = np.stack((rot_1, rot_2, rot_3, translation)).T
    return np.dot(camera_parameters, projection)

def render(img, obj, projection, model, color=False):
    vertices = obj.vertices
    scale_matrix = np.eye(3)*6
    h,w = model.shape

    for face in obj.faces:
        face_vertices = face[0]
        points = np.array([vertices[vertex -1] for vertex in face_vertices])
        points = np.dot(points, scale_matrix)

        points = np.array([[p[0] + w / 2, p[1] + h/2, p[2]] for p in points])
        dst = cv2.perspectiveTransform(points.reshape(-1,1,3), projection)
        imgpts = np.int32(dst)

        cv2.fillConvexPoly(img, imgpts, (80, 217, 81))
    return img

sourcePoints = np.float32([referenceImagePts[m.queryIdx].pt for m in matches]).reshape(-1,1,2)
destinationPoints = np.float32([sourceImagePts[m.trainIdx].pt for m in matches]).reshape(-1,1,2)

homography, _ = cv2.findHomography(sourcePoints,destinationPoints, cv2.RANSAC, 5.0)
matchesMask = mask.ravel().tolist()
h, w = referenceImage.shape
corners = np.float32([[0,0],[0,h-1],[w-1,h-1],[w-1,0]]).reshape(-1,1,2)
transformedCorners = cv2.perspectiveTransform(corners, homography)
frame = cv2.polylines(sourceImage, [np.int32(transformedCorners)], True, 255,3,cv2.LINE_AA)
projection = projection_matrix(camera_parameters, homography)
frame = render(frame, obj, projection, referenceImage, True)

plt.figure(figsize=(6,12))
plt.imshow(frame, cmap='gray')
plt.show()
</code></pre></details>

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">camera_calibration.py</summary><pre><code class="python">
import cv2
import numpy as np
import glob

criteria = (cv2.TERM_CRITERIA_MAX_ITER | cv2.TERM_CRITERIA_EPS, 30, 0.001)

objp = np.zeros((9 * 13, 3), np.float32)
objp[:, :2] = np.mgrid[0:13, 0:9].T.reshape(-1, 2)

obj_points = []
img_points = []

images = glob.glob("/home/pacaep/Tests/OpenCvArDemo/calibration_img/*.png")
i=0;
for fname in images:
    img = cv2.imread(fname)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    size = gray.shape[::-1]
    ret, corners = cv2.findChessboardCorners(gray, (13, 9), None)

    if ret:

        obj_points.append(objp)

        corners2 = cv2.cornerSubPix(gray, corners, (5, 5), (-1, -1), criteria)
        if [corners2]:
            img_points.append(corners2)
        else:
            img_points.append(corners)

        cv2.drawChessboardCorners(img, (13, 9), corners, ret)
        i+=1;
        cv2.imwrite('conimg'+str(i)+'.png', img)
        cv2.waitKey(1500)

print(len(img_points))
cv2.destroyAllWindows()

ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(obj_points, img_points, size, None, None)

print("ret:", ret)
print("mtx:\n", mtx)
print("dist:\n", dist)
print("rvecs:\n", rvecs)
print("tvecs:\n", tvecs )

print("-----------------------------------------------------")

img = cv2.imread(images[2])
h, w = img.shape[:2]
newcameramtx, roi = cv2.getOptimalNewCameraMatrix(mtx,dist,(w,h),1,(w,h))
print (newcameramtx)
print("------------------use undistort-------------------")
dst = cv2.undistort(img,mtx,dist,None,newcameramtx)
x,y,w,h = roi
dst1 = dst[y:y+h,x:x+w]
cv2.imwrite('calibresult.png', dst1)
print ("dst:", dst1.shape)
</code></pre></details>

<details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">objloader_simple.py</summary><pre><code class="python">
class OBJ:
    def __init__(self, filename, swapyz=False):
        self.vertices = []
        self.normals = []
        self.texcoords = []
        self.faces = []
        material = None
        for line in open(filename, "r"):
            if line.startswith('#'): continue
            values = line.split()
            if not values: continue
            if values[0] == 'v':
                v = list(map(float, values[1:4]))
                if swapyz:
                    v = v[0], v[2], v[1]
                self.vertices.append(v)
            elif values[0] == 'vn':
                v = list(map(float, values[1:4]))
                if swapyz:
                    v = v[0], v[2], v[1]
                self.normals.append(v)
            elif values[0] == 'vt':
                self.texcoords.append(map(float, values[1:3]))
            elif values[0] == 'f':
                face = []
                texcoords = []
                norms = []
                for v in values[1:]:
                    w = v.split('/')
                    face.append(int(w[0]))
                    if len(w) >= 2 and len(w[1]) > 0:
                        texcoords.append(int(w[1]))
                    else:
                        texcoords.append(0)
                    if len(w) >= 3 and len(w[2]) > 0:
                        norms.append(int(w[2]))
                    else:
                        norms.append(0)
                self.faces.append((face, norms, texcoords))
</code></pre></details>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>制作目标检测数据集常用python脚本整理</title>
    <url>/2022/04/09/%E5%88%B6%E4%BD%9C%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B8%B8%E7%94%A8python%E8%84%9A%E6%9C%AC%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>制作个人目标检测数据集时，有查找爬取的错误图片，更改标注路径等等需要，写了以下python脚本</p>
<span id="more"></span>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="查找错误图片"><a href="#查找错误图片" class="headerlink" title="查找错误图片"></a>查找错误图片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> imghdr</span><br><span class="line"><span class="keyword">from</span> progressbar <span class="keyword">import</span> ProgressBar</span><br><span class="line"></span><br><span class="line">path =<span class="string">&#x27;./JPEGImages&#x27;</span></span><br><span class="line">original_images =[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, dirs, filenames <span class="keyword">in</span> os.walk(path):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        original_images.append(os.path.join(root, filename))</span><br><span class="line"></span><br><span class="line">original_images = <span class="built_in">sorted</span>(original_images)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;num:&#x27;</span>,<span class="built_in">len</span>(original_images))</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;check_error.txt&#x27;</span>,<span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">error_images =[]</span><br><span class="line">progress = ProgressBar()</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> progress(original_images):</span><br><span class="line">    check = imghdr.what(filename)</span><br><span class="line">    <span class="keyword">if</span> check == <span class="literal">None</span>:</span><br><span class="line">        f.write(filename)</span><br><span class="line">        f.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        error_images.append(filename)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(error_images))</span><br><span class="line">f.seek(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h3 id="按顺序重命名标注文件和图片（分成两部分防止图片和标注文件数量不一致）"><a href="#按顺序重命名标注文件和图片（分成两部分防止图片和标注文件数量不一致）" class="headerlink" title="按顺序重命名标注文件和图片（分成两部分防止图片和标注文件数量不一致）"></a>按顺序重命名标注文件和图片（分成两部分防止图片和标注文件数量不一致）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BatchRename</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path1 = <span class="string">&#x27;./JPEGImages&#x27;</span></span><br><span class="line">        self.path2 = <span class="string">&#x27;./Annotations&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">self</span>):</span></span><br><span class="line">        filelist1 = os.listdir(self.path1)</span><br><span class="line">        filelist1.sort()</span><br><span class="line">        total_num1 = <span class="built_in">len</span>(filelist1)</span><br><span class="line">        i1 = <span class="number">1</span></span><br><span class="line">        srcpath1 = os.path.abspath(self.path1)</span><br><span class="line">        <span class="keyword">for</span> item1 <span class="keyword">in</span> filelist1:</span><br><span class="line">            os.rename(os.path.join(srcpath1, item1), os.path.join(srcpath1, <span class="built_in">str</span>(i1).zfill(<span class="number">5</span>) + <span class="string">&#x27;.jpg&#x27;</span>))</span><br><span class="line">            i1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        filelist2 = os.listdir(self.path2)</span><br><span class="line">        filelist2.sort()</span><br><span class="line">        total_num2 = <span class="built_in">len</span>(filelist2)</span><br><span class="line">        i2 = <span class="number">1</span></span><br><span class="line">        srcpath2 = os.path.abspath(self.path2)</span><br><span class="line">        <span class="keyword">for</span> item2 <span class="keyword">in</span> filelist2:</span><br><span class="line">            os.rename(os.path.join(srcpath2, item2), os.path.join(srcpath2, <span class="built_in">str</span>(i2).zfill(<span class="number">5</span>) + <span class="string">&#x27;.xml&#x27;</span>))</span><br><span class="line">            i2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    demo = BatchRename()</span><br><span class="line">    demo.rename()</span><br></pre></td></tr></table></figure>
<h3 id="修改标注文件中的图片路径为本目录下"><a href="#修改标注文件中的图片路径为本目录下" class="headerlink" title="修改标注文件中的图片路径为本目录下"></a>修改标注文件中的图片路径为本目录下</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilesChange</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path = <span class="string">&#x27;./Annotations&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Change</span>(<span class="params">self</span>):</span></span><br><span class="line">        filelist = os.listdir(self.path)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> filelist:</span><br><span class="line">            srcfile = os.path.join(os.path.abspath(self.path), item)</span><br><span class="line">            item = item.rstrip(<span class="string">&#x27;.xml&#x27;</span>)</span><br><span class="line">            item = item.zfill(<span class="number">5</span>)</span><br><span class="line">            line_replace = <span class="number">2</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(srcfile,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">                lines = fd.readlines()</span><br><span class="line">            lines[line_replace] = (<span class="string">&#x27;        &lt;filename&gt;&#x27;</span> + item + <span class="string">&#x27;.jpg&lt;/filename&gt;\n&#x27;</span>)</span><br><span class="line">            lines[line_replace + <span class="number">1</span>] = (<span class="string">&#x27;        &lt;path&gt;&#x27;</span> + <span class="built_in">format</span>(srcfile[:-<span class="number">21</span>]) + <span class="string">&#x27;JPEGImages/&#x27;</span> + item + <span class="string">&#x27;.jpg&lt;/path&gt;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(srcfile,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">                fd.writelines(lines)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    demo = FilesChange()</span><br><span class="line">    demo.Change()</span><br></pre></td></tr></table></figure>
<h3 id="输出没有标注的图片和标注文件名到-txt-文件"><a href="#输出没有标注的图片和标注文件名到-txt-文件" class="headerlink" title="输出没有标注的图片和标注文件名到 txt 文件"></a>输出没有标注的图片和标注文件名到 txt 文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys,re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleSearch</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path = <span class="string">&#x27;./Annotations&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Search</span>(<span class="params">self</span>):</span></span><br><span class="line">        filetxt = <span class="string">&#x27;NoAppleXml.txt&#x27;</span></span><br><span class="line">        txtlist = []</span><br><span class="line">        filelist = os.listdir(self.path)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> filelist:</span><br><span class="line">            srcfile = os.path.join(os.path.abspath(self.path), item)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(srcfile,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">                content = fd.read()</span><br><span class="line">                target = re.findall(<span class="string">&quot;apple&quot;</span>, content)</span><br><span class="line">            <span class="keyword">if</span> target == []:</span><br><span class="line">                txtlist.append(item.rstrip(<span class="string">&#x27;.xml&#x27;</span>))</span><br><span class="line">        txtpath = os.path.join(os.path.abspath(<span class="string">&#x27;./&#x27;</span>), filetxt)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(txtpath,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> txtlist:</span><br><span class="line">                <span class="built_in">print</span>(i)</span><br><span class="line">                fd.write(<span class="string">&quot;&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(i)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    demo = AppleSearch()</span><br><span class="line">    demo.Search()</span><br></pre></td></tr></table></figure>
<h3 id="从-txt-文件读取要删除的图片和标注文件"><a href="#从-txt-文件读取要删除的图片和标注文件" class="headerlink" title="从 txt 文件读取要删除的图片和标注文件"></a>从 txt 文件读取要删除的图片和标注文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys,fileinput,re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteNoApple</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path1 = <span class="string">&#x27;./JPEGImages&#x27;</span></span><br><span class="line">        self.path2 = <span class="string">&#x27;./Annotations&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        filetxt = <span class="string">&#x27;./NoAppleXml.txt&#x27;</span></span><br><span class="line">        content = []</span><br><span class="line">        txtpath = os.path.join(os.path.abspath(<span class="string">&#x27;./&#x27;</span>), filetxt)</span><br><span class="line">        <span class="comment"># with open(txtpath) as fd:</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fileinput.<span class="built_in">input</span>(txtpath):</span><br><span class="line">            content.append(line.rstrip(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> content:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> content:</span><br><span class="line">                srcpath1 = os.path.join(os.path.abspath(self.path1), i+<span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line">                os.remove(srcpath1)</span><br><span class="line">                srcpath2 = os.path.join(os.path.abspath(self.path2), i+<span class="string">&#x27;.xml&#x27;</span>)</span><br><span class="line">                os.remove(srcpath2)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    demo = DeleteNoApple()</span><br><span class="line">    demo.Delete()</span><br></pre></td></tr></table></figure>
<h3 id="批量图片格式转换-（未过滤-jpg-图片防止图片编码错误）"><a href="#批量图片格式转换-（未过滤-jpg-图片防止图片编码错误）" class="headerlink" title="批量图片格式转换 （未过滤 jpg 图片防止图片编码错误）"></a>批量图片格式转换 （未过滤 jpg 图片防止图片编码错误）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">imgList = os.listdir(<span class="string">&#x27;./JPEGImages&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> imgList:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        img = Image.<span class="built_in">open</span>(item)</span><br><span class="line">        file_name, file_type = os.path.splitext(item)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if file_type == &#x27;jpg&#x27;:</span></span><br><span class="line">        <span class="comment">#     continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img.save(<span class="string">&quot;%s.jpg&quot;</span>%(file_name), <span class="string">&#x27;jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;picture convert error&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="批量更改标签名"><a href="#批量更改标签名" class="headerlink" title="批量更改标签名"></a>批量更改标签名</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilesChange</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.path = <span class="string">&#x27;./Annotations&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Change</span>(<span class="params">self</span>):</span></span><br><span class="line">        old = <span class="string">&quot;Apple&quot;</span></span><br><span class="line">        new = <span class="string">&quot;apple&quot;</span></span><br><span class="line">        filelist = os.listdir(self.path)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> filelist:</span><br><span class="line">            srcfile = os.path.join(os.path.abspath(self.path), item)</span><br><span class="line">            line_replace = <span class="number">2</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(srcfile,<span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">                lines = fd.readlines()</span><br><span class="line">                fd.seek(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                    <span class="keyword">if</span> old <span class="keyword">in</span> line:</span><br><span class="line">                        lines=<span class="string">&quot;&quot;</span>.join(lines).replace(old,new)</span><br><span class="line">                fd.writelines(<span class="string">&quot;&quot;</span>.join(lines))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    demo = FilesChange()</span><br><span class="line">    demo.Change()</span><br></pre></td></tr></table></figure>
<h3 id="查找无对应图片的标签-和-无对应标签的图片"><a href="#查找无对应图片的标签-和-无对应标签的图片" class="headerlink" title="查找无对应图片的标签 和 无对应标签的图片"></a>查找无对应图片的标签 和 无对应标签的图片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path1 = <span class="string">r&#x27;./JPEGImages&#x27;</span></span><br><span class="line">path2 = <span class="string">r&#x27;./Annotations&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_name</span>(<span class="params">image_dir,xml_dir</span>):</span></span><br><span class="line">    jpg_list = []</span><br><span class="line">    xml_list = []</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(image_dir):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            jpg_list.append(os.path.splitext(file)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(xml_dir):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            xml_list.append(os.path.splitext(file)[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(jpg_list))</span><br><span class="line">    diff = <span class="built_in">set</span>(xml_list).difference(<span class="built_in">set</span>(jpg_list))  <span class="comment"># 差集，在a中但不在b中的元素</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> diff:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no jpg&quot;</span>, name + <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">    diff2 = <span class="built_in">set</span>(jpg_list).difference(<span class="built_in">set</span>(xml_list))  <span class="comment"># 差集，在b中但不在a中的元素</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(diff2))</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> diff2:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no xml&quot;</span>, name + <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    file_name(path1,path2)</span><br></pre></td></tr></table></figure>
<h3 id="使用-imgaug-库图像增广"><a href="#使用-imgaug-库图像增广" class="headerlink" title="使用 imgaug 库图像增广"></a>使用 <code>imgaug</code> 库图像增广</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> imgaug <span class="keyword">as</span> ia</span><br><span class="line"><span class="keyword">from</span> imgaug <span class="keyword">import</span> augmenters <span class="keyword">as</span> iaa</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFile</span><br><span class="line"></span><br><span class="line">ImageFile.LOAD_TRUNCATED_IMAGES = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ia.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_xml_annotation</span>(<span class="params">root, image_id</span>):</span></span><br><span class="line">    in_file = <span class="built_in">open</span>(os.path.join(root, image_id))</span><br><span class="line">    tree = ET.parse(in_file)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    bndboxlist = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">object</span> <span class="keyword">in</span> root.findall(<span class="string">&#x27;object&#x27;</span>):  <span class="comment"># 找到root节点下的所有country节点</span></span><br><span class="line">        bndbox = <span class="built_in">object</span>.find(<span class="string">&#x27;bndbox&#x27;</span>)  <span class="comment"># 子节点下节点rank的值</span></span><br><span class="line"></span><br><span class="line">        xmin = <span class="built_in">int</span>(<span class="built_in">float</span>(bndbox.find(<span class="string">&#x27;xmin&#x27;</span>).text))</span><br><span class="line">        xmax = <span class="built_in">int</span>(<span class="built_in">float</span>(bndbox.find(<span class="string">&#x27;xmax&#x27;</span>).text))</span><br><span class="line">        ymin = <span class="built_in">int</span>(<span class="built_in">float</span>(bndbox.find(<span class="string">&#x27;ymin&#x27;</span>).text))</span><br><span class="line">        ymax = <span class="built_in">int</span>(<span class="built_in">float</span>(bndbox.find(<span class="string">&#x27;ymax&#x27;</span>).text))</span><br><span class="line">        <span class="comment"># print(xmin,ymin,xmax,ymax)</span></span><br><span class="line">        bndboxlist.append([xmin,ymin,xmax,ymax])</span><br><span class="line">        <span class="comment"># print(bndboxlist)</span></span><br><span class="line"></span><br><span class="line">    bndbox = root.find(<span class="string">&#x27;object&#x27;</span>).find(<span class="string">&#x27;bndbox&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> bndboxlist</span><br><span class="line"><span class="comment"># (506.0000, 330.0000, 528.0000, 348.0000) -&gt; (520.4747, 381.5080, 540.5596, 398.6603)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_xml_annotation</span>(<span class="params">root, image_id, new_target</span>):</span></span><br><span class="line">    new_xmin = new_target[<span class="number">0</span>]</span><br><span class="line">    new_ymin = new_target[<span class="number">1</span>]</span><br><span class="line">    new_xmax = new_target[<span class="number">2</span>]</span><br><span class="line">    new_ymax = new_target[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    in_file = <span class="built_in">open</span>(os.path.join(root, <span class="built_in">str</span>(image_id) + <span class="string">&#x27;.xml&#x27;</span>))  <span class="comment"># 这里root分别由两个意思</span></span><br><span class="line">    tree = ET.parse(in_file)</span><br><span class="line">    xmlroot = tree.getroot()</span><br><span class="line">    <span class="built_in">object</span> = xmlroot.find(<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">    bndbox = <span class="built_in">object</span>.find(<span class="string">&#x27;bndbox&#x27;</span>)</span><br><span class="line">    xmin = bndbox.find(<span class="string">&#x27;xmin&#x27;</span>)</span><br><span class="line">    xmin.text = <span class="built_in">str</span>(new_xmin)</span><br><span class="line">    ymin = bndbox.find(<span class="string">&#x27;ymin&#x27;</span>)</span><br><span class="line">    ymin.text = <span class="built_in">str</span>(new_ymin)</span><br><span class="line">    xmax = bndbox.find(<span class="string">&#x27;xmax&#x27;</span>)</span><br><span class="line">    xmax.text = <span class="built_in">str</span>(new_xmax)</span><br><span class="line">    ymax = bndbox.find(<span class="string">&#x27;ymax&#x27;</span>)</span><br><span class="line">    ymax.text = <span class="built_in">str</span>(new_ymax)</span><br><span class="line">    tree.write(os.path.join(root, <span class="built_in">str</span>(image_id) + <span class="string">&quot;_aug&quot;</span> + <span class="string">&#x27;.xml&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_xml_list_annotation</span>(<span class="params">root, image_id, new_target,saveroot,<span class="built_in">id</span></span>):</span></span><br><span class="line"></span><br><span class="line">    in_file = <span class="built_in">open</span>(os.path.join(root, <span class="built_in">str</span>(image_id) + <span class="string">&#x27;.xml&#x27;</span>))  <span class="comment"># 这里root分别由两个意思</span></span><br><span class="line">    tree = ET.parse(in_file)</span><br><span class="line">    xmlroot = tree.getroot()</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">object</span> <span class="keyword">in</span> xmlroot.findall(<span class="string">&#x27;object&#x27;</span>):  <span class="comment"># 找到root节点下的所有country节点</span></span><br><span class="line">        bndbox = <span class="built_in">object</span>.find(<span class="string">&#x27;bndbox&#x27;</span>)  <span class="comment"># 子节点下节点rank的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># xmin = int(bndbox.find(&#x27;xmin&#x27;).text)</span></span><br><span class="line">        <span class="comment"># xmax = int(bndbox.find(&#x27;xmax&#x27;).text)</span></span><br><span class="line">        <span class="comment"># ymin = int(bndbox.find(&#x27;ymin&#x27;).text)</span></span><br><span class="line">        <span class="comment"># ymax = int(bndbox.find(&#x27;ymax&#x27;).text)</span></span><br><span class="line"></span><br><span class="line">        new_xmin = new_target[index][<span class="number">0</span>]</span><br><span class="line">        new_ymin = new_target[index][<span class="number">1</span>]</span><br><span class="line">        new_xmax = new_target[index][<span class="number">2</span>]</span><br><span class="line">        new_ymax = new_target[index][<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        xmin = bndbox.find(<span class="string">&#x27;xmin&#x27;</span>)</span><br><span class="line">        xmin.text = <span class="built_in">str</span>(new_xmin)</span><br><span class="line">        ymin = bndbox.find(<span class="string">&#x27;ymin&#x27;</span>)</span><br><span class="line">        ymin.text = <span class="built_in">str</span>(new_ymin)</span><br><span class="line">        xmax = bndbox.find(<span class="string">&#x27;xmax&#x27;</span>)</span><br><span class="line">        xmax.text = <span class="built_in">str</span>(new_xmax)</span><br><span class="line">        ymax = bndbox.find(<span class="string">&#x27;ymax&#x27;</span>)</span><br><span class="line">        ymax.text = <span class="built_in">str</span>(new_ymax)</span><br><span class="line"></span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    tree.write(os.path.join(saveroot, <span class="built_in">str</span>(image_id) + <span class="string">&quot;_aug_&quot;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>) + <span class="string">&#x27;.xml&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span>(<span class="params">path</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 去除首位空格</span></span><br><span class="line">    path = path.strip()</span><br><span class="line">    <span class="comment"># 去除尾部 \ 符号</span></span><br><span class="line">    path = path.rstrip(<span class="string">&quot;\\&quot;</span>)</span><br><span class="line">    <span class="comment"># 判断路径是否存在</span></span><br><span class="line">    <span class="comment"># 存在     True</span></span><br><span class="line">    <span class="comment"># 不存在   False</span></span><br><span class="line">    isExists = os.path.exists(path)</span><br><span class="line">    <span class="comment"># 判断结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        <span class="comment"># 如果不存在则创建目录</span></span><br><span class="line">         <span class="comment"># 创建目录操作函数</span></span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        <span class="built_in">print</span>(path + <span class="string">&#x27; 创建成功&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果目录存在则不创建，并提示目录已存在</span></span><br><span class="line">        <span class="built_in">print</span>(path + <span class="string">&#x27; 目录已存在&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    IMG_DIR = <span class="string">&quot;./JPEGImages&quot;</span></span><br><span class="line">    XML_DIR = <span class="string">&quot;./Annotations&quot;</span></span><br><span class="line"></span><br><span class="line">    AUG_XML_DIR = <span class="string">&quot;./aug_Annotations&quot;</span>  <span class="comment"># 存储增强后的XML文件夹路径</span></span><br><span class="line">    mkdir(AUG_XML_DIR)</span><br><span class="line"></span><br><span class="line">    AUG_IMG_DIR = <span class="string">&quot;./aug_JPEGImages&quot;</span>  <span class="comment"># 存储增强后的影像文件夹路径</span></span><br><span class="line">    mkdir(AUG_IMG_DIR)</span><br><span class="line"></span><br><span class="line">    AUGLOOP = <span class="number">2</span> <span class="comment"># 每张影像增强的数量</span></span><br><span class="line"></span><br><span class="line">    boxes_img_aug_list = []</span><br><span class="line">    new_bndbox = []</span><br><span class="line">    new_bndbox_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 影像增强</span></span><br><span class="line">    seq = iaa.Sequential([</span><br><span class="line">        <span class="comment"># iaa.Flipud(0.5),  # vertically flip 20% of all images</span></span><br><span class="line">        iaa.Fliplr(<span class="number">0.5</span>),  <span class="comment"># 镜像</span></span><br><span class="line">        iaa.Multiply((<span class="number">1.2</span>, <span class="number">1.5</span>)),  <span class="comment"># change brightness, doesn&#x27;t affect BBs</span></span><br><span class="line">        iaa.GaussianBlur(sigma=(<span class="number">0</span>, <span class="number">3.0</span>)), <span class="comment"># iaa.GaussianBlur(0.5),</span></span><br><span class="line">        iaa.Affine(</span><br><span class="line">            translate_px=&#123;<span class="string">&quot;x&quot;</span>: <span class="number">15</span>, <span class="string">&quot;y&quot;</span>: <span class="number">15</span>&#125;,</span><br><span class="line">            scale=(<span class="number">0.8</span>, <span class="number">0.95</span>),</span><br><span class="line">            rotate=(-<span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">        )  <span class="comment"># translate by 40/60px on x/y axis, and scale to 50-70%, affects BBs</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> root, sub_folders, files <span class="keyword">in</span> os.walk(XML_DIR):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line"></span><br><span class="line">            bndbox = read_xml_annotation(XML_DIR, name)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(AUGLOOP):</span><br><span class="line">                seq_det = seq.to_deterministic()  <span class="comment"># 保持坐标和图像同步改变，而不是随机</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 读取图片</span></span><br><span class="line">                img = Image.<span class="built_in">open</span>(os.path.join(IMG_DIR, name[:-<span class="number">4</span>] + <span class="string">&#x27;.jpg&#x27;</span>))</span><br><span class="line">                img = np.array(img)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># bndbox 坐标增强</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bndbox)):</span><br><span class="line">                    bbs = ia.BoundingBoxesOnImage([</span><br><span class="line">                        ia.BoundingBox(x1=bndbox[i][<span class="number">0</span>], y1=bndbox[i][<span class="number">1</span>], x2=bndbox[i][<span class="number">2</span>], y2=bndbox[i][<span class="number">3</span>]),</span><br><span class="line">                    ], shape=img.shape)</span><br><span class="line"></span><br><span class="line">                    bbs_aug = seq_det.augment_bounding_boxes([bbs])[<span class="number">0</span>]</span><br><span class="line">                    boxes_img_aug_list.append(bbs_aug)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># new_bndbox_list:[[x1,y1,x2,y2],...[],[]]</span></span><br><span class="line">                    new_bndbox_list.append([<span class="built_in">int</span>(bbs_aug.bounding_boxes[<span class="number">0</span>].x1),</span><br><span class="line">                                            <span class="built_in">int</span>(bbs_aug.bounding_boxes[<span class="number">0</span>].y1),</span><br><span class="line">                                            <span class="built_in">int</span>(bbs_aug.bounding_boxes[<span class="number">0</span>].x2),</span><br><span class="line">                                            <span class="built_in">int</span>(bbs_aug.bounding_boxes[<span class="number">0</span>].y2)])</span><br><span class="line">                <span class="comment"># 存储变化后的图片</span></span><br><span class="line">                image_aug = seq_det.augment_images([img])[<span class="number">0</span>]</span><br><span class="line">                path = os.path.join(AUG_IMG_DIR, <span class="built_in">str</span>(name[:-<span class="number">4</span>]) + <span class="string">&quot;_aug_&quot;</span> + <span class="built_in">str</span>(epoch) + <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line">                <span class="comment"># image_auged = bbs.draw_on_image(image_aug, thickness=0)</span></span><br><span class="line">                Image.fromarray(image_aug).save(path)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 存储变化后的XML</span></span><br><span class="line">                change_xml_list_annotation(XML_DIR, name[:-<span class="number">4</span>], new_bndbox_list,AUG_XML_DIR,epoch)</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">str</span>(name[:-<span class="number">4</span>]) + <span class="string">&quot;_aug_&quot;</span> + <span class="built_in">str</span>(epoch) + <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line">                new_bndbox_list = []</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>懵逼的深度学习</category>
      </categories>
      <tags>
        <tag>数据集</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>和周小姐高中的对话（一）</title>
    <url>/2021/11/08/%E5%92%8C%E5%91%A8%E5%B0%8F%E5%A7%90%E9%AB%98%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%AF%9D%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>和周小姐的高中日常之一</p>
<span id="more"></span>
<p>一日，周小姐忽然递过一张纸条，上面写道：</p>
<blockquote>
<p>凡食人间烟火者，皆有所好，吾之所好者，乐也；爱华君之所好者，色也。</p>
<p>何为色也？女色也，凡有面容姣好者，难以逃脱爱华之眼也。</p>
<p>嗟乎！色字当头一把刀，吾甚恐爱华君不知也，特写此书以告之。</p>
<p align="right">——by Ting</p>

</blockquote>
<p>我这样回复：</p>
<blockquote>
<p>汝庸也，华夏上下五千年，其人也以亿计，天地寿也数十亿年，其灵也以万亿计。此皆雌雄，男女分工之法。</p>
<p>万物有灵，灵皆爱美，更有学者撰《物种起源》论进化之事矣，其意亦如此。</p>
<p>今吾所思之女子，面容姣好，举止淑女，世人视之皆慕之，吾何理不念之。古人云：“窃窕淑女，君子好逑。”且吾止于远观而不骚扰，汝何理之言吾心色也？</p>
<p align="right">——by Aep</p>

</blockquote>
<p>今料我所言应如是。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>卷积运算的输入输出shape</title>
    <url>/2022/03/16/%E5%8D%B7%E7%A7%AF%E8%BF%90%E7%AE%97%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BAshape/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>记录一下二维卷积神经网络中卷积运算的输入输出shape大小</p>
<span id="more"></span>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul>
<li><p>输入：$(H,W)$</p>
</li>
<li><p>卷积核：$(FH,FW)$</p>
</li>
<li><p>填充：$P$</p>
</li>
<li><p>步幅：$S$</p>
</li>
<li><p>输出：$(OH,OW)$</p>
</li>
</ul>
<script type="math/tex; mode=display">
OH = \frac{H + 2P - FH}{S} + 1 
\\
\\
OW = \frac{W + 2P - FW}{S} + 1</script>]]></content>
      <categories>
        <category>懵逼的深度学习</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>多目标优化笔记</title>
    <url>/2022/04/19/%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>多目标优化 ( MOO ) - Multi-Objective Optimization</p>
<p>从问题定义，单目标、多目标，无约束、有约束方面了解多目标优化</p>
<span id="more"></span>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="无约束的单目标优化问题"><a href="#无约束的单目标优化问题" class="headerlink" title="无约束的单目标优化问题"></a>无约束的单目标优化问题</h3><script type="math/tex; mode=display">
\min_{x} f(x),x \in R^{N}</script><h3 id="无约束的多目标优化问题"><a href="#无约束的多目标优化问题" class="headerlink" title="无约束的多目标优化问题"></a>无约束的多目标优化问题</h3><script type="math/tex; mode=display">
\min_{x} F(x) = [f_1(x), f_2(x),\cdots, f_n(x)], x \in R^{N}</script><p>$ n $ 为子目标的数量，$ f_n(x) $为一阶可导目标函数 $F(x)$ 的子函数</p>
<h3 id="有约束的单目标优化问题"><a href="#有约束的单目标优化问题" class="headerlink" title="有约束的单目标优化问题"></a>有约束的单目标优化问题</h3><script type="math/tex; mode=display">
\begin{array}{lcl}
\min_{x} & f(x) & \\
\text { s.t. } & g_{i}(x) \geq 0 & , i \in[1, M] \\
& h_{j}(x)=0 & , j \in[1, L]
\end{array}</script><p>$\text { s.t. }$ 为 <code>subject to</code> ，受限于的缩写，设 $ D $ 为可行域</p>
<script type="math/tex; mode=display">
D = \{x | g_i(x) \geq 0, i \in [1, M], h_j(x) =0 , j \in [1,L]  \}</script><h3 id="有约束的多目标优化问题"><a href="#有约束的多目标优化问题" class="headerlink" title="有约束的多目标优化问题"></a>有约束的多目标优化问题</h3><script type="math/tex; mode=display">
\begin{array}{lcl}
\min_x & F(x) = [f_1(x), f_2(x),\cdots, f_n(x)]\\
\text{s.t.} & g_i(x) \geq 0 ,\quad i\in(1, M) \\
& h_j(x) = 0 ,\quad j \in (1,L)
\end{array}</script><p>设 $ D $ 为可行域</p>
<script type="math/tex; mode=display">
D = \{x | g_i(x) \geq 0, i \in [1, M], h_j(x) =0 , j \in [1,L]  \}</script><h2 id="MOO-的解集"><a href="#MOO-的解集" class="headerlink" title="MOO 的解集"></a>MOO 的解集</h2><p>对于 MOO，通常没有解  $ x^\ast \in D $, 使 $ f_i(x), \forall i \in [1,N] $  同时处于最优解，因此单目标优化问题的解在 MOO 中通常不适用</p>
<p>MOO 中的解集分为 <strong>绝对有效解</strong>，<strong>有效解</strong>，<strong>弱有效解</strong></p>
<p>设 $R^N $为 $N$ 维的实向量空间，$y=(y_1,y_2,\cdots, y_N)^{T}$，$z=(z_1,z_2,\cdots, z_N)^{T}$</p>
<script type="math/tex; mode=display">
\begin{cases}\text { 相等 } & y=z \Leftrightarrow y_{i}=z_{i}, i=1,2, \ldots, N \\ \text { 严格小于 } & y<z \Leftrightarrow y_{i}<z_{i}, i=1,2, \ldots, N \\ \text { 小于 } & y \leqq z \Leftrightarrow y_{i} \leqslant z_{i}, i=1,2, \ldots, N \\ \text { 小于且不相等(支配) } & y \leqslant z \Leftrightarrow y_{i} \leqslant z_{i}, i=1,2, \ldots, N, y \neq z\end{cases}</script><h3 id="Pareto-支配（Pareto-Dominance）"><a href="#Pareto-支配（Pareto-Dominance）" class="headerlink" title="Pareto 支配（Pareto Dominance）"></a>Pareto 支配（Pareto Dominance）</h3><p>$ \forall x_1, x_2 \in R^{N}     $， 对于 $ k = 1,\cdots,K $，都有 $ f_k(x_1) \leqslant f_k(x_2)$，则 $ x_1 $ 支配 $ x_2 $</p>
<p><img src="/image/多目标优化笔记/D.jpg" style="zoom:67%;" /></p>
<h3 id="Pareto-解集（绝对最优解）"><a href="#Pareto-解集（绝对最优解）" class="headerlink" title="Pareto 解集（绝对最优解）"></a>Pareto 解集（绝对最优解）</h3><p>$ x^{\ast}{\in}{D} $ ， $ \forall x \in D,\quad f(x^\ast) {\leqq} f(x) $ ，即 $ \forall k \in 1,\cdots,K, \quad f_K(x^\ast) \leqq f_{K}(x) $ ，则 $ x^\ast $ 为 MOO 问题的最优解</p>
<h3 id="Pareto-解集（有效解）"><a href="#Pareto-解集（有效解）" class="headerlink" title="Pareto 解集（有效解）"></a>Pareto 解集（有效解）</h3><p>$x^\ast\in{D}$ ，若 $f_k(x)\leq f_k(x^\ast) \wedge \exists i,f_i(x) &lt; f_i(x^\ast),i\in [1,k]$ 不成立，则 $x^\ast$ 是 MOO 问题的有效解，也叫 Pareto 最优解，其含义是如果 $x^\ast$ 是 Pareto 最优解，则找不到这样的可行解  $x\in{D}$ ，使得 $f(x)$ 的每个目标值都不比 $f(x^\ast)$ 的目标值坏,并且 $ f (x) $ 至少有一个目标比 $f(x^\ast)$ 的相应目标值好，即 $ x^\ast $ 是最好的，不能再进行改进（Pareto 改进）</p>
<h3 id="Pareto-解集（弱有效解）"><a href="#Pareto-解集（弱有效解）" class="headerlink" title="Pareto 解集（弱有效解）"></a>Pareto 解集（弱有效解）</h3><p>$x^\ast\in{D}$ ，如果不存在 $x\in{D}$，使得 $f(x)&lt;f(x^\ast)$ ，即</p>
<script type="math/tex; mode=display">
f_k(x) < f_k(x^*) \quad \wedge \quad \forall k \in [1,K]</script><p>则 $x^\ast$ 是 MOO 问题的有效解，其含义是如果 $x^\ast$ 是弱有效解,则找不到这样的可行解 $x\in{D}$，使得 $f(x)$ 的每个目标值都比 $f(x^\ast)$ 的目标值严格（ $&lt;$ ）的好</p>
<h3 id="Pareto-最优解集（Pareto-optimal-Set）"><a href="#Pareto-最优解集（Pareto-optimal-Set）" class="headerlink" title="Pareto 最优解集（Pareto-optimal Set）"></a>Pareto 最优解集（Pareto-optimal Set）</h3><p>给定问题的有效解集（Pareto 最优解）构成的解集，集合中的解是相互非支配的，两两非支配关系，简称 $PS$</p>
<h3 id="Pareto-最优前沿（Pareto-optimal-Front）"><a href="#Pareto-最优前沿（Pareto-optimal-Front）" class="headerlink" title="Pareto 最优前沿（Pareto-optimal Front）"></a>Pareto 最优前沿（Pareto-optimal Front）</h3><p>Pareto 每一个解对应的目标值向量组成的集合，简称 $PF$</p>
<script type="math/tex; mode=display">
PF = \{F(x)|x\in PS\}</script><p><img src="/image/多目标优化笔记/PF.jpg" style="zoom:50%;" /></p>
<h3 id="MOO-的最优性条件"><a href="#MOO-的最优性条件" class="headerlink" title="MOO 的最优性条件"></a>MOO 的最优性条件</h3><p>约束规格定义：对优化问题的约束函数，附加某些限制条件，使得其最优解满足的最优性条件</p>
<p>下面给出一个严格条件下多目标优化的充分必要条件，给出的充要条件前，先引入了约束规格条件</p>
<script type="math/tex; mode=display">
\begin{aligned}
\min _{x \in \hat{D}} F(x) &=\sum_{k=1}^{K} f_{k}(x) \\
\hat{D} &=x \in D \mid f(x) \leq f(\hat{x})
\end{aligned}</script><p>定理：设 $ f (x)$ ，$ g(x) $ 为凸函数,且在 $x \in D$ 处可微，$h(x)$ 为线性函数，且 $\hat{D} = x \in D|f (x) \leq f (\hat{x})$ 满足 $ KKT $ 约束规格，则 $x^\ast$ 是 MOO 的有效解的充分必要条件是存在 $ \lambda \in  R^K , u \in R^M , v \in R^L$， 使得</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\nabla_{x} L\left(x^{*}, \lambda^{*}, u^{*}, v^{*}\right)=\nabla f\left(x^{*}\right) \lambda^{*}+\nabla g\left(x^{*}\right) u^{*}+\nabla h\left(x^{*}\right) v^{*}=0 \\
u^{* T} g\left(x^{*}\right)=0 \\
\lambda^{*}>0, u^{*} \geq 0
\end{array}\right.</script><h2 id="MOO-的经典算法"><a href="#MOO-的经典算法" class="headerlink" title="MOO 的经典算法"></a>MOO 的经典算法</h2><h3 id="线性加权法"><a href="#线性加权法" class="headerlink" title="线性加权法"></a>线性加权法</h3><p>根据 $f(x)$ 的重要程度，设定权重进行线性加权</p>
<script type="math/tex; mode=display">
\begin{array}{r}
& \min _{x} \sum_{k=1}^{K} \lambda_{k} f_{k}(x) \\
\text { s.t. } & g_{i}(x) \geq 0,\quad i \in[1, M] \\
& h_{j}(x)=0,\quad j \in[1, L]
\end{array}</script><p><img src="/image/多目标优化笔记/weight.jpg" style="zoom:67%;" /></p>
<p>于是就变成了单目标优化问题，上述问题存在有效解的条件，对于给定的 $\lambda \in \Lambda^{++}$ ，则上述问题的最优解是 MOO 问题的有效解，其中</p>
<script type="math/tex; mode=display">
\Lambda^{++}=\left\{\lambda \mid \lambda_{k}>0, k=1,2 \ldots K, \sum_{k=1}^{K} \lambda_{k}=1\right\}</script><ul>
<li>优点：实现简单，有成熟的算法求解</li>
<li>缺点：$\lambda_k$ 难以确定，求出的解的优劣无法确定</li>
</ul>
<h3 id="主要目标法"><a href="#主要目标法" class="headerlink" title="主要目标法"></a>主要目标法</h3><p>也称 $\epsilon$-约束方法</p>
<script type="math/tex; mode=display">
\begin{array}{l}
& \min _{x} & f_{p}(x) \\
\text { s.t. } & f_{k}(x) &\leq \epsilon_{k} &,k=1, \ldots, K, k \neq p \\
& g_{i}(x) &\geq 0, i \in[1, M] \\
& h_{j}(x) &= 0, j \in[1, L]
\end{array}</script><p><img src="/image/多目标优化笔记/constraint.jpg" style="zoom: 67%;" /></p>
<p>$\epsilon$-约束方法从 $K$ 个目标中选择最重要的子目标作为优化目标,其余的子目标作为约束条件。每个子目标,通过上界 $\epsilon_{K}$ 来约束</p>
<h4 id="主要目标法最优解和-MOO-解集的关系"><a href="#主要目标法最优解和-MOO-解集的关系" class="headerlink" title="主要目标法最优解和 MOO 解集的关系"></a>主要目标法最优解和 MOO 解集的关系</h4><ul>
<li><p>主要目标法最优解是 MOO 解的弱有效解</p>
</li>
<li><p>若主要目标 $f_p (x)$ 是严格凸函数，可行域为 $\hat{D}$ 的凸集，则主要目标法最优解是 MOO 解的有效解</p>
</li>
</ul>
<h4 id="界限值-epsilon-的选取"><a href="#界限值-epsilon-的选取" class="headerlink" title="界限值 $\epsilon$ 的选取"></a>界限值 $\epsilon$ 的选取</h4><p>可以取子目标函数的上限值</p>
<script type="math/tex; mode=display">
\min \left\{f_{k} \mid f_{k}(x), k=1, \ldots, K, k \neq p\right\} \leq \epsilon_{k}</script><p>这种取法可以使得某些 $f_k(x)$ 留在可行域 $\hat{D}$ 内,并且 $\hat{D}$ 内有较多的点靠近 $f_k (x)$ 的最优解</p>
<ul>
<li>优点：简单，能应用到凸函数和非凸函数场景下</li>
<li>缺点：$\epsilon_k$ 如果取值不合适，可行域 $\hat{D}$ 可能为空值</li>
</ul>
<h3 id="逼近目标法"><a href="#逼近目标法" class="headerlink" title="逼近目标法"></a>逼近目标法</h3><p>提出一个目标值 $f^0 = (f_1^0,f_2^0,\cdots,f_k^0)$，使得每个目标函数 $f_k(x)$ 都逼近对应的目标值</p>
<script type="math/tex; mode=display">
\begin{array}{l}
L = (f(x), f^0) & = ||f(x) - f^0 ||^{\lambda}_{2} \\
&= \sum_{k=1}^{K} \lambda_k(f_k(x)-f^0)^2,\lambda \in \Lambda^{++}
\end{array}</script><p>和机器学习中的损失函数类似，是一个单目标优化问题，可以通过经典的方法进行求解，这里求解的最优解和有效解及弱有效解没有直接的联系，反映了决策者希望的目标值</p>
<h3 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h3><p>这是一种直接优化的方法，而上面提到的算法都是采取先验的知识将多目标优化转化成单目标优化</p>
<h4 id="最速梯度下降"><a href="#最速梯度下降" class="headerlink" title="最速梯度下降"></a>最速梯度下降</h4><p>简单起见，将讨论问题限制在无约束的单目标优化问题，并要求无约束的单目标优化问题中的 $f (x)$ 具有一阶连续偏导数，对于这类问题，能够从某一点出发，选择目标函数 $f (x) $ 下降最快的方向进行搜索，尽快达到最小值，问题是如何选择下降最快的方向</p>
<script type="math/tex; mode=display">
DF(x;d) = \nabla f(x)^T d</script><p>求 $f(x)$ 在点 $x$ 处的下降最快的方向导数，归结为求如下最优化问题</p>
<script type="math/tex; mode=display">
\min \nabla f(x)^T d \\
\text{s.t.} \quad ||d|| \leq 1</script><p>其中 $||\cdot||$ 为欧式距离，上述问题的解为</p>
<script type="math/tex; mode=display">
d = -\frac{\nabla f(x)}{||\nabla f(x)||}</script><p>负梯度方向为最速下降方向，最速下降法的迭代公式为</p>
<script type="math/tex; mode=display">
x^{t+1} = x^t + \lambda_k d^{(k)}</script><p>其中，$\lambda _k$ 可以通过一维搜索来得到</p>
<h4 id="多目标梯度下降算法"><a href="#多目标梯度下降算法" class="headerlink" title="多目标梯度下降算法"></a>多目标梯度下降算法</h4><p>设当前为 $t+1$ 轮迭代，梯度迭代公式</p>
<script type="math/tex; mode=display">
x^{t+1} = x^t + \lambda \cdot d^{t}</script><p>多目标优化的方向导数</p>
<script type="math/tex; mode=display">
\nabla f_k(x)^T d,k = 1,2,\cdots,K</script><p>定义最大方向导数</p>
<script type="math/tex; mode=display">
M_x(d^t) = max\{ \nabla f_k(x)^T d^t \mid k = 1,2,\cdots,K\}</script><p>多目标问题的最速梯度下降方向，可以归结为求解以下问题</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\min & M_x(d^t) + \frac{1}{2} \| d^t \| ^2 \\
\text{s.t.} & d^t \in R
\end{array}</script><p>上述优化问题是闭且强凸优化问题，一定存在最优解，令 $M_x (d^t) = \alpha$，可以将一阶偏导项消去</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\min & \alpha + \frac{1}{2} \|d^t \|^2 \\
\text{s.t.} & \nabla f_k(x)^T d^t \leq \alpha ,k = 1,2,\cdots,K \\
& d^t \in R
\end{array}</script><p>上述问题为带线性不等式约束的凸二次规划问题</p>
<p>令 $d^\ast$，$a^\ast$ 为上述优化问题的最优解，得到</p>
<ul>
<li>若 $x^\ast$ 为 Pareto 最优，则 $d^\ast=0,a^\ast=0$ </li>
<li>若 $x^\ast$ 不为 Pareto 最优，则 $a^\ast&lt;0$</li>
</ul>
<p>且</p>
<script type="math/tex; mode=display">
\alpha  \leq-\frac{1}{2} \|\left. d^{t}\right|^{2}<0 \\
\nabla f_{k}(x)^{T} d^{t}  \leq \alpha, k=1, \cdots, K</script><p>因此</p>
<ul>
<li>如果 $d^\ast = 0$，则说明此时不存在下降方向,使得所有的目标都下降</li>
<li>如果 $d^\ast \neq 0$，则有 $\nabla f_{k}(x)^{T} d^{t} &lt; 0$，则 $d^t$ 是一个有效的多目标搜索方向，按如下公式更新，即可以使目标函数下降</li>
</ul>
<script type="math/tex; mode=display">
\begin{array}{l}
x^{(t+1)}&=& x^{t}+\lambda \cdot d^{t} \\
f_{k}\left(x^{(t+1)}\right) &\leq& f_{k}\left(x^{t}\right), k=1, \ldots, K
\end{array}</script><h2 id="多任务学习（MTL）"><a href="#多任务学习（MTL）" class="headerlink" title="多任务学习（MTL）"></a>多任务学习（MTL）</h2><p>多任务学习（MTL）- Multi-Task Learning</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在同一时间学习多个任务，求得最优解</p>
<p>设有 $N$ 个样本点 $\{ x,y_i^1,y_i^2,\cdots, y_i^T\},i \in N$，其中 $T$ 为任务数量，$y_i^t$ 是第 $t^{th}$ 个任务，第 $i^{th}$ 个样本点标签，定义为</p>
<script type="math/tex; mode=display">
f^t(x;\theta^{sh},\theta^t):X \rightarrow Y^t</script><p>其中 $\theta^{sh}$ 为多个任务的共享参数，$\theta^t$ 为单个任务的独有参数</p>
<p>$Loss$ 为</p>
<script type="math/tex; mode=display">
L^t(\_,\_) = Y^t \times Y^t \rightarrow R^+</script><script type="math/tex; mode=display">
\min_{\theta^{sh} ,\theta} = \sum_{t=1}^{T} c^t \hat{L}^{t}(\theta^{sh},\theta)</script><p>$c^t$ 为每个具体任务的权重，每个具体任务 $t$ 的 $Loss$ 为</p>
<script type="math/tex; mode=display">
\hat{L}^t(\theta^{sh},\theta) \triangleq \frac{1}{N} \sum_t L(f^t(x;\theta^{sh}, \theta^t), y^t_i)</script><h3 id="多任务学习转化为多目标优化"><a href="#多任务学习转化为多目标优化" class="headerlink" title="多任务学习转化为多目标优化"></a>多任务学习转化为多目标优化</h3><p>将多任务学习转换为 MOO 问题求解，定义</p>
<script type="math/tex; mode=display">
\min _{\theta^{s h}, \theta} L\left(\theta^{s h}, \theta^{1}, \ldots, \theta^{T}\right)=\min _{\theta^{s h}, \theta}\left(\hat{L}^{1}\left(\theta^{s h}, \theta^{1}\right), \cdots, \hat{L}^{T}\left(\theta^{s h}, \theta^{T}\right)\right)</script><p>多目标优化的目的是求得 Pareto 最优解，多目标优化的 Pareto 最优解定义</p>
<p>一个解 $\theta$ 支配另一个解 $\bar{\theta}$ ，如果</p>
<script type="math/tex; mode=display">
\hat{L}(\theta^{sh},\theta^t) \leq \hat{L}(\bar{\theta}^{sh},\bar{\theta}^t)</script><p>对于所有的任务 $t$ 都成立，且</p>
<script type="math/tex; mode=display">
L(\theta^{sh},\theta^1,\theta^2,\cdots,\theta^{T}) \neq L(\bar{\theta}^{sh},\bar{\theta}^1,\bar{\theta}^2,\cdots, \bar{\theta}^T)</script><p>一个解 $\theta^{\ast}$ 称为 Pareto 最优解的集合称为 Pareto 最优解集，其图像称为 Pareto 前沿（Pareto Front）</p>
<h2 id="多任务求解：单个-Pareto-解"><a href="#多任务求解：单个-Pareto-解" class="headerlink" title="多任务求解：单个 Pareto 解"></a>多任务求解：单个 Pareto 解</h2><h3 id="问题转化"><a href="#问题转化" class="headerlink" title="问题转化"></a>问题转化</h3><p>单个 Pareto 解使用了多重梯度下降法，由多目标优化的 $KKT$ 条件，得</p>
<p>存在 $\alpha^1,\alpha^2,\cdots,\alpha^T \geq 0$，使得</p>
<script type="math/tex; mode=display">
\begin{array}{r}
\sum_{t=1}^{T} \alpha^T = 1 \\
\sum_{t=1}^{T} \alpha^t \nabla_{\theta^{sh}} \hat{L}(\theta^{sh},\theta^{t}) = 0
\end{array}</script><p>对应所有的任务 $t$</p>
<script type="math/tex; mode=display">
\nabla_{\theta^t}\hat{L}(\theta^{sh},\theta^t) = 0</script><p>满足上式的解称为 Pareto 平衡点（Pareto Stationary Point），Pareto 最优点都是 Pareto 平稳点，反之不一定成立，考虑如下的优化问题</p>
<script type="math/tex; mode=display">
\begin{gathered}
\min _{\alpha^{1}, \cdots ,\alpha^{T}}\left\|\sum_{t=1}^{T} \alpha^{t} \nabla_{\theta s h} \hat{L}^{t}\left(\theta^{s h}, \theta^{t}\right)\right\| \\
\sum_{t=1}^{T} \alpha^{t}=1, \alpha^{t} \geq 0, \forall t
\end{gathered}</script><p>上述优化问题的解存在两种情况</p>
<ul>
<li>最优值 $=0$，则对应的解满足 $KKT$ 条件</li>
<li>最优值 $\neq 0$，则对应的解给出了下降方向，使得多任务目标函数提升（函数值下降）上述优化问题等价于在输入点集凸包中找到最小模点</li>
</ul>
<h3 id="两个任务的情形"><a href="#两个任务的情形" class="headerlink" title="两个任务的情形"></a>两个任务的情形</h3><p>由多目标优化的 $KKT$ 条件，得</p>
<script type="math/tex; mode=display">
\begin{gathered}
\min _{\alpha^{1}, \ldots \alpha^{T}}\|\gamma \theta+(1-\gamma) \bar{\theta}\| \\
\gamma+(1-\gamma)=1, \gamma \geq 0
\end{gathered}</script><p>其中 $\theta,\bar{\theta}$ 定义为</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\theta \triangleq \nabla_{\theta s h} \hat{L}^{1}\left(\theta^{s h}, \theta^{1}\right) \\
&\bar{\theta} \triangleq \nabla_{\theta s h} \hat{L}^{2}\left(\theta^{s h}, \theta^{2}\right)
\end{aligned}</script><p>其解的情况枚举如下</p>
<ul>
<li>当 $\theta^T \bar{\theta} \geq \theta^T \theta,\gamma = 1$</li>
<li>当 $\theta^T \bar{\theta} \geq \bar{\theta}^T \bar{\theta},\gamma = 0$</li>
<li>$\text{otherwise}$</li>
</ul>
<script type="math/tex; mode=display">
\gamma=\frac{(\bar{\theta}-\theta)^{T} \bar{\theta}}{\| \bar{\theta}-\theta) \|_{2}^{2}}p7</script><p>几何解释</p>
<p><img src="/image/多目标优化笔记/interpret.png" style="zoom:66%;" /></p>
<p><img src="/image/多目标优化笔记/algo1.png" style="zoom:60%;" /></p>
<p>基于 Frank-wolfe 算法，得求解 MTL 任务算法</p>
<p><img src="/image/多目标优化笔记/algo2.png" style="zoom: 66%;" /></p>
<p><img src="/image/多目标优化笔记/frankwolfesolver.png" style="zoom:62%;" /></p>
<h2 id="多任务求解：多个-Pareto-解"><a href="#多任务求解：多个-Pareto-解" class="headerlink" title="多任务求解：多个 Pareto 解"></a>多任务求解：多个 Pareto 解</h2><p>上一节介绍的方法只能求得一个 pareto 解，有时需要多个 pareto 解才能做出更好的决策</p>
<h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>将多任务学习分解为多个带约束的多目标子问题，通过对子问题进行并行求解</p>
<p>原始多任务学习定义</p>
<script type="math/tex; mode=display">
\min_{\theta} L(\theta) = (L_1(\theta),L_2(\theta),\cdots,L_i(\theta),\cdots,L_m(\theta))</script><p>$L_i(\theta)$ 是第 $i$ 个任务的损失函数</p>
<p>下图所示</p>
<p><img src="/image/多目标优化笔记/pareto1.png" style="zoom:60%;" /></p>
<p><img src="/image/多目标优化笔记/pareto2.png" style="zoom:60%;" /></p>
<p>用一组分布良好的 Preference Vectors（PV）将多任务学习的目标空间分解为 $K$ 个子区域</p>
<script type="math/tex; mode=display">
PV = \{u_1,u_2,\cdots,u_k,\cdots,u_K\},u_k \in R_+^m</script><p>重新定义多任务学习</p>
<script type="math/tex; mode=display">
\min_{\theta} L(\theta) = (L_1(\theta),L_2(\theta),L_m(\theta)) \\
s.t. \quad L(\theta) \in \Omega_k,k = 1,\cdots,K</script><p>$\Omega_k$ 是目标空间的子区域</p>
<script type="math/tex; mode=display">
\Omega_k = \{v \in R_+^m | u_j^T v \leq u_k^Tv,\forall j = 1,\cdots,K \}</script><p>$\Omega_k$ 中的元素 $v$</p>
<script type="math/tex; mode=display">
v \in \Omega_k \Leftrightarrow u_k^T v = \| u_k \| \cdot \| v \| \cos{\alpha}</script><p>$u_k^T v$ 为最大的内积</p>
<p>重新定义多任务学习</p>
<script type="math/tex; mode=display">
\begin{array}{l}
& \min_\theta L(\theta) = (L_1(\theta),L_2(\theta),L_m(\theta)) \\
\text{s.t.} & G_j(\theta_t) = (u_j - u_k)^T \\
& L(\theta_t) \leq 0 \\
& j=1,\cdots,K
\end{array}</script><p>这样得到的解集将会分布在不同的子区域 $\Omega_k$</p>
<h3 id="子问题的梯度下降方法"><a href="#子问题的梯度下降方法" class="headerlink" title="子问题的梯度下降方法"></a>子问题的梯度下降方法</h3><h4 id="寻找初始解-theta-r"><a href="#寻找初始解-theta-r" class="headerlink" title="寻找初始解 $\theta_r$"></a>寻找初始解 $\theta_r$</h4><p>求解多任务学习，需要找到一个满足约束的基本可行解，对于随机产生的可行解 $\theta_r$ ，一种最直接的方法就是找到初始可行解 $\theta_0$ </p>
<script type="math/tex; mode=display">
\begin{array}{l}
& \min_{\theta_0} \| \theta_0 - \theta_r \|^2 \\
 \text{s.t.} & L(\theta_0) \in \Omega_k
\end{array}</script><p>上述问题投影方法求解的效率不高，特别是对于大规模的深度神经网络，改写为无约束优化问题，使用序列梯度方法找到初始解 $\theta_0$</p>
<p>定义活跃限制集合（activated constraints）</p>
<script type="math/tex; mode=display">
I(\theta_r) = \{ j|G_j(\theta_r) \geq 0,j=1,\cdots,K \}</script><p>令 $I(\theta_r)$ 中所有的活跃限制函数值下降的方向</p>
<script type="math/tex; mode=display">
(d_r,\alpha_r) = \text{argmin}_{d \in R^n,\alpha \in R} \quad \alpha + \frac{1}{2} \|d\|^2 \\
\text{s.t.} \quad \nabla G_j (\theta_r)^T d \leq \alpha,j\in I(\theta_r)</script><p>得到更新公式</p>
<script type="math/tex; mode=display">
\theta_{r_{t+1}} = \theta_{r_t} + \eta_r d_{r_t}</script><p>上述方法能将活跃集内的约束目标值减少，使得越来越多的约束目标小于 0，$I(\theta_{r})$ 最后变为空集，则 $\theta_{r}$ 是可行解</p>
<h4 id="求解子问题"><a href="#求解子问题" class="headerlink" title="求解子问题"></a>求解子问题</h4><p>受限 pareto 最优：$\theta^{\ast}$ 是多任务 $L(\theta)$ 在子区域 $\Omega_k$ 的最优解，如果 $\theta^{\ast} \in \Omega_k$ 且不存在 $\hat{\theta} \in  \Omega_k$，使得 $\hat{\theta} &lt; \theta^{\ast}$</p>
<p>考虑如下多目标优化问题</p>
<script type="math/tex; mode=display">
\begin{array}{l}
& (d_t,\alpha_t)  = \text{argmin}_{d\in R^n,\alpha \in R} \quad \alpha + \frac{1}{2}\|d\|^2 \\

\text{s.t.} & \nabla L_i(\theta_t)^Td \leq \alpha,i=1,\cdots,m\\
& \nabla G_j(\theta_t)^Td \leq \alpha,j \in I_{\in}(\theta_t)
\end{array}</script><p> 其中 $I_{\in}(\theta_t)$ 定义</p>
<script type="math/tex; mode=display">
I_{\in} (\theta_t) = \{j \in I | G_j (\theta) \geq - \epsilon \}</script><p>令 $(d^k,a^k)$ 是多任务学习问题的解，则</p>
<ul>
<li><p>如果 $\theta_t$ 是严格受限于 $\Omega_k$，则 $d_t = 0 \in R^n$ 且 $\alpha_t = 0$</p>
</li>
<li><p>如果 $\theta_t$ 不是严格受限于 $\Omega_k$，则</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\alpha_{t} \leq-\frac{1}{2}\left\|d_{t}\right\|^{2}<0 \\
\nabla L_{i}\left(\theta_{t}\right)^{T} d \leq \alpha,& i=1, \ldots, m \\
\nabla G_{j}\left(\theta_{t}\right)^{T} d \leq \alpha,& j \in I_{\epsilon}\left(\theta_{t}\right)
\end{array}</script><p>迭代公式</p>
<script type="math/tex; mode=display">
\theta_{t+1} = \theta_t + \eta d_t</script></li>
</ul>
<p>通过求解上述问题，能够获得一个有效的搜索方向</p>
<h4 id="大规模求解方法"><a href="#大规模求解方法" class="headerlink" title="大规模求解方法"></a>大规模求解方法</h4><p>上述方法能够获得一个有效的搜索方向，对于大规模的问题，会比较困难，这里将问题重写，将其表示为对偶形式</p>
<ul>
<li><p>$KKT$ 条件</p>
<script type="math/tex; mode=display">
\begin{array}{l}
& d_{t} =-\sum_{i=1}^{m} \lambda_{i} \nabla L_{i}\left(\theta_{t}\right)+\sum_{j \in I_{\epsilon}(\theta)} \beta_{i} \nabla G_{j}\left(\theta_{t}\right) \\
\text{s.t.} & \sum_{i=1}^{m} \lambda_{i}+\sum_{j \in I_{\epsilon}(\theta)} \beta_{j}=1
\end{array}</script></li>
<li><p>对偶问题</p>
<script type="math/tex; mode=display">
\begin{array}{l}
& \max_{\lambda_{i}, \beta_{j}}-\frac{1}{2}\left\|\sum_{i=1}^{m} \lambda_{i} \nabla L_{i}\left(\theta_{t}\right)+\sum_{j \in I_{\epsilon}(\theta)} \beta_{i} \nabla G_{j}\left(\theta_{t}\right)\right\|^{2} \\
\text { s.t. } & \sum_{i=1}^{m} \lambda_{i}+\sum_{j \in I_{\epsilon}(\theta)} \beta_{j}=1 \\ 
& \lambda_{i} \geq 0, \beta_{j} \geq 0 \\
& \forall i=1, \cdots, m\\
& \forall j \in I_{\epsilon}(\theta)
\end{array}</script></li>
</ul>
<p>将多任务学习转化为其对偶问题后，求解空间不再是参数空间，而是变成了任务个数和受限条件数，使得求解问题极大的减少了</p>
<p>Pareto MTL 算法如下图</p>
<p><img src="/image/多目标优化笔记/pareto_MTL.png" style="zoom: 50%;" /></p>
<p>为表述方便，这里引用论文中关于多任务学习的定义</p>
<p>设 $f(x)$ 表面光滑</p>
<script type="math/tex; mode=display">
f(x):\mathcal{R}^n \rightarrow \mathcal{R}^m \\
f_i(x):\mathcal{R}^n \rightarrow \mathcal{R},i=1,\cdots,m</script><h3 id="准备：-Krylov-子空间"><a href="#准备：-Krylov-子空间" class="headerlink" title="准备：$Krylov$ 子空间"></a>准备：$Krylov$ 子空间</h3><p>大规模稀疏线性方程组 $AX=b$ 求解的首先方法是 $krylov$ 子空间方法，基本思想是在一个较小的子空间 $\mathcal{K} \subset R_n$ 中寻找近似解</p>
<p>定义：设 $A \in R^{n \times n},r \in R^n$，则</p>
<script type="math/tex; mode=display">
\mathcal{K}_{m}(A, r) \triangleq \text{span}\{r, Ar, \cdots, A^{m-1} r\} \subseteq R_{n}</script><p>是由 $A$ 和 $r$ 生成的 $Krylov$ 子空间，通常简记为 $\mathcal{K}_m$，$Krylov$ 子空间有如下的三个性质</p>
<ul>
<li>$Krylov$ 子空间嵌套性：$\mathcal{K}_{1} \subseteq \mathcal{K}_{2} \subseteq \cdots \subseteq \mathcal{K}_{m}$</li>
<li>$\mathcal{K}_m$ 的维数不超过 $m$</li>
<li>$\mathcal{K}_{m}(A, r)=\{x=p(A)\}$，$r$ 为次数小于 $m$ 的多项式</li>
</ul>
<p>求解 $Krylov$ 子空间的解来近似原始线性方程组的解</p>
<p><img src="/image/多目标优化笔记/krylov.png" style="zoom:50%;" /></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>Pareto 平稳点（Pareto Stationary）：设 $f_i(x)$ 连续可身微，点 $x$ 称为 Pareto 平稳点，如果存在 $\alpha \in \mathcal{R}^{m},a_i \geq 0$ 使得下式成立</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{m} \alpha_i \nabla f_i(x) = 0 \\
\sum_{i=1}^{m} \alpha_i = 1</script></li>
<li><p>Pareto 点都是 Pareto 平稳点</p>
</li>
<li><p>设 $f(x)$ 是光滑且 $x^{\ast}$ 是 Pareto 点，$x(t)$ 是过点 $x^{\ast}$ 的曲线</p>
<script type="math/tex; mode=display">
x(t):t\in (-\epsilon,\epsilon) \rightarrow \mathcal{R}^n \\
x(0) = x^{\ast}</script><p>则存在 $\beta \in \mathcal{R}^m$ 使得</p>
<script type="math/tex; mode=display">
H(x^{\ast})x'(t) = \nabla f(x^{\ast})^T \beta \\
H(x^{\ast}) = \sum_{i=1}^{m} \alpha_i \nabla^2 f_i(x^{\ast})</script><p>$x’(t)$ 为切线</p>
</li>
</ul>
<p>上式表明,算子 $H(x^{\ast})$ 将点 $x$ 处的切向量 $v = x’(t)$ 变换为由 $∇f_i(x^{\ast})$ 扩张成的 $Krylov$ 子空间的向量</p>
<p><img src="/image/多目标优化笔记/krylov_expand.png" style="zoom:70%;" /></p>
<h3 id="离散-Pareto-求解"><a href="#离散-Pareto-求解" class="headerlink" title="离散 Pareto 求解"></a>离散 Pareto 求解</h3><p>给定初始点 $x_0 \in \mathcal{R}^n,f_i(x)$ 光滑，可以从如下三步来获取连续 Pareto 解</p>
<ul>
<li>求解 Pareto 平稳点: 从初始点 $x_0$ 出发，通过梯度下降的方法求解 Pareto 平稳点 $x_0^{\ast}$</li>
<li>扩展 Pareto 平稳点，$f(x)$ 在点 $x_0^{\ast}$ 处光滑，如果 Pareto 前沿存在，则在点 $x_0^{\ast}$ 处的某个领域内存在 Pareto 平稳点，由此出发，可以求得一系列的 Pareto 平稳点 $x_i^{\ast}$</li>
<li>将已知的平稳点所在的局部 Pareto 前沿进行连接合并，扩充成更大的连续Pareto 前沿</li>
</ul>
<p><img src="/image/多目标优化笔记/pareto_front.png" style="zoom:50%;" /></p>
<p>接下来讨论获取 Pareto 平稳点的方法</p>
<h3 id="梯度求解法"><a href="#梯度求解法" class="headerlink" title="梯度求解法"></a>梯度求解法</h3><p>见上述</p>
<h3 id="一阶梯度求解法扩张"><a href="#一阶梯度求解法扩张" class="headerlink" title="一阶梯度求解法扩张"></a>一阶梯度求解法扩张</h3><p>通过梯度求解法求解出 Pareto 平稳点 $x_0^{\ast}$ 后，基于该点扩展出局部 Pareto 集 $\{x_i \}$，这一过程分解为两步</p>
<ul>
<li>计算权重 $\alpha$</li>
<li>求解搜索方向 $v$，估计梯度迭代的搜索方向 $v_i$</li>
</ul>
<p>通过如下更新公式求解</p>
<script type="math/tex; mode=display">
x_i = x_0^{\ast} + sv_i</script><p>计算 $\alpha$ 可以归结为求解如下的约束问题</p>
<script type="math/tex; mode=display">
\min_\alpha \| \sum_{i=1}^m \alpha_i \nabla f_i(x_0^{\ast}) \|^2 \\
\text{s.t.} \quad \alpha_i \geq 0,\sum_{i=1}^m \alpha_i = 1</script><p>上述问题规模为 $m$， 量级较小，可以很方便的求解出来</p>
<p>再由基本概念，得求解的线性方程组</p>
<script type="math/tex; mode=display">
H(x_0^{\ast})v = \nabla f(x_0^{\ast})^T \beta</script><p>上述问题求解有两个难点</p>
<ul>
<li>$x_0^{\ast}$ 不一定为 Pareto 平稳点</li>
<li>当 $n$ 非常大时，求解起来非常困难</li>
</ul>
<p>为此引入校正向量 $c$（correction vector），约束问题改写为</p>
<script type="math/tex; mode=display">
\begin{array}{l}
&\min_{a,c} \| c \|^2 \\
\text{s.t.} & \alpha_i \geq 0 \\
& \sum_{i=1}^m \alpha_i = 1 \\
& \sum_{i=1}^{m} \alpha_i(\nabla f_i(x_0^{\ast})-c)=0
\end{array}</script><p>用 $\nabla f_i(x_0^{\ast})-c$ 近似 $\nabla f_i(x_0^{\ast})$，$x_0^{\ast}$ 将会是 Pareto 平稳点</p>
<p>设 $a^{\ast}$ 是未引入校正向量约束问题的解，则引入 $c$ 后的解为</p>
<script type="math/tex; mode=display">
(a,c) = (a^{\ast},\nabla f(x_0^{\ast})^T a^{\ast})</script><p>在计算出 $a^{\ast},x_0^{\ast},c$ 后，可以计算出 $\nabla f(x_0^{\ast})$，考虑如下稀疏线性方程组</p>
<script type="math/tex; mode=display">
H(x_0^{\ast})v = (\nabla f(x_0^{\ast})^T - c^T) \beta</script><p>$\beta$ 为随机生成的向量，$v$ 为待求解的变量。上述式可以通过 $krylov$ 子空间，$MINERS$ 方法求解</p>
<p>寻找离散 Pareto 解集合的求解算法</p>
<ul>
<li>Input：随机初始化网络</li>
<li>ParetoExpand($x^{\ast}$) 生成点 $x^{\ast}$ 的 $K$ 个搜索方向 $v_i$</li>
<li>由 $K$ 个搜索方向扩展出 $K$ 个子网络</li>
<li>更新子网络节点 $x_i = x^{\ast} + sv_i$</li>
<li>ParetoExpand($x_i$) 输出 Pareto 平稳点 $x_i^{\ast}$</li>
<li>Output：$N$ 个 Pareto 平稳网络</li>
</ul>
<p><img src="/image/多目标优化笔记/efficient_Pareto.png" style="zoom: 60%;" /></p>
<h3 id="连续-Pareto-解（Pareto-front）构建"><a href="#连续-Pareto-解（Pareto-front）构建" class="headerlink" title="连续 Pareto 解（Pareto front）构建"></a>连续 Pareto 解（Pareto front）构建</h3><p>通过前面求解出来 $N$ 个 Pareto 平稳网络（父节点及 $K$ 个子网络），由离散 Pareto 点合并成更大的连续 Pareto 前沿</p>
<p>给定 $x_i^{\ast}$ 及基其对应的 $K$ 个节点 $\{ {x_i^{\ast}}_1,\cdots,{x_i^{\ast}}_k \}$，定义连续变量 $r_{i \rightarrow {i}_j} \in [0,1]$ 以及搜索方向</p>
<script type="math/tex; mode=display">
v_{i \rightarrow {i}_j} = {x_i^{\ast}}_j - x_i^{\ast},j = 1,2,\cdots,K</script><p>$x_i^{\ast}$ 处局部 Pareto 集可以通过下式进行构建</p>
<script type="math/tex; mode=display">
S(x_i^{\ast}) = \{x_i^{\ast} + \sum_{i=1}^K r_{i \rightarrow {i}_j} u_{i \rightarrow {i}_j} | r_{i \rightarrow {i}_j} \geq 0,\sum_{i=1}^K r_{i \rightarrow {i}_j} \leq 1 \}</script><p>$S(x_i^{\ast})$ 是点 $x_i^{\ast}$ 及对应的 $K$ 个子节点 $\{ {x_i^{\ast}}_1,\cdots,{x_i^{\ast}}_K \}$ 构成的凸包，切平面中切向量的线性组合仍然在切平面</p>
<p>对于 $N$ 个局部 Pareto 集</p>
<script type="math/tex; mode=display">
\{ S(x_1^{\ast}),\cdots,S(x_N^{\ast}) \}</script><p>可以将两两接壤处合并成一个更大的局部 Pareto 集合，全部合并完后，可以生成多个的连续 Pareto 前沿</p>
<p><img src="/image/多目标优化笔记/pareto_continuous.png" style="zoom:67%;" /></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://engineering.purdue.edu/~sudhoff/ee630/Lecture09.pdf">https://engineering.purdue.edu/~sudhoff/ee630/Lecture09.pdf</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/352461938">https://zhuanlan.zhihu.com/p/352461938</a></li>
<li><a href="https://hpzhao.github.io/2018/09/17/多目标优化四种方法/">https://hpzhao.github.io/2018/09/17/多目标优化四种方法/</a></li>
<li><a href="https://www.zhihu.com/question/23311674">https://www.zhihu.com/question/23311674</a></li>
<li><a href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions</a></li>
</ul>
]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>多目标优化</tag>
        <tag>最优化方法</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2022暑假独居生活</title>
    <url>/2022/06/12/%E6%88%91%E7%9A%842022%E6%9A%91%E5%81%87%E7%8B%AC%E5%B1%85%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一张小方桌，有一荤一素</p>
<span id="more"></span>
<h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><h3 id="2022年6月10日"><a href="#2022年6月10日" class="headerlink" title="2022年6月10日"></a>2022年6月10日</h3><ul>
<li>青椒土豆丝</li>
<li>腊肠蒸蛋</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-06-10.png" style="zoom: 50%;" /></p>
<h3 id="2022年6月11日"><a href="#2022年6月11日" class="headerlink" title="2022年6月11日"></a>2022年6月11日</h3><ul>
<li>青椒土豆丝</li>
<li>红烧带鱼</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-06-11.png" style="zoom: 50%;" /></p>
<h3 id="2022年6月12日"><a href="#2022年6月12日" class="headerlink" title="2022年6月12日"></a>2022年6月12日</h3><ul>
<li>土豆鸡腿</li>
<li>炒青菜</li>
<li>紫菜蛋汤</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-06-12.png" style="zoom: 50%;" /></p>
<h3 id="2022年6月13日"><a href="#2022年6月13日" class="headerlink" title="2022年6月13日"></a>2022年6月13日</h3><ul>
<li>番茄鸡蛋面</li>
<li>包菜炒肉</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-06-13.png" style="zoom: 50%;" /></p>
<h3 id="2022年6月14日"><a href="#2022年6月14日" class="headerlink" title="2022年6月14日"></a>2022年6月14日</h3><ul>
<li>番茄鸡蛋面</li>
<li>包菜炒肉</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-06-14.png" style="zoom: 50%;" /></p>
<h3 id="2022年6月16日"><a href="#2022年6月16日" class="headerlink" title="2022年6月16日"></a>2022年6月16日</h3><ul>
<li>蛋黄粽</li>
<li>红枣粽</li>
<li>虎皮青椒</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-06-16.png" style="zoom: 50%;" /></p>
<h3 id="2022年6月17日"><a href="#2022年6月17日" class="headerlink" title="2022年6月17日"></a>2022年6月17日</h3><ul>
<li>红烧鳊鱼</li>
<li>土豆洋葱炒腊肠</li>
<li>紫菜蛋汤</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-06-17.png" style="zoom: 50%;" /></p>
<h3 id="2022年6月23日-30-日"><a href="#2022年6月23日-30-日" class="headerlink" title="2022年6月23日 - 30 日"></a>2022年6月23日 - 30 日</h3><ul>
<li>去学校天天吃大餐</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-06-24.png" style="zoom: 50%;" /></p>
<p><img src="/image/我的2022暑假独居生活/2022-06-30.png" style="zoom: 50%;" /></p>
<h3 id="2022年07月02日"><a href="#2022年07月02日" class="headerlink" title="2022年07月02日"></a>2022年07月02日</h3><ul>
<li>蒸贝贝南瓜</li>
<li>蒜蓉茄子</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-07-02.png" style="zoom: 50%;" /></p>
<h3 id="2022年07月03日"><a href="#2022年07月03日" class="headerlink" title="2022年07月03日"></a>2022年07月03日</h3><ul>
<li>金色传说煎饺</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-07-03.png" style="zoom: 50%;" /></p>
<h3 id="2022年07月04日"><a href="#2022年07月04日" class="headerlink" title="2022年07月04日"></a>2022年07月04日</h3><ul>
<li>空气炸锅奥尔良鸡腿</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-07-04.png" style="zoom: 50%;" /></p>
<h3 id="2022年07月07日"><a href="#2022年07月07日" class="headerlink" title="2022年07月07日"></a>2022年07月07日</h3><ul>
<li><p>番茄马铃薯排骨</p>
</li>
<li><p>炒豇豆</p>
</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-07-07.png" style="zoom: 50%;" /></p>
<h3 id="2022年07月14日"><a href="#2022年07月14日" class="headerlink" title="2022年07月14日"></a>2022年07月14日</h3><ul>
<li>奥尔良鸡腿</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-07-14.png" style="zoom: 50%;" /></p>
<h3 id="2022年07月19日"><a href="#2022年07月19日" class="headerlink" title="2022年07月19日"></a>2022年07月19日</h3><ul>
<li>糖果煮蛋</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-07-19.png" style="zoom: 50%;" /></p>
<h3 id="2022年07月20日"><a href="#2022年07月20日" class="headerlink" title="2022年07月20日"></a>2022年07月20日</h3><ul>
<li><p>空气炸锅鸡米花</p>
</li>
<li><p>丝瓜炒蛋</p>
</li>
<li><p>番茄鸡蛋汤</p>
</li>
<li><p>青椒土豆丝</p>
</li>
</ul>
<p><img src="/image/我的2022暑假独居生活/2022-07-20.png" style="zoom: 50%;" /></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>拉格朗日插值多项式</title>
    <url>/2021/10/06/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在数值分析中，多项式插值是最常提到的内容</p>
<span id="more"></span>
<h2 id="多项式插值"><a href="#多项式插值" class="headerlink" title="多项式插值"></a>多项式插值</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p> 给定有序点集 $\{x_0,x_1,\cdots,x_n\}$ 且 $x_0 \lt x_1\lt \cdots\lt x_n$ 以及定义在 $x_0,x_n$ 上的连续函数$f(x)$或对应于 $x$ 值的 $y$ 值集合 $y_0,y_1,\cdots,y_n$ (即 $(x_i,y_i)$) 对.<br>多项式插值就是要求出对数据 $(x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)$ 进行插值的次数最多为 $n$ 的多项式 $p(x)$ ,即</p>
<script type="math/tex; mode=display">y_0 = p(x_0)</script><script type="math/tex; mode=display">y_1 = p(x_1)</script><script type="math/tex; mode=display">\vdots</script><script type="math/tex; mode=display">y_n = p(x_n)</script><p> 称 $p$ 在 $\{x_0,x_1,\cdots,x_n\}$ 上插值 $f$ ，且 $p$ 是插值. 插值必须在相应点 $\{x_0,x_1,\cdots,x_n\}$ 上与函数 $f$ 或  $y_0,y_1,\cdots,y_n$ 取值相同，这些点通常称为节点(或分割点).<br> 则插值多项式为</p>
<script type="math/tex; mode=display">p(x) = a_n x^n + a_n-1 x^n-1 + \cdots + a_1 x + a_0</script><p> 插值条件为</p>
<script type="math/tex; mode=display">a_n x_0^n + a_n-1 x_0^n-1 + \cdots +a_1 x_0 + a_0 = y_0</script><script type="math/tex; mode=display">a_n x_1^n + a_n-1 x_1^n-1 + \cdots +a_1 x_1 + a_0 = y_1</script><script type="math/tex; mode=display">\vdots</script><script type="math/tex; mode=display">a_n x_n^n + a_n-1 x_n^n-1 + \cdots +a_1 x_n + a_0 = y_n</script><p> 其中矩阵</p>
<script type="math/tex; mode=display">V = \begin{bmatrix}1&x_0 &x_0^2 & \cdots & x_0^n \\1&x_1 &x_1^2 & \cdots & x_1^n \\ 1&x_2 &x_2^2 & \cdots & x_2^n \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 1&x_n &x_n^2 & \cdots & x_n^n \end{bmatrix}</script><p> 由 $x$ 构成，形如 $V$ 的矩阵称为 $Vandermonde$ 矩阵，如果 $x_i$ 互异，则 $Vandermonde$ 矩阵非奇异，因此多项式插值存在且唯一. 插值多项式的系数由方程</p>
<script type="math/tex; mode=display">V \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_n\end{bmatrix} = \begin{bmatrix} y_0 \\ y_1 \\ \vdots \\ y_n\end{bmatrix}</script><p> 的解给出，可以采用Vandermonde方程组的专门解法解出.</p>
</blockquote>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>对正弦曲线上的数据点 $(0,0),( \pi / 2,1),( \pi ,0),(3 \pi / 2, -1)$进行多项式插值，这里 $\{x_0,x_1,x_2,x_3 \} = \{ 0,\pi / 2,\pi ,3 \pi /2 \} , \{y_0,y_1,y_2,y_3 \} = \{ 0,1,0,-1 \} $,求解</p>
<script type="math/tex; mode=display">\begin{bmatrix} 1&0&0&0 \\ 1&\frac{\pi}{2} & \frac{\pi^2}{4} & \frac{\pi^3}{8} \\ 1 & \pi & \pi^2 & \pi^3 \\ 1 & \frac{3\pi}{2} & \frac{9\pi^2}{4} & \frac{27\pi^3}{8}\end{bmatrix}  \begin{bmatrix} a_0 \\ a_1 \\ a_2 \\ a_3\end{bmatrix} = \begin{pmatrix} 0 \\ 1 \\ 0 \\ -1 \end{pmatrix}</script><p>得 $ a_0,a_1,a_2,a_3 $<br><code>V\y</code></p>
<script type="math/tex; mode=display">\begin{bmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \end{bmatrix} = \begin{pmatrix} 0 \\ 1.6977 \\ -0.8106 \\ 0.0860 \end{pmatrix}</script><p>得</p>
<script type="math/tex; mode=display">p(x) = 0.0860 x^3 - 0.8106 x^2 +1.6997 x</script><p>验证<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">3</span>/<span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br><span class="line">a = [<span class="number">0.0860</span> <span class="number">-0.8106</span> <span class="number">1.6977</span> <span class="number">0</span>];</span><br><span class="line">p = polyval(a,x);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;k-&#x27;</span>,x,p,<span class="string">&#x27;r--&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sin(x)&#x27;</span>,<span class="string">&#x27;polyval(a,x)&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="/image/拉格朗日插值多项式/1.svg" alt="1"></p>
<h3 id="Runge函数"><a href="#Runge函数" class="headerlink" title="Runge函数"></a>Runge函数</h3><blockquote>
<p>多项式插值近似函数的效果似乎不错，但有时很差，因为Vandermonde矩阵一般是病态的，即使求解过程是精确的.<br>比如高阶多项式插值的振荡问题，即在节点间出现大的迂回.<br><strong>Runge函数</strong></p>
<script type="math/tex; mode=display">f(x) = \frac{1}{1 + 25 x^2}</script><p>图中画出了Runge函数以及它的10次插值多项式，函数的振幅会随着n的增大而增大，近似程度将越来越差， $x \in (-1,1)$ 时</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">-1</span>:<span class="number">0.2</span>:<span class="number">1</span>;</span><br><span class="line">x_ = <span class="built_in">linspace</span>(<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">x = x&#x27;;</span><br><span class="line">y = <span class="number">1.</span>/(<span class="number">1</span>+<span class="number">25.</span>*(x.^<span class="number">2</span>));</span><br><span class="line">y_ = <span class="number">1.</span>/(<span class="number">1</span>+<span class="number">25.</span>*(x_.^<span class="number">2</span>));</span><br><span class="line">A = <span class="built_in">ones</span>(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">A = [A x.^<span class="built_in">i</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a = A\y;</span><br><span class="line">a = a&#x27;;</span><br><span class="line">a = a(:,<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">x = <span class="number">-1</span>:<span class="number">0.001</span>:<span class="number">1</span>;</span><br><span class="line">p=<span class="built_in">zeros</span>(<span class="number">11</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">10</span>:<span class="number">-1</span>:<span class="number">0</span></span><br><span class="line">p = p+a(<span class="number">1</span>,<span class="number">11</span>-<span class="built_in">i</span>)*(x.^<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(x_,y_,<span class="string">&#x27;k-&#x27;</span>,x,p,<span class="string">&#x27;r--&#x27;</span>),<span class="built_in">legend</span>(<span class="string">&#x27;1/(1+25*(x^2))&#x27;</span>,<span class="string">&#x27;p(x)&#x27;</span>),xlim([<span class="number">-1</span>,<span class="number">1</span>]),ylim([<span class="number">-0.5</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    <img src="/image/拉格朗日插值多项式/2.svg" alt="2"></p>
<blockquote>
<p>因此需要推导和理解其他方法.</p>
</blockquote>
<h2 id="拉格朗日插值多项式"><a href="#拉格朗日插值多项式" class="headerlink" title="拉格朗日插值多项式"></a>拉格朗日插值多项式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>假定要对两个互异点 $x_a,x_b$ 进行直线插值，先定义函数 $ L_a(x) $ 和 $ L_b(x) $</p>
<script type="math/tex; mode=display">L_a(x) = \frac{x - x_b }{x_a - x_b}</script><script type="math/tex; mode=display">L_b(x) = \frac{x - x_a }{x_b - x_a}</script><p>则</p>
<script type="math/tex; mode=display">L_a(x_a ) = 1,\quad L_a(x_b = 0)</script><script type="math/tex; mode=display">L_b(x_a ) = 1,\quad L_b(x_b = 0)</script><p>且<br>$ L_a(x) $和 $ L_b(x) $ 都是 $x$ 的线性函数.给定 $y_a = f(x_a )$ 和 $y_b = f(x_b )$，则</p>
<script type="math/tex; mode=display">l(x) = y_a L_a (x) + y_b L_b (x)</script><p>满足</p>
<script type="math/tex; mode=display">\begin{aligned} l(x_a ) ={}& y_a L_a (x_a) + y_b L_b (x_a) {} \\ ={}& y_a \cdot 1 + y_b \cdot 0 \\ ={}& y_a \end{aligned}</script><script type="math/tex; mode=display">\begin{aligned} l(x_b ) ={}& y_a L_a (x_b) + y_b L_b (x_b) {} \\ ={}& y_a \cdot 1 + y_b \cdot 0 \\ ={}& y_b \end{aligned}</script><p>即 $l(x)$ 是 $f$ 在 $(x_a , y_a )$ 和 $(x_b,y_b)$ 上的插值.由于 $l(x)$ 是两个线性函数的和，所以是线性的，又因为过互异两点的直线只有一条，所以 $l(x)$ 是唯一的.<br>将这种做法推广到 $n+1$ 个互异点 $x_0,x_1,\cdots,x_n $(有序且 $ x_0 \lt x_1 \lt \cdots \lt x_n $ )，定义函数</p>
<script type="math/tex; mode=display">\begin{aligned} L_{n,i} (x) ={}& \frac{(x-x_0)(x-x_1) \cdots (x-x_{i-1})(x-x_{i+1}) \cdots (x-x_n)}{(x_i-x_0)(x_i-x_1) \cdots (x_i-x_{i-1})(x_i-x_{i+1}) \cdots (x_i-x_n)} \\ ={}& \prod_{k=0 \\ k\neq i}^{n} \frac{(x-x_k)}{(x_i - x_k)} \end{aligned}</script><p>当 $n \neq i$ 时，有</p>
<script type="math/tex; mode=display">L_{n,i} (x_n) = 0</script><script type="math/tex; mode=display">L_{n,i} (x_i) = 1</script><p>上式为Lagrange多项式.<br>由于 $n$ 次多项式的和是次数最多为 $n$ 的多项式，所以用Lagrange多项式可以得到过点 $(x_0,y_0),(x_1,y_1), \cdots , (x_n,y_n) $ 的次数不超过 $n$ 的插值多项式 $p(x)$ </p>
<script type="math/tex; mode=display">\begin{aligned} p(x) ={}& y_0 L_{n,0} (x) + y_1 L_{n,1} (x) + \cdots + y_n L_{n,n} (x) \\ ={}& \sum_{i=1}^{n} y_i L_n (x) \end{aligned}</script><p>有 $L_i(x_j) = 0 $</p>
<script type="math/tex; mode=display">\begin{aligned} p(x) ={}& \sum_{i=0}^{n} y_i L_i (x_j) \\ ={}& y_0 L_0 (x_j) + y_1 L_1 (x_j) + \cdots + y_n L_n (x_j) \\ ={}& y_j \cdot 1 \\ ={}& y_j \end{aligned}</script><p>$p$ 就是所求的多项式插值，与Vandermonde矩阵的结果相同.</p>
</blockquote>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>对正弦曲线上的数据点 $(0,0),( \pi / 2,1),( \pi ,0),(3 \pi / 2, -1)$进行多项式插值，这里 $\{x_0,x_1,x_2,x_3 \} = \{ 0,\pi / 2,\pi ,3 \pi /2 \} , \{y_0,y_1,y_2,y_3 \} = \{ 0,1,0,-1 \} $,Lagrange多项式</p>
<script type="math/tex; mode=display">\begin{aligned}L_0(x) ={}& \frac{(x-x_1)(x-x_2)(x-x_3)}{(x_0-x_1)(x_0-x_2)(x_0-x_3)} \\ ={}& - \frac{4}{3\pi^3} (x-\frac{\pi}{2})(x-\pi)(x-\frac{3\pi}{2}) \end{aligned}</script><script type="math/tex; mode=display">L_1(x) = \frac{4}{\pi^3}x(x-\pi)(x-\frac{3\pi}{2})</script><script type="math/tex; mode=display">L_2(x) = - \frac{4}{3\pi^3} (x-\frac{\pi}{2})(x-\frac{3\pi}{2})</script><script type="math/tex; mode=display">L_3(x) = \frac{4}{3\pi^3} (x-\frac{\pi}{2})(x-\pi)</script><p>插值多项式为</p>
<script type="math/tex; mode=display">\begin{aligned} p(x) ={}& 0 \cdot L_0(x) + 1 \cdot L_1(x) + 0 \cdot L_2(x) + (-1) \cdot L_3(x) \\ ={}& 0.0860 x^3 - 0.8106 x^2 +1.6997 x \end{aligned}</script><p>同前</p>
</blockquote>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h5 id="Cauchy余项定理"><a href="#Cauchy余项定理" class="headerlink" title="Cauchy余项定理"></a>Cauchy余项定理</h5><blockquote>
<p>给定 $a \leq x_0 \lt x_1 \lt \cdots \lt x_n \leq b$ 及 $f \in C^{n+1}[a,b]$，则对任意 $x \in [a,b]$，都存在 $\xi = \xi(x) \in [a,b]$，使$f$在$x_0,x_1,\cdots,x_n$ 上的插值多项式 $p(x)$ 满足</p>
<script type="math/tex; mode=display">f(x) - p(x) = \frac{f^{n+1}(\xi)}{(n+1)!}(x-x_0)(x-x_1)\cdots(x-x_n)</script><p>证明略</p>
</blockquote>
<h4 id="Weierstrass定理"><a href="#Weierstrass定理" class="headerlink" title="Weierstrass定理"></a>Weierstrass定理</h4><blockquote>
<p>若$f \in C[a,b]$，则对任意给定的 $\varepsilon \gt 0$ 都存在多项式 $p(x)$ ,使对任意 $x \in [a,b]$，有</p>
<script type="math/tex; mode=display">\left | f(x) - p(x) \right | \leq \varepsilon</script><p>说明任何连续函数都可以被高次多项式任意逼近.</p>
</blockquote>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>Lagrange只讨论了求出插值多项式系数的方法，区间外，Lagrange插值是不准确的，如果问题中要求多项式的值，可以使用更为有效和精确的方法.</p>
]]></content>
      <categories>
        <category>数值分析</category>
      </categories>
      <tags>
        <tag>多项式插值</tag>
      </tags>
  </entry>
  <entry>
    <title>拟合和统计中的检验参数</title>
    <url>/2021/10/20/%E6%8B%9F%E5%90%88%E5%92%8C%E7%BB%9F%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%A3%80%E9%AA%8C%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>数据分析中无处不在的知识点</p>
<span id="more"></span>
<blockquote>
<p>SSE(和方差、误差平方和)：The sum of squares due to error<br>MSE(均方差、方差)：Mean squared error<br>RMSE(均方根、剩余标准差)：Root mean squared error<br>$R^2$(判断系数，拟合优度)：Coefficient of determination</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在统计学中，均方误差是参数估计值与参数真值之差平方的期望值，是衡量“平均误差”的一种较方便的方法，MSE可以评价数据的变化程度，MSE的值越小，说明预测模型描述实验数据具有更好的精确度。</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h4><p>方差是在概率论和统计方差衡量随机变量或一组数据的离散程度的度量方式，方差越大，离散度越大。求解方式为，各随机变量与平均值差值的平方和的平均数<br>平均数：</p>
<script type="math/tex; mode=display">M = \frac{x_1+x_2+x_3+\cdots+x_n}{n}</script><p>方差公式：</p>
<script type="math/tex; mode=display">S^2 = \frac{(x_1-M)^2+(x_1-M)^2+\cdots+(x_n-M)^2}{n}</script><h4 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h4><p>标准差就是方差的算术平方根，它反映组内个体间的离散程度。因此它的过程是与平均值之间进行差值计算<br>标准差公式：</p>
<script type="math/tex; mode=display">\sigma=\sqrt{\frac{1}{n}\sum_{i=1}^n(x_i-\mu)^2}</script><h4 id="样本方差"><a href="#样本方差" class="headerlink" title="样本方差"></a>样本方差</h4><script type="math/tex; mode=display">\hat{\sigma}^2=\frac{1}{n-1}\sum_{i=1}^n(x_i-\mu)^2</script><h2 id="SSE（误差平方和）"><a href="#SSE（误差平方和）" class="headerlink" title="SSE（误差平方和）"></a>SSE（误差平方和）</h2><p>在统计学里，该参数计算的是拟合数据很原始数据对应点的误差的平方和，计算公式为：</p>
<script type="math/tex; mode=display">SSE = \sum_{i=1}^m(y_i - \hat{y}_i)^2</script><p>$y_i$是真实数据，$\hat{y}_i$是拟合数据</p>
<h2 id="MSE（方差）"><a href="#MSE（方差）" class="headerlink" title="MSE（方差）"></a>MSE（方差）</h2><p>是预测数据和原始数据对应点误差的平方和的均值，也就是$\frac{SSE}{n-m}$，$n$是观测数据的个数，$m$j是拟合数据的个数,和$SSE$没有太大的区别，计算公式为：</p>
<script type="math/tex; mode=display">MSE=\frac{SSE}{n-m}=\frac{1}{n-m}\sum_{i=1}^{n}(y_i-\hat{y_i })^2</script><h2 id="RMSE（剩余标准差）"><a href="#RMSE（剩余标准差）" class="headerlink" title="RMSE（剩余标准差）"></a>RMSE（剩余标准差）</h2><p>也是叫回归系统的拟合标准差，是$MSE$的平方根，计算公式为：</p>
<script type="math/tex; mode=display">RMSE=\sqrt{MSE}=\sqrt{\frac{1}{n-m}\sum_{i=1}^{n}(y_i-\hat{y_i })^2}</script><h2 id="R-2-判断系数"><a href="#R-2-判断系数" class="headerlink" title="$R^2$(判断系数)"></a>$R^2$(判断系数)</h2><p>在讲判断系数之前，先介绍另外两个参数$SSR$和$SST$，因为判断系数就是由这两个参数决定的<br>对总平方和$SST = \sum_{i=1}^{n}(y_i-\overline{y})^2$进行分解，有</p>
<script type="math/tex; mode=display">SST = SSE+SSR,SSR = \sum_{i=1}^{n}(\hat{y_i}-\overline{y})^2</script><p>其中$\overline{y} = \frac{1}{n}\sum_{i=1}^{n}y_i$，$SSE$是误差平方和，反映随机误差对$y$的影响，$SSR$是回归平方和，反映自变量对$y$的影响<br>判断系数定义为</p>
<script type="math/tex; mode=display">R^2 = \frac{SSR}{SST} = \frac{SST-SSE}{SST} = 1-\frac{SSE}{SST}</script><h2 id="调整的-R-2"><a href="#调整的-R-2" class="headerlink" title="调整的$R^2$"></a>调整的$R^2$</h2><p>统计学家主张在回归建模时，就采用尽可能少的自变量，不要盲目地追求判定系数的提高。当变量增加时，残量的自由度就会减少。而自由度越小，数据的统计趋势就越不容易显现。为此，又定义了一个调整判断系数</p>
<script type="math/tex; mode=display">\overline{R^2} = 1-\frac{SSE/(n-m)}{SST/(n-1)}</script><p>$\overline{R^2}$与$R^2$的关系是</p>
<script type="math/tex; mode=display">\overline{R^2} = 1-(1-R^2)\frac{n-1}{n-m}</script><p>当$n$很小，$m$很大时，$\overline{R^2}$会远小于$R^2$</p>
]]></content>
      <categories>
        <category>统计学</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>最小化交叉熵损失与最大似然估计的推导</title>
    <url>/2022/03/05/%E6%9C%80%E5%B0%8F%E5%8C%96%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E4%B8%8E%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E7%9A%84%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>机器学习所使用的交叉熵损失函数与信息论里的交叉熵的推导与思考</p>
<span id="more"></span>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="信息论中的交叉熵定义"><a href="#信息论中的交叉熵定义" class="headerlink" title="信息论中的交叉熵定义"></a>信息论中的交叉熵定义</h3><script type="math/tex; mode=display">
H(p,q) = H(p) + D_{KL}(p||q)</script><p>在 $ p,q $ 是离散分布时， 上式等价为</p>
<script type="math/tex; mode=display">
H(p,q) = -\sum^K_{i=1} p(x_i) \log q(x_i)</script><p>其中， $x_i$ 是 $p,q$ 分布共同样本空间的同一个样本点，样本空间的大小为 $K$</p>
<h3 id="机器学习中的交叉熵定义"><a href="#机器学习中的交叉熵定义" class="headerlink" title="机器学习中的交叉熵定义"></a>机器学习中的交叉熵定义</h3><p>机器学习进行优化时， 会把所有样本的交叉熵值求平均，假设有 $N$ 个样本</p>
<script type="math/tex; mode=display">
J(w) = \frac{1}{N} \sum^N_{n=1} H(p_n,q_n)</script><p>而信息论中的交叉熵仅仅是针对一个样本</p>
<p>因为交叉熵常用于解决分类问题，而分类问题的概率本质是计算类别变量的广义的伯努利分布，所以机器学习采用的是交叉熵的离散形式</p>
<script type="math/tex; mode=display">
CE = -\sum^K_{i=1} t_i \log s_i</script><p>其中，$t_i$ 是期望的类别标签，$s_i$ 是模型对第 $i$ 个类别计算得到的 $score$ ，通常在计算损失之前，会用激活函数对 $score$ 加以转换，用 $f(s_i)$ 替代上式的 $s_i$</p>
<p>得到机器学习的交叉熵损失函数</p>
<script type="math/tex; mode=display">
J(w) = - \frac{1}{N} \sum^N_{n=1} \sum^K_{i=1} t_i \log s_i</script><p>因为对于分类问题，假设模型的输出层上只有2个输出结点，而且是一个二分类单标签问题，如果输出层用符号 $Y$ 表示，那么 $Y$ 服从 $0-1$ 分布(是二项分布的特例，或称伯努利分布，二元分布)，即随机变量 $Y$ 的样本空间有两个样本点(分别对应输出层的两个输出结点)，每个样本点就是一个类别。我们希望机器学习模型训练出的分布是某个类别的概率为 $1$ ，另一个类别的概率为 $0$ 。推广到多分类单标签问题，那么 $Y$ 服从广义的伯努利分布(是多项式分布的特例，或称 $Category$ 分布，范畴分布，类别分布，$Multinoulli$ 分布(2012年在《Machine Learning - A Probabilistic Perspective》中正式提出))。</p>
<h3 id="最小化交叉熵损失与最大似然推导"><a href="#最小化交叉熵损失与最大似然推导" class="headerlink" title="最小化交叉熵损失与最大似然推导"></a>最小化交叉熵损失与最大似然推导</h3><p>先从一个直观的例子感受最小化交叉熵损失与最大似然的关系</p>
<script type="math/tex; mode=display">
J(w)=-\frac{1}{N} \sum_{n=1}^{N}\left[y_{n} \log \hat{y}_{n}+\left(1-y_{n}\right) \log \left(1-\hat{y}_{n}\right)\right]</script><p>去掉 $\frac{1}{N}$ 并不影响函数的单调性，机器学习任务的也可以是最小化下面的交叉熵损失</p>
<script type="math/tex; mode=display">
J(w)=-\sum_{n=1}^{N}\left[y_{n} \log \hat{y}_{n}+\left(1-y_{n}\right) \log \left(1-\hat{y}_{n}\right)\right]</script><p>等价于最大化</p>
<script type="math/tex; mode=display">
J(w)=\sum_{n=1}^{N}\left[y_{n} \log \hat{y}_{n}+\left(1-y_{n}\right) \log \left(1-\hat{y}_{n}\right)\right]</script><p>这其实就是对伯努利分布求最大似然中的对数似然函数</p>
<h3 id="伯努利分布的最大似然推导"><a href="#伯努利分布的最大似然推导" class="headerlink" title="伯努利分布的最大似然推导"></a>伯努利分布的最大似然推导</h3><p>有二元随机变量 $Y \in\{0,1\}$ ，设 $p(Y=1) = \beta$ ，那么它的概率质量函数(PMF)为</p>
<script type="math/tex; mode=display">
P(Y \mid \beta)=\beta^{Y}(1-\beta)^{1-Y}</script><p>现有 $D=\left\{y_{1}, y_{2}, \ldots, y_{N}\right\} $ 来自 $Y$ ，样本容量为 $N$ 的一个样本，似然函数为</p>
<script type="math/tex; mode=display">
P(D \mid \beta)=\prod_{i=1}^{N} P\left(Y=y_{i} \mid \beta\right)=\prod_{i=1}^{N} \beta^{y_{i}}(1-\beta)^{1-y_{i}}</script><p>在机器学习中，对 $\beta$ 的定义为</p>
<script type="math/tex; mode=display">
\beta = p_{\theta}(Y = 1|x_i)</script><p>其中，$X=\left\{x_{1}, \ldots, x_{N}\right\}$ ，$ x_{i} \in X$，$X$ 是 $D$ 中每个样本点对应类别的特征的集合。即给定模型参数 $\theta$ 和随机变量的样本点 $Y=1$ 的属性特征 $x_i$ ( $x_i$ 可以是一个向量)，让模型估计出事件 $Y=1$ 的概率(同时也是当前伯努利分布的参数)</p>
<p>故上述的似然函数的参数不再是伯努利分布的 $\beta$，而是模型的参数 $\theta$，有</p>
<script type="math/tex; mode=display">
P(D \mid \theta, X)=\prod_{i=1}^{N} p_{\theta}\left(Y=1 \mid x_{i}\right)^{y_{i}}\left(1-p_{\theta}\left(Y=1 \mid x_{i}\right)\right)^{1-y_{i}}</script><p>易得对数似然函数</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathcal{L}(\theta ; X, D) &= \log \prod_{i=1}^{N} p_{\theta}\left(Y=1 \mid x_{i}\right)^{y_{i}}\left(1-p_{\theta}\left(Y=1 \mid x_{i}\right)\right)^{1-y_{i}} \\
&= \sum_{i=1}^{N} \log p_{\theta}\left(Y=1 \mid x_{i}\right)^{y_{i}}\left(1-p_{\theta}\left(Y=1 \mid x_{i}\right)\right)^{1-y_{i}} \\
&= \sum_{i=1}^{N} \log p_{\theta}\left(Y=1 \mid x_{i}\right)^{y_{i}}+\log \left(1-p_{\theta}\left(Y=1 \mid x_{i}\right)\right)^{1-y_{i}} \\
&= \sum_{i=1}^{N} y_{i} \log p_{\theta}\left(Y=1 \mid x_{i}\right)+\left(1-y_{i}\right) \log \left(1-p_{\theta}\left(Y=1 \mid x_{i}\right)\right)
\end{aligned}</script><p>以下给出最大似然估计与最小化交叉熵损失的转化过程，意在说明在伯努利分布下，最大似然估计与最小化交叉熵损失是同概念的</p>
<script type="math/tex; mode=display">
\begin{aligned}
\theta_{p} &= \arg \max _{\theta} \sum_{i=1}^{N} y_{i} \log p_{\theta}\left(Y=1 \mid x_{i}\right)+\left(1-y_{i}\right) \log \left(1-p_{\theta}\left(Y=1 \mid x_{i}\right)\right) \\
&= \arg \max_{\theta} \sum^N_{i=1}y_i \log \hat{y_i} + (1-y_i) \log (1- \hat{y_i}) \\
&= \arg \min_{\theta} - \sum^N_{i=1}y_i \log \hat{y_i} + (1-y_i) \log (1- \hat{y_i}) \\
&= \arg \min_{\theta} \sum^N_{i=1} H(y_i,\hat{y_i})
\end{aligned}</script><h3 id="广义伯努利分布的最大似然推导"><a href="#广义伯努利分布的最大似然推导" class="headerlink" title="广义伯努利分布的最大似然推导"></a>广义伯努利分布的最大似然推导</h3><p>单标签多分类任务的类别随机变量只服从多项式分布中试验次数为1的情况，广义伯努利分布（ $Category$ 分布）对应的是更常见的单标签多分类任务，以下讨论伯努利分布到广义伯努利分布的过渡以及与最大似然估计的关系</p>
<p>有 $K$ 元类别随机变量 $Y \in\{1, \ldots, K\} $ ，且 $p(Y=J)=\beta_{j}$，概率质量函数库为</p>
<script type="math/tex; mode=display">
P(Y|B)=\prod^K_{i=1} \beta ^{I(Y=i)}_i</script><p>如果 $Y=i$，$I(Y=i) = 1$ ，否则， $I(Y=i)=0$ </p>
<blockquote>
<p>这个概率质量函数之所以看上去有点奇怪，是因为它出现了 $Identity$ 函数。而符合我们直觉的是维基百科对广义伯努利分布的另一个PMF定义，即 $p(Y=i)=p_i$ ，即直接根据列联表，获得该事件发生的概率。如果想解释上面晦涩难懂的包含 $Identity$ 函数的PMF，可以用严格按照伯努利试验的描述来解释：在进行1次试验中抽到第 $j$ 个类别，其他概率被抽中0次的概率，即</p>
<script type="math/tex; mode=display">
P(Y=j)=(1,1) \ldots p_{j-1}^{0} p_{j}^{1} p_{j+1}^{0} \ldots</script></blockquote>
<p>$D=\left\{y_{1}, y_{2}, \ldots, y_{N}\right\}$ 是来自 $Y$ 的，样本容量为 $N$，的一个样本，那么似然函数为</p>
<script type="math/tex; mode=display">
P(D \mid \beta)=\prod_{i=1}^{N} \prod_{j=1}^{K} \beta_{j}^{I\left(y_{i}=j\right)}</script><p>同样地，在机器学习模型中，对上述关于对 $\beta$ 的定义做出转变</p>
<script type="math/tex; mode=display">
\beta_{j}=p_{\theta}\left(Y=j \mid x_{i}\right)</script><p>$X=\left\{x_{1}, \cdots, x_{N}\right\}$，$x_i \in X$，$X$ 是 $D$ 中的每个样本点对应特征的集合</p>
<p>同理上述的似然函数的参数不再是广义伯努利分布的 $\beta_1,beta_2,\cdots,\beta_k$，而是模型的参数 $\theta$，所以似然函数有</p>
<script type="math/tex; mode=display">
P(D \mid \theta, X)=\prod_{i=1}^{N} \prod_{j=1}^{K} p_{\theta}\left(y_{i}=j \mid x_{i}\right)^{I\left(y_{i}=j\right)}</script><p>易得对数似然函数</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathcal{L}(\theta ; X, D) &= \log \prod_{i=1}^{N} \prod_{j=1}^{K} p_{\theta}\left(y_{i}=j \mid x_{i}\right)^{I\left(y_{i}=j\right)}\\
&= \sum_{i=1}^{N} \log \prod_{j=1}^{K} p_{\theta}\left(y_{i}=j \mid x_{i}\right)^{I\left(y_{i}=j\right)} \\
&= \sum_{i=1}^{N} \sum_{j=1}^{K} \log p_{\theta}\left(y_{i}=j \mid x_{i}\right)^{I\left(y_{i}=j\right)} \\
&= \sum_{i=1}^{N} \sum_{j=1}^{K} I\left(y_{i}=j\right) \log p_{\theta}\left(y_{i}=j \mid x_{i}\right)
\end{aligned}</script><p>因为最大化上述式子具有约束条件 $\sum^K_{i=1} \beta_i = 1$，所以最大化上面的对数似然函数是一个条件极值问题，使用拉格朗日乘数法进行求解，得到下面的关于求解广义伯努利分布下的交叉熵的拉格朗日函数</p>
<script type="math/tex; mode=display">
\tilde{\mathcal{L}}(\theta ; X, D, \lambda)=\sum_{i=1}^{N} \sum_{j=1}^{K} I\left(y_{i}=j\right) \log p_{\theta}\left(y_{i}=j \mid x_{i}\right)+\lambda\left(1-\sum_{k} \beta_{i}\right)</script><p>在没有使用机器学习模型的前提下，我们只需对分布的参数和 $\lambda$ 求偏导就能得到参数的估计值</p>
<p>用模型的参数记号 $\hat{\beta_j}$ 表示 $p_{\theta} (y_i = j | x_i)$，用 one-hot 向量表示 $Identity$ 函数值</p>
<p>得</p>
<script type="math/tex; mode=display">
\mathcal{L}(\theta ; X, D)=\sum_{i=1}^{N} \sum_{j=1}^{K} y_{j} \log \hat{\beta}_{j}</script><p>下面同样给出极大似然估计与最小化广义伯努利分布的交叉熵损失函数的转化过程，意在说明在广义伯努利分布下，最大似然估计与最小化交叉熵损失也是同概念的</p>
<script type="math/tex; mode=display">
\begin{aligned}
\theta_{p} &= \arg \max _{\theta} \sum_{i=1}^{N} \sum_{j=1}^{K} y_{j} \log \hat{\beta}_{j} \\
&= \arg \min _{\theta}-\sum_{i=1}^{N} \sum_{j=1}^{K} y_{j} \log \hat{\beta}_{j} \\
&= \arg \min _{\theta} \sum_{i=1}^{N} H\left(y_{j}, \hat{\beta}_{j}\right)
\end{aligned}</script><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最小化交叉熵损失函数与最大似然估计之间的等价并非巧合，同是处理信息的公式，只是应用的方向不同</p>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/51099880">https://zhuanlan.zhihu.com/p/51099880</a></p>
</blockquote>
]]></content>
      <categories>
        <category>懵逼的深度学习</category>
      </categories>
      <tags>
        <tag>概率与信息论</tag>
      </tags>
  </entry>
  <entry>
    <title>求解微分方程</title>
    <url>/2021/11/02/%E6%B1%82%E8%A7%A3%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>解微分方程是我的弱项，就靠这个了</p>
<span id="more"></span>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>含导数或微分的方程称之为微分方程，一般形式为$f(x,y’ \cdots y^{(n)})$</p>
<h3 id="阶数"><a href="#阶数" class="headerlink" title="阶数"></a>阶数</h3><p>微分方程所含的导数或微分的最高阶数称为微分方程的阶数</p>
<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><p>解：使得微分方程成立的函数<br>特解：不含任意常数<br>通解：所含的相互独立的任意常数的个数与微分方程的阶数相等</p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><h3 id="可分离变量微分方程"><a href="#可分离变量微分方程" class="headerlink" title="可分离变量微分方程"></a>可分离变量微分方程</h3><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x} = f(x)g(y)</script><p>解</p>
<script type="math/tex; mode=display">\int \frac{\mathrm{d}y}{g(y)} = \int f(x)\mathrm{d}x</script><blockquote>
<p>e.g. </p>
<script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x} = 2xy</script><p>解</p>
<script type="math/tex; mode=display">\int \frac{\mathrm{d}y}{y} = \int 2x\mathrm{d}x</script><script type="math/tex; mode=display">\ln y = x^2+C</script><script type="math/tex; mode=display">\begin{aligned} y {}& = e^{x^2+C} {} \\ & = e^C e^{x^2} {} \\ & = C_1 e^{x^2} {} \\ & \quad(C_1 = e^C) \end{aligned}</script></blockquote>
<h3 id="一阶齐次线性微分方程"><a href="#一阶齐次线性微分方程" class="headerlink" title="一阶齐次线性微分方程"></a>一阶齐次线性微分方程</h3><script type="math/tex; mode=display">y' +P(x)y = 0</script><p>解</p>
<script type="math/tex; mode=display">y = Ce^{-\int{P(x)\mathrm{d}x}}</script><blockquote>
<p>e.g.</p>
<script type="math/tex; mode=display">y'-xy=0</script><p>解</p>
<script type="math/tex; mode=display">y = Ce^{\int x\mathrm{d}x}=Ce^{\frac{x^2}{2}}</script></blockquote>
<h3 id="一阶非齐次线性微分方程"><a href="#一阶非齐次线性微分方程" class="headerlink" title="一阶非齐次线性微分方程"></a>一阶非齐次线性微分方程</h3><script type="math/tex; mode=display">y'+P(x)y = Q(x) \neq 0</script><p>解</p>
<script type="math/tex; mode=display">y = (\int Q(x)e^{\int P(x) \mathrm{d}x}\mathrm{d}x+C)e^{-\int P(x) \mathrm{d}x}</script><blockquote>
<p>e.g.</p>
<script type="math/tex; mode=display">y'+y \tan x = \cos x</script><p>解</p>
<script type="math/tex; mode=display">y = (\int \cos x e^{\int \tan x \mathrm{d}x}\mathrm{d}x+C)e^{-\int\tan x \mathrm{d}x} = (x+C)\cos x</script></blockquote>
<h3 id="贝努利方程"><a href="#贝努利方程" class="headerlink" title="贝努利方程"></a>贝努利方程</h3><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x} + P(x)y = Q(x)y^n \quad (n \neq 0)</script><p>解<br>令$z = y^{1-n}$，代入原方程得$\frac{\mathrm{d}z}{\mathrm{d}x}+(1-n)P(x)z = (1-n)Q(x)$，再求解该一阶非齐次线性方程即可</p>
<blockquote>
<p>e.g.</p>
<script type="math/tex; mode=display">x^2y'+xy = y^2</script><p>解</p>
<script type="math/tex; mode=display">z = y^{1-2} = y^{-1},\quad y' = -\frac{1}{z^2}z'</script><p>代入原式</p>
<script type="math/tex; mode=display">z' - \frac{1}{x}z = -\frac{1}{x^2}</script><script type="math/tex; mode=display">z = (\int (-\frac{1}{x^2})e^{\int -\frac{1}{x}\mathrm{d}x}\mathrm{d}x +C)e^{\int \frac{1}{x}\mathrm{d}x} = (\frac{1}{2x^2}+C)x</script><script type="math/tex; mode=display">\frac{1}{y} = (\frac{1}{2x^2}+C)x</script></blockquote>
<h3 id="可降阶微分方程"><a href="#可降阶微分方程" class="headerlink" title="可降阶微分方程"></a>可降阶微分方程</h3><h4 id="形式一"><a href="#形式一" class="headerlink" title="形式一"></a>形式一</h4><script type="math/tex; mode=display">y^{(n) = f(x)}</script><p>解<br>对方程进行$n$次不定积分</p>
<blockquote>
<p>e.g.</p>
<script type="math/tex; mode=display">y'' = x^2</script><p>解</p>
<script type="math/tex; mode=display">y' = \frac{1}{3} x^3 +C_1</script><script type="math/tex; mode=display">y = \frac{1}{12}x^4+C_1 x + C_2</script></blockquote>
<h4 id="形式二"><a href="#形式二" class="headerlink" title="形式二"></a>形式二</h4><script type="math/tex; mode=display">f(x,y',y'') = 0</script><p>解</p>
<ol>
<li>令$y’ = p$，则$y’’=p’$，原方程变为$f(x,p,p’) = 0$</li>
<li>解出$p = \varphi(x)$</li>
<li>$y = \int \varphi(x)\mathrm{d}x+C$<blockquote>
<p>e.g.</p>
<script type="math/tex; mode=display">y'' + \frac{y'}{x} = 0</script><p>解<br>令$y’ = p$，则$y’’ = p’$，原方程变为$p’ + \frac{p}{x} = 0$</p>
<script type="math/tex; mode=display">p = C_1e^{\int -\frac{1}{x}\mathrm{d}x} = \frac{C_1}{x}</script><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x} = \frac{C_1}{x}</script><script type="math/tex; mode=display">y = C_1 \ln \lvert x \rvert +C_2</script></blockquote>
</li>
</ol>
<h4 id="形式三"><a href="#形式三" class="headerlink" title="形式三"></a>形式三</h4><script type="math/tex; mode=display">f(y,y',y'') = 0</script><p>解</p>
<ol>
<li>令$y’ = p$，则$y’’ = \frac{\mathrm{d}p}{\mathrm{d}x} = \frac{\mathrm{d}p}{\mathrm{d}y} \frac{\mathrm{d}y}{\mathrm{d}x} = p \frac{\mathrm{d}p}{\mathrm{d}y}$，原方程变为$f(y,p,p’) = 0$</li>
<li>解出$p = \varphi(y)$</li>
<li>$\int \frac{\mathrm{d}y}{\varphi(y)} = x+C$<blockquote>
<p>e.g.</p>
<script type="math/tex; mode=display">y y'' = y'^2</script><p>令$y’ = p$，$y’’ = p \frac{\mathrm{d}p}{\mathrm{d}y}$，代入原式</p>
<script type="math/tex; mode=display">yp\frac{\mathrm{d}p}{\mathrm{d}y}-p^2 = 0 \Rightarrow p = C_1 e^{\int \frac{1}{y} \mathrm{d}y = C_1 y }</script><script type="math/tex; mode=display">\frac{\mathrm{d}y}{\mathrm{d}x} = C_1 y \Rightarrow \int \frac{\mathrm{d}y}{y} = \int C_1 \mathrm{d}x</script><script type="math/tex; mode=display">\ln y = C_1x+C_2 \Rightarrow y = e^{C_1 x+C_2} = C_3 e^{C_1 x} \quad (C_3 = e^{C_2})</script></blockquote>
</li>
</ol>
<h3 id="二阶常系数线性微分方程"><a href="#二阶常系数线性微分方程" class="headerlink" title="二阶常系数线性微分方程"></a>二阶常系数线性微分方程</h3><script type="math/tex; mode=display">y'' +py' +qy = 0</script><p>解</p>
<ol>
<li>求解$y’’ +py’ +qy = 0$的特征方程是$r^2+pr+q = 0$</li>
<li>根据方程根的不同分为三种情况<ol>
<li>当特征方程有两个实根$r_1$，$r_2$，且$r_1\neq r_2$，则$y = C_1e^{r1 x}+C_2e^{r_2 x}$</li>
<li>当特征方程有重根$r_1 = r_2$，则$y = (C_1+C_2x)e^{r_1 x}$</li>
<li>当特征方程有两个共轭重根$r_{1,2} = \alpha \pm \beta i$，则$y = e^{\alpha x} (C_1 \cos \beta x + C_2 \sin \beta x)$<blockquote>
<p>e.g.1</p>
<script type="math/tex; mode=display">y'' - y' - 6y = 0</script><p>解</p>
<script type="math/tex; mode=display">r^2-r-6 = (r-3)(r+2) = 0 \Rightarrow r_1 = 3,\quad r_2 = -2</script><script type="math/tex; mode=display">y = C_1 e^{3x} + C_2 e^{-2x}</script><p>e.g.2</p>
<script type="math/tex; mode=display">y''-2y'+y = 0</script><p>解</p>
<script type="math/tex; mode=display">r^2-2r+1 = (r-1)^2 = 0 \Rightarrow r_{1,2} = 1</script><script type="math/tex; mode=display">y = (C_1 + C_2 x)e^x</script><p>e.g.3</p>
<script type="math/tex; mode=display">y'' - 2y' + 2y = 0</script><p>解</p>
<script type="math/tex; mode=display">r^2- 2r +2 = 0 \Rightarrow r_{1,2} = 1 \pm i</script><script type="math/tex; mode=display">y = e^x (C_1 \cos x + C_2 \sin x)</script></blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="二阶常系数非齐次线性微分方程"><a href="#二阶常系数非齐次线性微分方程" class="headerlink" title="二阶常系数非齐次线性微分方程"></a>二阶常系数非齐次线性微分方程</h3><h4 id="形式一-1"><a href="#形式一-1" class="headerlink" title="形式一"></a>形式一</h4><script type="math/tex; mode=display">y'' + py' +qy = P_n(x)e^{kx}</script><p>其中$P_n(x)$代表$x$的$n$阶多项式<br>解<br>根据$k$的值有以下三种情况：</p>
<ol>
<li>若$k$非特征值，即$k \neq r_1 \neq r_2$，则特解 $y^* = e^{kx} \sum_{i=0}^n a_i x^i$</li>
<li>若$k$与一个特征值相同，则特解  $y^* = xe^{kx} \sum_{i=0}^n a_i x^i$</li>
<li>若$k$与两个特征值相同，则特解  $y^* = x^2e^{kx} \sum_{i=0}^n a_i x^i$</li>
</ol>
<h4 id="形式二-1"><a href="#形式二-1" class="headerlink" title="形式二"></a>形式二</h4><script type="math/tex; mode=display">y'' + py' + qy = e^{ax} [P_l \cos bx + P_s \sin bx]</script><p>其中$P_l(x)$，$P_s(x)$代表$x$的$l$，$s$阶多项式<br>解<br>根据$a$，$b$的值有以下三种情况</p>
<ol>
<li>若$a\pm b i$不是特征值，则特解 $y^* = (Q_n^{(1)}(x)\cos bx+Q_n^{(2)}(x)\sin bx)e^{ax}$</li>
<li>若$a\pm b i$是特征值，则特解 $y^* = x(Q_n^{(1)}(x)\cos bx+Q_n^{(2)}(x)\sin bx)e^{ax}$</li>
</ol>
]]></content>
      <categories>
        <category>高等数学</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>正交多项式</title>
    <url>/2021/10/17/%E6%AD%A3%E4%BA%A4%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>总结一下可能会遇到的正交多项式</p>
<span id="more"></span>
<h2 id="正交多项式定义"><a href="#正交多项式定义" class="headerlink" title="正交多项式定义"></a>正交多项式定义</h2><p>一个多项式序列${ {p_n}(x)} _{n = 0}^\infty$，阶数为$[p_n(x)] = n$,对于每一个$n$，这个多项式序列在开区间$(a,b)$上关于权函数$w(x)$正交，如果：</p>
<script type="math/tex; mode=display">\int_a^bw(x)p_m(x)p_n(x)dx = h_n\delta_{mn}</script><blockquote>
<p>$\delta$为狄克拉函数，且$h_n$为常数<br>权函数$w(x)$在区间$(a,b)$是连续且正的,下式存在:</p>
<script type="math/tex; mode=display">\mu_n = \int_a^bw(x)x^ndx,n \in N^+</script></blockquote>
<p>则多项式$f$和多项式$g$的内积定义为：</p>
<script type="math/tex; mode=display">\langle{f,g}\rangle = \int_a^bw(x)f(x)g(x)dx</script><p>区间$(a,b)称为正交区间，正交区间不一定是有限区间$</p>
<h3 id="e-g-三角函数的正交性"><a href="#e-g-三角函数的正交性" class="headerlink" title="e.g 三角函数的正交性"></a>e.g 三角函数的正交性</h3><blockquote>
<p>对于三角函数序列$1,sin(\theta),cos(\theta),sin(2\theta),cos(2\theta),…,cos(n\theta)$，$n \in N^+$，他们在区间$(0,2\pi )$的正交性为：</p>
<script type="math/tex; mode=display">\int_0^{2 \pi }sin(n \theta )cos(m \theta) d\theta = \delta_{mn}</script><p>图中阴影部分的面积加上符号求和为0.<br><img src="/image/正交多项式/1.png" alt="1"></p>
</blockquote>
<h3 id="e-g-施密特正交化"><a href="#e-g-施密特正交化" class="headerlink" title="e.g 施密特正交化"></a>e.g 施密特正交化</h3><blockquote>
<p>施密特正交化方法是将一组线性无关的向量组正交化的方法，对正交化后的向量组进行标准化处理，可进一步得到一组标准正交基。处理步骤如下</p>
<script type="math/tex; mode=display">\begin{array}{l}
 {\beta _1} = {\alpha _1} \\ 
 {\beta _2} = {\alpha _2} - \frac{ {\left\langle { {\alpha _2},{\beta _1} } \right\rangle } }{ {\left\langle { {\beta _1},{\beta _1} } \right\rangle } }{\beta _1} \\ 
  \cdots  \\ 
 {\beta _n} = {\alpha _n} - \frac{ {\left\langle { {\alpha _n},{\beta _1} } \right\rangle } }{ {\left\langle { {\beta _1},{\beta _1} } \right\rangle } }{\beta _1} - \frac{ {\left\langle { {\alpha _n},{\beta _2} } \right\rangle } }{ {\left\langle { {\beta _2},{\beta _2} } \right\rangle } }{\beta _2} -  \cdots  - \frac{ {\left\langle { {\alpha _n},{\beta _{n - 1} } } \right\rangle } }{ {\left\langle { {\beta _{n - 1} },{\beta _{n - 1} } } \right\rangle } }{\beta _{n - 1} } \\ 
 \end{array}</script><p>将三维空间中的一组线性无关向量$a,b,c$用施密特正交化方法处理得到正交向量组 $x,y,z$，步骤如下：</p>
<script type="math/tex; mode=display">\begin{array}{l}
 x = a \\ 
 y = b - \frac{ {\left\langle {b,x} \right\rangle } }{ {\left\langle {x,x} \right\rangle } }x = \frac{ {\left| b \right|\cos (\theta )} }{ {\left| a \right|} }a \\ 
 z = c - \frac{ {\left\langle {c,x} \right\rangle } }{ {\left\langle {x,x} \right\rangle } }x - \frac{ {\left\langle {c,y} \right\rangle } }{ {\left\langle {y,y} \right\rangle } }y \\ 
\end{array}</script><p>几何描述如图：<br><img src="/image/正交多项式/2.png" alt="2"></p>
</blockquote>
<h2 id="经典正交多项式"><a href="#经典正交多项式" class="headerlink" title="经典正交多项式"></a>经典正交多项式</h2><p>如雅克比多项式，切比雪夫多项式，勒让德多项式，拉盖尔多项式，伯恩斯坦多项式，球谐多项式等</p>
<h3 id="雅克比多项式"><a href="#雅克比多项式" class="headerlink" title="雅克比多项式"></a>雅克比多项式</h3><p>雅克比多项式是定义在$(-1,1)$上，关于权函数$(1-x)^{\alpha} (1+x)^{\beta} $正交的多项式，其中$\alpha ,\beta &gt; -1$<br>表达式为：</p>
<script type="math/tex; mode=display">P_n^{ (\alpha,\beta) } (x) = \frac{ \Gamma(\alpha+n+1) }{n!(\alpha+\beta+n+1)} \sum_{m=0}^n \begin{pmatrix} n \\ m \end{pmatrix} \frac{\Gamma(\alpha+\beta+n+m+1)}{\Gamma(\alpha+m+1)}{(\frac{x-1}{2})}^m</script><script type="math/tex; mode=display">\Gamma(\gamma) = \int_0^{+ \infty } t^{\gamma -1} e^{-t} dt</script><p>雅克比多项式的正交性：</p>
<script type="math/tex; mode=display">\begin{array}{l}
\int_{ - 1}^1 { { {(1 - x)}^\alpha }{ {(1 + x)}^\beta }P_m^{(\alpha ,\beta )}(x)P_n^{(\alpha ,\beta )}(x)dx}  \\ 
 = \frac{ { {2^{\alpha  + \beta  + 1} } } }{ {2n + \alpha  + \beta  + 1} }\frac{ {\Gamma (\alpha  + n + 1)\Gamma (\beta  + n + 1)} }{ {n!\Gamma (\alpha  + \beta  + n + 1)} }{\delta _{mn} } \\ 
\end{array}</script><h3 id="勒让德多项式"><a href="#勒让德多项式" class="headerlink" title="勒让德多项式"></a>勒让德多项式</h3><p>勒让德多项式是定义在区间 $(−1,1) $上关于权函数1正交的多项式。勒让德多项式实际上是雅克比多项式在 $\alpha=\beta=0$ 时的特殊情况<br>表达式为：</p>
<script type="math/tex; mode=display">P_n(x) = \frac{1}{2^n n!} \frac{d^n}{dx^n} [ (x^2-1)^n ]</script><p>递推公式为：</p>
<script type="math/tex; mode=display">(n+1)P_{n+1}(x) = (2n+1)xP_n(x)-nP_{n-1}(x)</script><p>正交性：</p>
<script type="math/tex; mode=display">\int_{-1}^1 P_m(x)P_n(x)dx = \frac{2}{2n+1}\delta_{mn}</script><p>前6阶勒让德多项式：</p>
<script type="math/tex; mode=display">P_0(x) = 1</script><script type="math/tex; mode=display">P_1(x) = x</script><script type="math/tex; mode=display">{P_2}(x) = \frac{3}{2}{x^2} - \frac{1}{2}</script><script type="math/tex; mode=display">{P_3}(x) = \frac{5}{2}{x^3} - \frac{3}{2}x</script><script type="math/tex; mode=display">{P_4}(x) = \frac{ {35} }{8}{x^4} - \frac{ {15} }{4}{x^2} + \frac{3}{8}</script><script type="math/tex; mode=display">{P_5}(x) = \frac{ {63} }{8}{x^5} - \frac{ {35} }{4}{x^3} + \frac{ {15} }{8}x</script><script type="math/tex; mode=display">{P_6}(x) = \frac{ {231} }{ {16} }{x^6} - \frac{ {315} }{ {16} }{x^4} + \frac{ {105} }{ {16} }{x^2} - \frac{5}{ {16} }</script><p>图像为：<br><img src="/image/正交多项式/3.png" alt="3"></p>
<h3 id="切比雪夫多项式"><a href="#切比雪夫多项式" class="headerlink" title="切比雪夫多项式"></a>切比雪夫多项式</h3><p>切比雪夫多项式是定义在区间 $(−1,1)$ 上关于权函数 $\frac{1}{\sqrt{1-x^2} }$ 正交的多项式</p>
<h4 id="第一类切比雪夫多项式"><a href="#第一类切比雪夫多项式" class="headerlink" title="第一类切比雪夫多项式"></a>第一类切比雪夫多项式</h4><script type="math/tex; mode=display">T_n(x) = cos(n\theta)</script><p>令$x = cos(\theta)$，则$T_n(x) = cos(n \arccos(x))$，<br>第一类切比雪夫多项式正交性：</p>
<script type="math/tex; mode=display">\int_{-1}^1 \frac{1}{\sqrt{1-x^2} } T_m(x) T_n(x)dx = \begin{cases}0 \quad m \neq n \\ \pi \quad n=m=0 \\ \frac{\pi}{2} \quad n=m \neq 0 \end{cases}</script><p>第一类切比雪夫多项式递推公式：</p>
<script type="math/tex; mode=display">{T_{n + 1} }(x) = 2x{T_n}(x) - {T_{n - 1} }(x)</script><p>第一类切比雪夫多项式的前6项：</p>
<script type="math/tex; mode=display">T_0(x) = 1</script><script type="math/tex; mode=display">T_1(x) = x</script><script type="math/tex; mode=display">T_2(x) = 2x^2-1</script><script type="math/tex; mode=display">T_3(x) = 4x^3-3x</script><script type="math/tex; mode=display">T_4(x) = 8x^4-8x^2+1</script><script type="math/tex; mode=display">T_5(x) = 16x^5-20x^3+5x</script><script type="math/tex; mode=display">T_6(x) = 32x^6-48x^4+18x^2-1</script><p>第一类切比雪夫多项图像：<br><img src="/image/正交多项式/4.svg" alt="4"></p>
<h4 id="第二类切比雪夫多项式"><a href="#第二类切比雪夫多项式" class="headerlink" title="第二类切比雪夫多项式"></a>第二类切比雪夫多项式</h4><script type="math/tex; mode=display">{T_n}(x) = \frac{ {\sin [(n + 1)\theta ]} } { {\sin \theta } }</script><p>第二类切比雪夫多项式的正交为：</p>
<script type="math/tex; mode=display">\int_{-1}^1 \sqrt{1-x^2}{T_m}(x){T_n}(x)dx=\begin{cases}0 \quad m\neq n \\ \frac{\pi}{2} \quad m = n \end{cases}</script><p>第二类切比雪夫多项式的递推公式：</p>
<script type="math/tex; mode=display">{T_{n + 1} }(x) = 2x{T_n}(x) - {T_{n - 1} }(x)</script><p>第二类切比雪夫多项式的前6项：</p>
<script type="math/tex; mode=display">T_0(x) = 1</script><script type="math/tex; mode=display">T_1(x) = 2x</script><script type="math/tex; mode=display">T_2(x) = 4x^2-1</script><script type="math/tex; mode=display">T_3(x) = 8x^3-4x</script><script type="math/tex; mode=display">T_4(x) = 16x^4-12x^2+1</script><script type="math/tex; mode=display">T_5(x) = 32x^5-32x^3+6x</script><script type="math/tex; mode=display">T_6(x) = 64x^6-80x^4+24x^2-1</script><p>第二类切比雪夫多项图像：<br><img src="/image/正交多项式/5.png" alt="5"></p>
<h3 id="拉盖尔多项式"><a href="#拉盖尔多项式" class="headerlink" title="拉盖尔多项式"></a>拉盖尔多项式</h3><p>拉盖尔多项式是定义在区间 $(0,+\infty)$ 上关于权函数 $e^{-x}x^a$ 正交的多项式<br>拉盖尔多项式的正交关系：</p>
<script type="math/tex; mode=display">\int_0^{ + \infty } { {x^\alpha }{e^{ - x} }L_m^{(\alpha )}(x)L_n^{(\alpha )}(x)dx}  = \frac{ {\left( {n + \alpha } \right)!} }{ {n!} }{\delta _{mn} }</script><p>拉盖尔多项式的递推关系：</p>
<script type="math/tex; mode=display">{L_{n + 1} }(x) = \frac{ {(2n + 1 - x){L_n}(x) - n{L_{n - 1} }(x)} }{ {n + 1} }</script><p>前6项拉盖尔多项式$(\alpha = 0)$：</p>
<script type="math/tex; mode=display">L_0(x) = 1</script><script type="math/tex; mode=display">L_1(x) = -x+1</script><script type="math/tex; mode=display">L_2(x) = \frac{1}{2}x^2-2x+1</script><script type="math/tex; mode=display">L_3(x) = -\frac{1}{6}x^3+\frac{3}{2}x^2-3x+1</script><script type="math/tex; mode=display">L_4(x) = \frac{1}{24}x^4-\frac{2}{3}x^3+3x^2-4x+1</script><script type="math/tex; mode=display">L_5(x) = -\frac{1}{120}x^5+\frac{5}{24}x^4-\frac{5}{3}x^3+5x^2-5x+1</script><script type="math/tex; mode=display">L_6(x) = \frac{1}{720}x^6-\frac{1}{20}x^5+\frac{5}{8}x^4-\frac{10}{3}x^3+\frac{15}{2}x^2-6x+1</script><p>前6项拉盖尔多项式的图像：<br><img src="/image/正交多项式/6.png" alt="6"></p>
<h3 id="埃尔米特多项式"><a href="#埃尔米特多项式" class="headerlink" title="埃尔米特多项式"></a>埃尔米特多项式</h3><p>埃尔米特多项式是定义在区间$(-\infty,+\infty)$上关于权函数$e^{x^2}$正交的多项式<br>埃尔米特多项式分为概率论中的埃尔米特多项式和物理中的埃尔米特多项式，概率论的埃尔米特多项式是首一多项式（最高次项系数等于1），而物理学的埃尔米特多项式的最高次项系数等于$2n$，这里只介绍物理学中使用的埃尔米特多项式<br>埃尔米特多项式的表达式为：</p>
<script type="math/tex; mode=display">H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n}e^{-x^2}</script><p>埃尔米特多项式的正交性：</p>
<script type="math/tex; mode=display">\int_{-\infty}^{+\infty} H_m(x)H_n(x)e^{-x^2}dx = \sqrt{\pi}2^n n! \delta_{mn}</script><p>埃尔米特多项式的递推公式：</p>
<script type="math/tex; mode=display">H_{n+1}(x) = 2xH_n(x)-2nH_{n-1}(x)</script><p>前6项埃尔米特多项式为：</p>
<script type="math/tex; mode=display">H_0(x) = 1</script><script type="math/tex; mode=display">H_1(x) = 2x</script><script type="math/tex; mode=display">H_2(x) = 4x^2-2</script><script type="math/tex; mode=display">H_3(x) = $8x^3-12x</script><script type="math/tex; mode=display">H_4(x) = 16x^4-48x^2+12</script><script type="math/tex; mode=display">H_5(x) = 32x^5-160x^3+120x</script><script type="math/tex; mode=display">H_6(x) = 64x^6-480x^4+720x^2-120</script><p>前6项埃尔米特多项式图像：<br><img src="/image/正交多项式/7.png" alt="7"></p>
<h3 id="正交多项式的应用"><a href="#正交多项式的应用" class="headerlink" title="正交多项式的应用"></a>正交多项式的应用</h3><p>仅以一个小的例子来说明正交多项式在函数拟合中的应用<br>实验中使用的测试函数为 $y=4x+3x^2+cos(x)+sin(2x)+e^x$，定义区间为 $(−2,2)$ ，实验比较了多项式展开3项时不同多项式的拟合均方误差（MSE），归一化<a href="https://aeeeeeep.github.io/2021/10/20/%E5%9D%87%E6%96%B9%E8%AF%AF%E5%B7%AE/">均方误差</a>（NMSE）。<br><img src="/image/正交多项式/8.svg" alt="8"></p>
<p><details class="custom-block details" style="display: block; position: relative; border-radius: 2px; margin: 1.6em 0px; padding: 1.6em; background-color: rgb(238, 238, 238); color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="outline: none; cursor: pointer;">输出</summary><pre><code class="matlab">
MSE_power =
    0.0131
NMSE_power =
    0.0419
MSE_legendre =
    0.0131
NMSE_legendre =
    0.0419
MSE_chebyshev =
    0.0131
NMSE_chebyshev =
    0.0419
MSE_laguerre =
    0.0131
NMSE_laguerre =
    0.0419
MSE_hermite =
    0.0067
NMSE_hermite =
    0.0215
</code></pre></details><br>可以看出埃尔米特的拟合误差较小，其他相当<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 正交多项式测试</span></span><br><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">% 采样点数</span></span><br><span class="line">N = <span class="number">1000</span> ; </span><br><span class="line"><span class="comment">% 正交多项式阶数</span></span><br><span class="line">M = <span class="number">3</span> ;   </span><br><span class="line"><span class="comment">% 拟合函数区间为（-2,2）</span></span><br><span class="line">x = <span class="built_in">linspace</span>(<span class="number">-2</span>,<span class="number">2</span>,N)&#x27; ; </span><br><span class="line"><span class="comment">% 生成被拟合的函数，包括指数函数，余弦函数，幂函数成分</span></span><br><span class="line">y =  <span class="number">4</span>*x + <span class="number">3</span>*x.^<span class="number">2</span> + <span class="built_in">cos</span>(x) + <span class="built_in">exp</span>(x) + <span class="built_in">sin</span>(<span class="number">2</span>*x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">% 生成幂级数组成的基矩阵</span></span><br><span class="line">P1 = power_p(x,M) ;</span><br><span class="line"><span class="comment">% 生成勒让德多项式组成的基矩阵</span></span><br><span class="line">P2 = legendre_p(N,M) ;</span><br><span class="line"><span class="comment">% 生成切比雪夫多项式组成的基矩阵</span></span><br><span class="line">P3 = chebyshev_p(N,M) ;</span><br><span class="line"><span class="comment">% 生成拉盖尔多项式组成的基矩阵</span></span><br><span class="line">P4 = laguerre_p(N,M) ;</span><br><span class="line"><span class="comment">% 生成诶尔米特多项式组成的基矩阵</span></span><br><span class="line">P5 = hermite_p(N,M) ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 用最小二乘拟合y</span></span><br><span class="line"><span class="comment">% c1对应幂级数系数</span></span><br><span class="line">c1 = P1\y ;</span><br><span class="line"><span class="comment">% c2对应勒让德系数</span></span><br><span class="line">c2 = P2\y ;</span><br><span class="line"><span class="comment">% c3对应切比雪夫系数</span></span><br><span class="line">c3 = P3\y ;</span><br><span class="line"><span class="comment">% c4对应拉盖尔系数</span></span><br><span class="line">c4 = P4\y ;</span><br><span class="line"><span class="comment">% c5对应埃尔米特系数</span></span><br><span class="line">c5 = P5\y ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 求MSE和NMSE</span></span><br><span class="line">MSE_power = norm(y-P1*c1)/N </span><br><span class="line">NMSE_power = norm(y-P1*c1)/norm(y) </span><br><span class="line"> </span><br><span class="line">MSE_legendre = norm(y-P2*c2)/N </span><br><span class="line">NMSE_legendre = norm(y-P2*c2)/norm(y) </span><br><span class="line"> </span><br><span class="line">MSE_chebyshev = norm(y-P3*c3)/N </span><br><span class="line">NMSE_chebyshev = norm(y-P3*c3)/norm(y) </span><br><span class="line"> </span><br><span class="line">MSE_laguerre = norm(y-P4*c4)/N </span><br><span class="line">NMSE_laguerre = norm(y-P4*c4)/norm(y) </span><br><span class="line"> </span><br><span class="line">MSE_hermite = norm(y-P5*c5)/N </span><br><span class="line">NMSE_hermite = norm(y-P5*c5)/norm(y) </span><br><span class="line"> </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;r-&#x27;</span>,x,P1*c1,<span class="string">&#x27;b-&#x27;</span>,x,P2*c2,<span class="string">&#x27;k-&#x27;</span>,x,P3*c3,<span class="string">&#x27;y-&#x27;</span>,x,P4*c4,<span class="string">&#x27;g-&#x27;</span>,x,P5*c5,<span class="string">&#x27;m-&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;original&#x27;</span>,<span class="string">&#x27;power&#x27;</span>,<span class="string">&#x27;legendre&#x27;</span>,<span class="string">&#x27;chebyshev&#x27;</span>,<span class="string">&#x27;laguerre&#x27;</span>,<span class="string">&#x27;hermite&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[P]</span> = <span class="title">power_p</span><span class="params">(x,M)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> m = <span class="number">1</span>:M</span><br><span class="line">    P(:,m) = x.^(m<span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[P]</span> = <span class="title">legendre_p</span><span class="params">(N,NN)</span></span></span><br><span class="line"><span class="comment">% 本函数生成N*M的勒让德基矩阵</span></span><br><span class="line">s = <span class="built_in">linspace</span>(<span class="number">-1</span>,<span class="number">1</span>,N)&#x27; ;</span><br><span class="line">P = <span class="built_in">zeros</span>(N,NN) ;</span><br><span class="line">P(:,<span class="number">1</span>) = <span class="built_in">ones</span>(N,<span class="number">1</span>) ;</span><br><span class="line">P(:,<span class="number">2</span>) = s ;</span><br><span class="line"><span class="keyword">for</span> n = <span class="number">3</span> : NN</span><br><span class="line">    P(:,n) = ((<span class="number">2</span> * n - <span class="number">3</span>) * s .* P(:,n - <span class="number">1</span>) - (n - <span class="number">2</span>) * P(:,n - <span class="number">2</span>)) / ( n <span class="number">-1</span> ) ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[P]</span> = <span class="title">chebyshev_p</span><span class="params">(N,M)</span></span></span><br><span class="line"><span class="comment">% 本函数生成N*M的切比雪夫基矩阵</span></span><br><span class="line">x = <span class="built_in">linspace</span>(<span class="number">-1</span>,<span class="number">1</span>,N)&#x27; ;</span><br><span class="line">P = <span class="built_in">zeros</span>(N,M) ;</span><br><span class="line">P(:,<span class="number">1</span>) = <span class="built_in">ones</span>(N,<span class="number">1</span>) ;</span><br><span class="line">P(:,<span class="number">2</span>) = x ;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">3</span>:M</span><br><span class="line">    P(:,k) = <span class="number">2</span>*x.*P(:,k<span class="number">-1</span>) - P(:,k<span class="number">-2</span>) ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[P]</span> = <span class="title">laguerre_p</span><span class="params">(N,M)</span></span></span><br><span class="line"><span class="comment">% 本函数生成N*M的拉盖尔基矩阵</span></span><br><span class="line">x  = <span class="built_in">linspace</span>(<span class="number">-2</span>,<span class="number">2</span>,N)&#x27; ;</span><br><span class="line">P = <span class="built_in">zeros</span>(N,M) ;</span><br><span class="line">P(:,<span class="number">1</span>) = <span class="built_in">ones</span>(N,<span class="number">1</span>) ;</span><br><span class="line">P(:,<span class="number">2</span>) = -x + <span class="built_in">ones</span>(N,<span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> m = <span class="number">3</span>:M</span><br><span class="line">    P(:,m) = ((<span class="number">2</span>*(m<span class="number">-2</span>)+<span class="number">1</span>-x).*P(:,m<span class="number">-1</span>)-(m<span class="number">-2</span>)*P(:,m<span class="number">-2</span>))./(m<span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[P]</span> = <span class="title">hermite_p</span><span class="params">(N,M)</span> </span></span><br><span class="line"><span class="comment">% 本函数生成N*M的埃尔米特基矩阵</span></span><br><span class="line">x = <span class="built_in">linspace</span>(<span class="number">-2</span>,<span class="number">2</span>,N)&#x27; ;</span><br><span class="line">P = <span class="built_in">zeros</span>(N,M) ;</span><br><span class="line">P(:,<span class="number">1</span>) = <span class="built_in">ones</span>(N,<span class="number">1</span>) ;</span><br><span class="line">P(:,<span class="number">2</span>) = <span class="number">2</span>*x ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> m = <span class="number">2</span>:M</span><br><span class="line">    P(:,m+<span class="number">1</span>) = <span class="number">2</span>*x.*P(:,m-) - <span class="number">2</span>*(m<span class="number">-1</span>)*P(:,m<span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>转载自：<a href="https://www.cnblogs.com/louisanu/p/13285394.html">https://www.cnblogs.com/louisanu/p/13285394.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数值分析</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>第二届网刃杯misc所见非所见wp</title>
    <url>/2022/04/25/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AFmisc%E6%89%80%E8%A7%81%E9%9D%9E%E6%89%80%E8%A7%81wp/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>记录一下这道深度学习入门的wp</p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>隐藏层的输出为512，输出层的输出10，导入模型得到报错，神经网络的输入必须为<code>(28,28)</code>，再用 <code>tf.latest_checkpoint</code> 和 <code>tf.load_weights</code> 导入模型文件，最后输出概率最大的预测结果组成 <code>flag</code> ，由于预测图片在压缩中有精度误差，和真实结果不同，所幸赛方给出了 <code>hint4</code>，修改第4位为 2。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models,layers</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">model</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        model = models.Sequential()</span><br><span class="line">        model.add(layers.Flatten(input_shape = (<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))</span><br><span class="line">        model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">        model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        model.summary()</span><br><span class="line">        self.model = model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Predict</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        latest = tf.train.latest_checkpoint(<span class="string">&#x27;./weights&#x27;</span>)</span><br><span class="line">        self.cnn = model()</span><br><span class="line">        self.cnn.model.load_weights(latest)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, image_path</span>):</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(image_path).convert(<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        img = img.resize((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">        img = np.reshape(img, (<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)) / <span class="number">255.</span></span><br><span class="line">        x = np.array([img])</span><br><span class="line">        y = np.argmax(self.cnn.model.predict(x))</span><br><span class="line">        <span class="built_in">print</span>(image_path)</span><br><span class="line">        <span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = Predict()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">14</span>):</span><br><span class="line">        p.predict(<span class="string">&#x27;./flag/&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(i))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>记录第n次修复引导区</title>
    <url>/2021/11/07/%E8%AE%B0%E5%BD%95%E7%AC%ACn%E6%AC%A1%E4%BF%AE%E5%A4%8D%E5%BC%95%E5%AF%BC%E5%8C%BA/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>给U盘装了archlinux后，没注意把固态上archlinux的/etc/fstab分区挂载配置文件修改了，以为是grub又坏了，干脆把挂载在/boot下的EFI 系统格式化了，孙子云：“置之死地而后生。” 从头开始</p>
<span id="more"></span>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>插网线，喝热水</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li><p>U盘启动进去后挂载根分区和启动分区，arch-chroot到根分区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsblk</span><br><span class="line">mkfs.vfat -F32 /dev/$&#123;/boot&#125;	# $&#123;/boot&#125; 启动分区</span><br><span class="line">mount /dev/$&#123;/&#125; /mnt	# $&#123;/&#125; 根分区</span><br><span class="line">mount /dev/$&#123;/boot&#125; /mnt/boot	</span><br><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上操作只能在启动盘进行，如果用完整的archlinux系统，则没有arch-chroot以及pacstrap命令<br>如果使用chroot代替arch-chroot命令后，执行pacman会报非本用户错误</p>
</blockquote>
</li>
<li><p>重新生成引导区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<p>查看有没有Linux的入口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<p>如果没有入口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /boot</span><br></pre></td></tr></table></figure>
<p>查看是否有下列文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initramfs-linux.img</span><br><span class="line">intel-ucode.img</span><br><span class="line">vmlinuz-linux</span><br></pre></td></tr></table></figure>
<p>如果没有，重装linux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S linux</span><br></pre></td></tr></table></figure>
<p>如果报错<br><code>GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name org.cinnamon.SettingsDaemon was not provided by any .service files</code><br>因为pacman检测到非原来用户执行，则可以执行下面命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkinitcpio -p linux</span><br></pre></td></tr></table></figure>
<p>重新加载内核模块，生成文件<br>再执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line">ls /boot</span><br></pre></td></tr></table></figure>
<p>可以看到有了三个文件<br>退出/mnt根分区，回到启动盘</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">initramfs-linux.img</span><br><span class="line">intel-ucode.img</span><br><span class="line">vmlinuz-linux</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li>
<li>重新生成分区挂载配置文件<br>先删除原来的分区挂载配置文件，不然无法挂载分区，系统无法启动，再生成fstab文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /mnt/etc/fstab</span><br><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure>
查看生成的硬盘UUID和分区命名，一致即可<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /dev/disk/by-uuid</span><br><span class="line">cat /mnt/etc/fstab</span><br><span class="line">exit</span><br><span class="line">poweroff</span><br></pre></td></tr></table></figure></li>
<li>设置UEFI<br>本人电脑为DELL</li>
</ol>
<ul>
<li>进入BIOS</li>
<li>选择Boot Sequence</li>
<li>Add Boot Option</li>
<li>File Name 为 /boot/EFI/grub下的grubx64.efi</li>
<li>Boot Option Name 非空</li>
<li>Apply，Exit<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><blockquote>
<p>修grub的周期大概是3个月一次，各种坏掉的原因都有，记录下方便下次解决。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>archlinux</category>
      </categories>
      <tags>
        <tag>grub</tag>
      </tags>
  </entry>
  <entry>
    <title>设计实现内存的分配和回收算法</title>
    <url>/2022/04/13/%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>操作系统作业</p>
<span id="more"></span>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如下数据结构下，设计实现内存的分配和回收算法：</p>
<ul>
<li>归还区有下邻空闲区；</li>
<li>归还区有上邻空闲区；</li>
<li>归还区既有上邻空闲区又有下邻空闲区；</li>
<li>归还区既无上邻空闲区又无下邻空闲区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123; float address;  /*已分分区起始地址*/</span><br><span class="line"> float length;  	/*已分分区长度，单位为字节*/</span><br><span class="line"> int flag;   	/*已分配区表登记栏标志，用“0”表示空栏目，实验中只支持一个字符的作业名*/</span><br><span class="line">&#125;used_table[n]; 	/*已分配区表*/</span><br><span class="line">struct</span><br><span class="line">&#123;float address;	/*空闲区起始地址*/</span><br><span class="line"> float length;    /*空闲区长度，单位为字节*/</span><br><span class="line"> int flag;  	/*空闲区表登记栏标志，用“0”表示空栏目，用“1”表示未分配*/</span><br><span class="line">&#125;free_table[m]; 	/*空闲区表*/</span><br></pre></td></tr></table></figure>
<p>编写程序，并输出结果。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区表数组结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UsedTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;  <span class="comment">/*已分分区起始地址*/</span></span><br><span class="line">    <span class="keyword">int</span> length;  	<span class="comment">/*已分分区长度，单位为字节*/</span></span><br><span class="line">    <span class="keyword">int</span> flag;   	<span class="comment">/*已分配区表登记栏标志，用“0”表示空栏目，实验中只支持一个编号的作业名*/</span></span><br><span class="line">&#125; usedTable[<span class="number">100</span>]; 	<span class="comment">/*已分配区表*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FreeTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;	<span class="comment">/*空闲区起始地址*/</span></span><br><span class="line">    <span class="keyword">int</span> length;    <span class="comment">/*空闲区长度，单位为字节*/</span></span><br><span class="line">    <span class="keyword">int</span> flag;  	<span class="comment">/*空闲区表登记栏标志，用“0”表示空栏目，用“1”表示未分配*/</span></span><br><span class="line">&#125; freeTable[<span class="number">100</span>]; 	<span class="comment">/*空闲区表*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTable</span><span class="params">()</span></span>;                                                   <span class="comment">// 初始化区表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocTable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> proName, <span class="keyword">const</span> <span class="keyword">int</span> proLenth)</span></span>;             <span class="comment">// 创建作业</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reclaimTable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> proName)</span></span>;                               <span class="comment">// 回收作业</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findProName</span><span class="params">(<span class="keyword">const</span> struct UsedTable temp[], <span class="keyword">const</span> <span class="keyword">int</span> proName)</span></span>;  <span class="comment">// 按作业名查找下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortUsedTable</span><span class="params">(struct UsedTable temp[])</span></span>;                        <span class="comment">// 排序已分配区表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsedTable</span><span class="params">(<span class="keyword">const</span> struct UsedTable temp)</span></span>;                   <span class="comment">// 输出作业分区信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFreeTable</span><span class="params">(<span class="keyword">const</span> struct FreeTable temp)</span></span>;                   <span class="comment">// 输出空闲分区信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;                    <span class="comment">//记录当前 已分配/空闲 区表数量</span></span><br><span class="line"><span class="keyword">int</span> Minsize=<span class="number">1</span>;              <span class="comment">//作业间最小空余地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//OS</span></span><br><span class="line">    usedTable[<span class="number">0</span>].address = <span class="number">0</span>;</span><br><span class="line">    usedTable[<span class="number">0</span>].length = <span class="number">3</span>;</span><br><span class="line">    usedTable[<span class="number">0</span>].flag = <span class="number">1</span>; <span class="comment">//OS 的作业名为1</span></span><br><span class="line">    </span><br><span class="line">    freeTable[<span class="number">0</span>].address = <span class="number">3</span>;</span><br><span class="line">    freeTable[<span class="number">0</span>].length = <span class="number">97</span>;</span><br><span class="line">    freeTable[<span class="number">0</span>].flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图形界面</span></span><br><span class="line">    freeTable[<span class="number">0</span>].address = <span class="number">8</span>;</span><br><span class="line">    freeTable[<span class="number">0</span>].length = <span class="number">92</span>;</span><br><span class="line">    freeTable[<span class="number">0</span>].flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    usedTable[<span class="number">1</span>].address = <span class="number">3</span>;</span><br><span class="line">    usedTable[<span class="number">1</span>].length = <span class="number">5</span>;</span><br><span class="line">    usedTable[<span class="number">1</span>].flag = <span class="number">2</span>; <span class="comment">//图形界面 的作业名为2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//网络程序</span></span><br><span class="line">    freeTable[<span class="number">0</span>].address = <span class="number">8</span>;</span><br><span class="line">    freeTable[<span class="number">0</span>].length = <span class="number">12</span>;</span><br><span class="line">    freeTable[<span class="number">0</span>].flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    usedTable[<span class="number">2</span>].address = <span class="number">20</span>;</span><br><span class="line">    usedTable[<span class="number">2</span>].length = <span class="number">10</span>;</span><br><span class="line">    usedTable[<span class="number">2</span>].flag = <span class="number">3</span>; <span class="comment">//网络程序 的作业名为3</span></span><br><span class="line"></span><br><span class="line">    freeTable[<span class="number">1</span>].address = <span class="number">30</span>;</span><br><span class="line">    freeTable[<span class="number">1</span>].length = <span class="number">70</span>;</span><br><span class="line">    freeTable[<span class="number">1</span>].flag = <span class="number">1</span>;</span><br><span class="line">    i += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocTable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> proName, <span class="keyword">const</span> <span class="keyword">int</span> proLenth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(freeTable[j].flag) &#123;</span><br><span class="line">        <span class="keyword">if</span>(freeTable[j].length &gt;= proLenth) <span class="keyword">break</span>;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(freeTable[j].flag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;31mNo free space available\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(freeTable[j].length - proLenth &lt;= Minsize) &#123;</span><br><span class="line">        usedTable[i].address = freeTable[j].address;</span><br><span class="line">        usedTable[i].length  = freeTable[j].length;</span><br><span class="line">        usedTable[i].flag    = proName;</span><br><span class="line">        <span class="keyword">while</span>(freeTable[j].flag) &#123;</span><br><span class="line">            freeTable[j] = freeTable[j+<span class="number">1</span>];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        freeTable[j].address = freeTable[j].length = freeTable[j].flag = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        usedTable[i].address = freeTable[j].address;</span><br><span class="line">        usedTable[i].length  = proLenth;</span><br><span class="line">        usedTable[i].flag    = proName;</span><br><span class="line">        freeTable[j].address = freeTable[j].address + proLenth;</span><br><span class="line">        freeTable[j].length  = freeTable[j].length  - proLenth;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findProName</span><span class="params">(<span class="keyword">const</span> struct UsedTable temp[], <span class="keyword">const</span> <span class="keyword">int</span> proName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; m&lt;i; m++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[m].flag == proName)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reclaimTable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> proName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proName==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;31mCannot reclaim OS progress!\n\033[0m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,j=<span class="number">0</span>,h=<span class="number">0</span>;</span><br><span class="line">    sortUsedTable(usedTable);</span><br><span class="line">    <span class="keyword">if</span>(findProName(usedTable, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;31mERROR!\033[0m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = findProName(usedTable, proName);</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;31mCannot find this progress!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(freeTable[j].flag || usedTable[h].flag) &#123;</span><br><span class="line">            <span class="keyword">if</span>(freeTable[j].address + freeTable[j].length == usedTable[k].address) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(freeTable[j+<span class="number">1</span>].flag &amp;&amp; usedTable[k].address + usedTable[k].length == freeTable[j+<span class="number">1</span>].address) &#123;</span><br><span class="line">                    freeTable[j].length += (usedTable[k].length + freeTable[j+<span class="number">1</span>].length);</span><br><span class="line">                    usedTable[k].address = usedTable[k].flag = usedTable[k].length = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l=j+<span class="number">1</span>; freeTable[l].flag; l++) &#123;</span><br><span class="line">                        freeTable[l] = freeTable[l+<span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="comment">//上有，下有</span></span><br><span class="line">                    i--;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freeTable[j].length += usedTable[k].length;</span><br><span class="line">                    usedTable[k].address = usedTable[k].length = usedTable[k].flag = <span class="number">0</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="comment">//上有，下无</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (usedTable[k].address + usedTable[k].length == freeTable[j].address) &#123;</span><br><span class="line">                freeTable[j].address = usedTable[k].address;</span><br><span class="line">                freeTable[j].length += usedTable[k].length;</span><br><span class="line">                usedTable[k].address = usedTable[k].flag = usedTable[k].length = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//上无，下有</span></span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (usedTable[k<span class="number">-1</span>].address + usedTable[k<span class="number">-1</span>].length + usedTable[k].length == usedTable[k+<span class="number">1</span>].address) &#123;</span><br><span class="line">                <span class="keyword">int</span> e=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(freeTable[e].flag) &#123;</span><br><span class="line">                    e++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m=e; j&lt;m; m--) &#123;</span><br><span class="line">                    freeTable[m].address = freeTable[m<span class="number">-1</span>].address;</span><br><span class="line">                    freeTable[m].length  = freeTable[m<span class="number">-1</span>].length;</span><br><span class="line">                    freeTable[m].flag    = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                freeTable[j].address = usedTable[k].address;</span><br><span class="line">                freeTable[j].length  = usedTable[k].length;</span><br><span class="line">                usedTable[k].address = usedTable[k].length = usedTable[k].flag = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//上无，下无</span></span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="comment">//elif</span></span><br><span class="line">            j++, h++;</span><br><span class="line">        &#125; <span class="comment">//while</span></span><br><span class="line">    &#125; <span class="comment">//else</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortUsedTable</span><span class="params">(struct UsedTable temp[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, f;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UsedTable</span> <span class="title">t</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;i; l++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[l].flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = l; m&lt;=i; m++) temp[m] = temp[m+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        f=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;i<span class="number">-1</span>-j; k++)</span><br><span class="line">            <span class="keyword">if</span>(temp[k+<span class="number">1</span>].address &lt; temp[k].address) &#123;</span><br><span class="line">                f=<span class="number">0</span>;</span><br><span class="line">                t         = temp[k];</span><br><span class="line">                temp[k]   = temp[k+<span class="number">1</span>];</span><br><span class="line">                temp[k+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(f) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsedTable</span><span class="params">(<span class="keyword">const</span> struct UsedTable temp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t%d\t%d\t%d\tNormal\n&quot;</span>, temp.flag, temp.address, temp.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFreeTable</span><span class="params">(<span class="keyword">const</span> struct FreeTable temp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[0;36m\tNULL\t%d\t%d\tNULL\n\033[0m&quot;</span>, temp.address, temp.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>, proName=<span class="number">0</span>, proLenth=<span class="number">0</span>;</span><br><span class="line">    InitTable();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;32m*Select operation:\n\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t(0) - exit\n\t(1) - allocate memory\n\t(2) - reclaim memory\n\t(3) - print table\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;32minput operation: \033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Bye~\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[0;32mthe name of the progress: \033[0m&quot;</span>);</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;proName);</span><br><span class="line">                    <span class="keyword">if</span>(proName == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;31munvalidated proName!\033[0m\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(findProName(usedTable, proName) != <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;31mthis proName has been used!\033[0m\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[0;32mrequired memory size: \033[0m&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;proLenth);</span><br><span class="line">                allocTable(proName, proLenth);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[0;32mthe name of the progress to reclaim: \033[0m&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;proName);</span><br><span class="line">                reclaimTable(proName);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[0;32mmemory table:\033[0m\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[0;34m\tproName\taddress\tlength\tstatus\033[0m\n&quot;</span>);</span><br><span class="line">                sortUsedTable(usedTable);</span><br><span class="line">                <span class="keyword">while</span>(usedTable[m].flag || freeTable[j].flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(usedTable[m].address &lt; freeTable[j].address &amp;&amp; usedTable[m].flag) &#123;</span><br><span class="line">                        printUsedTable(usedTable[m]);</span><br><span class="line">                        m++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freeTable[j].flag) &#123;</span><br><span class="line">                        printFreeTable(freeTable[j]);</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------\n&quot;</span>);</span><br><span class="line">                <span class="comment">//getchar();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;\033[0;31mNo such this operation\n\033[0m&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯函数与高斯核函数</title>
    <url>/2022/08/07/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0%E4%B8%8E%E9%AB%98%E6%96%AF%E6%A0%B8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>图像处理领域中，高斯核函数常用于图像低通滤波，记录下原理，同时用代码实现下。</p>
<span id="more"></span>
<h2 id="高斯函数"><a href="#高斯函数" class="headerlink" title="高斯函数"></a>高斯函数</h2><h3 id="一维高斯函数"><a href="#一维高斯函数" class="headerlink" title="一维高斯函数"></a>一维高斯函数</h3><script type="math/tex; mode=display">
f(x) = ae^{\frac{-(x-b)^2}{2c^2}}</script><p>$a, b, c$ 为实数常数， 且 $a&gt;0$</p>
<p>$a$ 为曲线尖峰高度，$b$ 为尖峰的中心位置， $c$ 为钟的宽度</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Normal_distribution_pdf.png/1200px-Normal_distribution_pdf.png" style="zoom: 40%;" /></p>
<p>由高斯积分公式，得</p>
<script type="math/tex; mode=display">
\int_{-\infty}^{\infty}e^{-x^2}dx = \sqrt{\pi}</script><p>令 $y=x-b$, 得 $dx = dy$</p>
<script type="math/tex; mode=display">
a \int_{-\infty}^{\infty}e^{-\frac{y^2}{2c^2}}dx</script><p>令 $z= \frac{y}{\sqrt{2}c}$, 得 $dy = \sqrt{2}cdz$</p>
<script type="math/tex; mode=display">
\begin{aligned}
  & a\int_{-\infty}^{\infty}e^{-z^2}\sqrt{2}cdz \\
= & \sqrt{2}ac \int_{-\infty}^{\infty}e^{-z^2}dz \\
= & \sqrt{2\pi}\cdot ac
\end{aligned}</script><p>得</p>
<script type="math/tex; mode=display">
\int_{-\infty}^{\infty}ae^{\frac{-(x-b)^2}{2c^2}}dx = \sqrt{2\pi}\cdot ac</script><p>令 $f(x)=1$，使宽度范围内所有概率为$ 1$，得</p>
<script type="math/tex; mode=display">
a = \frac{1}{\sqrt{2\pi}\cdot c}</script><p>令期望 $\mu$ 为 $b$，标准差 $\sigma$ 为 $c$，得满足正态分布的高斯函数</p>
<script type="math/tex; mode=display">
g(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{1}{2}(\frac{x-\mu}{\sigma})^{2}}</script><h3 id="二维高斯函数（高斯分布、正态分布）"><a href="#二维高斯函数（高斯分布、正态分布）" class="headerlink" title="二维高斯函数（高斯分布、正态分布）"></a>二维高斯函数（高斯分布、正态分布）</h3><script type="math/tex; mode=display">
G(x,y) = \frac{1}{2\pi\sigma^2}e^{-(x^2+y^2)/2\sigma^2}</script><p>$\mu=0$，即原点为中心点</p>
<p>在实际编程应用中，高斯函数中的参数如下</p>
<ul>
<li>ksize 核大小</li>
<li>sigma 方差</li>
<li>center 尖峰中心点坐标</li>
<li>bias 尖峰中心点的偏移量，用于控制截断高斯函数</li>
</ul>
<p>以下程序递增高斯函数的方差，并将结果图保存为 gif 图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line">item = <span class="number">10</span></span><br><span class="line">dt = <span class="number">1</span></span><br><span class="line">ksize = <span class="number">20</span></span><br><span class="line">sigma = <span class="number">2</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.ion()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(item)):</span><br><span class="line">    center = <span class="built_in">round</span>(ksize/<span class="number">2</span>)</span><br><span class="line">    bias = ksize *<span class="number">10</span>/<span class="number">10</span></span><br><span class="line">    ksigma = np.multiply(cv2.getGaussianKernel(ksize, sigma),</span><br><span class="line">            (cv2.getGaussianKernel(ksize,sigma)).T)</span><br><span class="line">    [m, n] = ksigma.shape</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(m)):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(n)):</span><br><span class="line">            <span class="keyword">if</span>((x&lt;center-bias) <span class="keyword">or</span> (x&gt;center+bias) <span class="keyword">or</span> (y&lt;center-bias) <span class="keyword">or</span></span><br><span class="line">                    (y&gt;center+bias)):</span><br><span class="line">                ksigma[x, y] = <span class="number">0</span></span><br><span class="line">    sigma = sigma + dt</span><br><span class="line"></span><br><span class="line">    ax3 = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">    ax3.set_zlim3d(<span class="number">0</span>,<span class="number">8e-3</span>)</span><br><span class="line">    x = <span class="built_in">list</span>(<span class="built_in">range</span>(ksize))</span><br><span class="line">    y = x</span><br><span class="line">    ax3.plot_surface(x,y,ksigma,cmap=<span class="string">&#x27;rainbow&#x27;</span>)</span><br><span class="line">    plt.draw()</span><br><span class="line">    plt.pause(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p>图片如下</p>
<p><img src="/image/高斯函数与高斯核函数/gaussian_curve.gif" style="zoom: 80%;" /></p>
<p>随着方差的增大，整个高斯函数的尖峰逐渐减小，整体也变的更加平缓，则对图像的平滑效果越来越明显</p>
<p>保持参数不变，对上述高斯函数进行截断，bias 的大小为 ksize *3/10，则结果如下</p>
<p><img src="/image/高斯函数与高斯核函数/gaussian_curve2.gif" style="zoom: 80%;" /></p>
<p>bias 的作用主要是对超过一定区域的原始图像信息不再考虑，这就保证在更加合理的利用靠近高斯函数中心点的周围像素，同时还可以改变高斯函数的中心坐标</p>
<h2 id="高斯核函数卷积"><a href="#高斯核函数卷积" class="headerlink" title="高斯核函数卷积"></a>高斯核函数卷积</h2><p>径向基函数（Radial Basis Function）， 就是某种沿径向对称的标量函数。 通常定义为空间中任一点 $x_1$ 到某一中心 $x_2$ 之间欧氏距离的单调函数，其作用往往是局部的 , 即当 $x_1$ 远离 $x_2$ 时函数取值很小</p>
<p>最常用的一个核函数为高斯核函数，形式为</p>
<script type="math/tex; mode=display">
k(\|x_1-x_2\|)=e^{-\|x_1-x_2\|^2/2\sigma^2}</script><p>也称为<strong>径向基函数</strong></p>
<p>高斯核函数的代码实现如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_kernel</span>(<span class="params">x1, x2, l=<span class="number">1.0</span>, sigma_f=<span class="number">1.0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Easy to understand but inefficient.&quot;&quot;&quot;</span></span><br><span class="line">    m, n = x1.shape[<span class="number">0</span>], x2.shape[<span class="number">0</span>]</span><br><span class="line">    dist_matrix = np.zeros((m, n), dtype=<span class="built_in">float</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dist_matrix[i][j] = np.<span class="built_in">sum</span>((x1[i] - x2[j]) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> sigma_f ** <span class="number">2</span> * np.exp(- <span class="number">0.5</span> / l ** <span class="number">2</span> * dist_matrix)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_kernel_vectorization</span>(<span class="params">x1, x2, l=<span class="number">1.0</span>, sigma_f=<span class="number">1.0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;More efficient approach.&quot;&quot;&quot;</span></span><br><span class="line">    dist_matrix = np.<span class="built_in">sum</span>(x1**<span class="number">2</span>, <span class="number">1</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>) + np.<span class="built_in">sum</span>(x2**<span class="number">2</span>, <span class="number">1</span>) - <span class="number">2</span> * np.dot(x1, x2.T)</span><br><span class="line">    <span class="keyword">return</span> sigma_f ** <span class="number">2</span> * np.exp(-<span class="number">0.5</span> / l ** <span class="number">2</span> * dist_matrix)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">700</span>, <span class="number">800</span>, <span class="number">1029</span>]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(gaussian_kernel_vectorization(x, x, l=<span class="number">500</span>, sigma=<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">100.</span>          <span class="number">98.01986733</span>  <span class="number">80.5347031</span> ]</span><br><span class="line"> [ <span class="number">98.01986733</span> <span class="number">100.</span>          <span class="number">90.04307671</span>]</span><br><span class="line"> [ <span class="number">80.5347031</span>   <span class="number">90.04307671</span> <span class="number">100.</span>        ]]</span><br></pre></td></tr></table></figure>
<h2 id="高斯函数性质"><a href="#高斯函数性质" class="headerlink" title="高斯函数性质"></a>高斯函数性质</h2><p>高斯函数具有五个重要的性质，这些性质使得它在早期图像处理中特别有用。这些性质表明，高斯平滑滤波器无论在空间域还是在频率域都是十分有效的低通滤波器，且在实际图像处理中得到了有效使用。高斯函数具有五个十分重要的性质</p>
<ol>
<li><p>二维高斯函数具有旋转对称性，即滤波器在各个方向上的平滑程度是相同的。一般来说，一幅图像的边缘方向是事先不知道的，因此，在滤波前是无法确定一个方向上比另一方向上需要更多的平滑。旋转对称性意味着高斯平滑滤波器在后续边缘检测中不会偏向任一方向。</p>
</li>
<li><p>高斯函数是单值函数。这表明，高斯滤波器用像素邻域的加权均值来代替该点的像素值，而每一邻域像素点权值是随该点与中心点的距离单调增减的。边缘是一种图像局部特征，如果平滑运算对离算子中心很远的像素点仍然有很大作用，则平滑运算会使图像失真。</p>
</li>
<li><p>高斯函数的傅立叶变换频谱是单瓣的。正如下面所示，这一性质是高斯函数傅立叶变换等于高斯函数本身这一事实的直接推论。图像常被不希望的高频信号所污染（噪声和细纹理）。而所希望的图像特征（如边缘），既含有低频分量，又含有高频分量。高斯函数傅立叶变换的单瓣意味着平滑图像不会被不需要的高频信号所污染，同时保留了大部分所需信号。</p>
</li>
<li><p>高斯滤波器宽度(决定着平滑程度)是由参数 $\sigma$ 表征的，而且 $\sigma$ 和平滑程度的关系是非常简单的。 $\sigma$ 越大，高斯滤波器的频带就越宽，平滑程度就越好。通过调节平滑程度参数 $\sigma$ ，可在图像特征过分模糊(过平滑)与平滑图像中由于噪声和细纹理所引起的过多的不希望突变量（欠平滑）之间取得折衷。</p>
</li>
<li><p>由于高斯函数的可分离性，大高斯滤波器可以得以有效地实现。二维高斯函数卷积可以分两步来进行，首先将图像与一维高斯函数进行卷积，然后将卷积结果与方向垂直的相同一维高斯函数卷积。因此，二维高斯滤波的计算量随滤波模板宽度成线性增长而不是成平方增长。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0</a></li>
<li><a href="https://blog.csdn.net/jorg_zhao/article/details/52687448">https://blog.csdn.net/jorg_zhao/article/details/52687448</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/75589452">https://zhuanlan.zhihu.com/p/75589452</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/40060966">https://zhuanlan.zhihu.com/p/40060966</a></li>
<li><a href="https://www.cnblogs.com/pacino12134/p/11372555.html">https://www.cnblogs.com/pacino12134/p/11372555.html</a></li>
</ul>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>空间滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA编程性能分析工具 nvprof/ncu --metrics参数含义</title>
    <url>/2023/01/07/CUDA%E7%BC%96%E7%A8%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-metrics%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在网上没有比较全的中文 ncu —metrics 参数含义，于是自己整理了一下官方和外国友人的笔记。</p>
<span id="more"></span>
<h2 id="nvprof-和-ncu"><a href="#nvprof-和-ncu" class="headerlink" title="nvprof 和 ncu"></a>nvprof 和 ncu</h2><p>nvprof 是过去比较常用的命令行工具，但在终端直接输入<code>nvprof ./*.o</code>会得到以下 Warning</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">======== Warning: nvprof is not supported on devices with compute capability 8.0 and higher.</span><br><span class="line">                  Use NVIDIA Nsight Systems for GPU tracing and CPU sampling and NVIDIA Nsight Compute for GPU profiling.</span><br><span class="line">                  Refer https://developer.nvidia.com/tools-overview for more details.</span><br></pre></td></tr></table></figure>
<p>目前主流的 CUDA 驱动不再支持<code>nvprof</code>命令，但我们仍可以在 NVIDIA Nsight Systems 中使用，在终端输入 <code>nsys nvprof ./*.o</code>就可以看到CUDA 程序执行的具体内容。</p>
<p>另外，<code>nvprof --metrics</code> 命令的功能被转换到了 <code>ncu --metrics</code> 命令中，下面就对 <code>nvprof/ncu --metrics</code>命令的参数作详细解释，nsys 和 ncu 工具都有可视化版本，这里只讨论命令行版本。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul>
<li><code>inst_per_warp</code>: 每个 warp 执行的平均指令数</li>
<li><code>branch_efficiency</code>: 非发散分支与总分支的比率</li>
<li><code>warp_execution_efficiency</code>: 每个 warp 的平均活动线程数与 SM 支持的每个 warp 的最大线程数之比</li>
<li><code>warp_nonpred_execution_efficiency</code>: 执行非谓词指令的每个 warp 的平均活动线程数与 SM 支持的每个 warp 的最大线程数之比</li>
<li><code>inst_replay_overhead</code>: 每条指令执行的平均重放次数</li>
<li><code>shared_load_transactions_per_request</code>: 每次共享内存加载时执行的平均共享内存加载事务数</li>
<li><code>shared_store_transactions_per_request</code>: 每次共享内存加载时执行的平均共享内存写入事务数</li>
<li><code>local_load_transactions_per_request</code>: 每次本地内存加载执行的本地内存加载事务平均数</li>
<li><code>local_store_transactions_per_request</code>: 为每个本地内存存储执行的本地内存存储交易的平均数量</li>
<li><code>gld_transactions_per_request</code>: 为每个全局内存加载执行的全局内存加载事务的平均数。</li>
<li><code>gst_transactions_per_request</code>: 为每个全局内存存储执行的平均全局内存存储事务数</li>
<li><code>shared_store_transactions</code>: 共享内存存储事务数</li>
<li><code>shared_load_transactions</code>: 共享内存加载事务数</li>
<li><code>local_load_transactions</code>: 本地内存加载事务数</li>
<li><code>local_store_transactions</code>: 本地内存存储事务数</li>
<li><code>gld_transactions</code>: 全局内存加载事务数</li>
<li><code>gst_transactions</code>: 全局内存存储事务数</li>
<li><code>sysmem_read_transactions</code>: 系统内存读取事务数</li>
<li><code>sysmem_write_transactions</code>: 系统内存写入事务数</li>
<li><code>l2_read_transactions</code>: 所有读取请求在 L2 缓存中接收到的内存读取事务</li>
<li><code>l2_write_transactions</code>: 所有写入请求在 L2 缓存中接收到的内存写入事务</li>
<li><code>dram_read_transactions</code>: 设备内存读取事务</li>
<li><code>dram_write_transactions</code>: 设备内存写入事务</li>
<li><code>global_hit_rate</code>: 统一 L1/tex 缓存中全局加载的命中率</li>
<li><code>local_hit_rate</code>: 本地加载和存储的命中率</li>
<li><code>gld_requested_throughput</code>: 请求的全局内存负载吞吐量</li>
<li><code>gst_requested_throughput</code>: 请求的全局内存存储吞吐量</li>
<li><code>gld_throughput</code>: 全局内存负载吞吐量</li>
<li><code>gst_throughput</code>: 全局内存存储吞吐量</li>
<li><code>local_memory_overhead</code>: 本地内存流量占 L1 和 L2 缓存之间总内存流量之比</li>
<li><code>tex_cache_hit_rate</code>: 统一缓存命中率</li>
<li><code>l2_tex_read_hit_rate</code>: 来自纹理缓存的所有读取请求在 L2 缓存中的命中率</li>
<li><code>l2_tex_write_hit_rate</code>: 来自纹理缓存的所有写入请求在 L2 缓存中的命中率</li>
<li><code>dram_read_throughput</code>: 设备内存读取吞吐量</li>
<li><code>dram_write_throughput</code>: 设备内存写入吞吐量</li>
<li><code>tex_cache_throughput</code>: 统一缓存吞吐量</li>
<li><code>l2_tex_read_throughput</code>: 在 L2 缓存中接收到的来自纹理缓存的内存读取吞吐量</li>
<li><code>l2_tex_write_throughput</code>: 在 L2 缓存中接收到的来自纹理缓存的内存写入吞吐量</li>
<li><code>l2_read_throughput</code>: 在 L2 缓存中接收到的所有内存读取吞吐量</li>
<li><code>l2_write_throughput</code>: 在 L2 缓存中接收到的所有内存写入吞吐量</li>
<li><code>sysmem_read_throughput</code>: 系统内存读取吞吐量</li>
<li><code>sysmem_write_throughput</code>: 系统内存写入吞吐量</li>
<li><code>local_load_throughput</code>: 本地内存加载吞吐量</li>
<li><code>local_store_throughput</code>: 本地内存存储吞吐量</li>
<li><code>shared_load_throughput</code>: 共享内存负载吞吐量</li>
<li><code>shared_store_throughput</code>: 共享内存存储吞吐量</li>
<li><code>gld_efficiency</code>: 请求的全局内存负载吞吐量与所需的全局内存负载吞吐量的比率</li>
<li><code>gst_efficiency</code>: 请求的全局内存存储吞吐量与所需的全局内存存储吞吐量的比率</li>
<li><code>tex_cache_transactions</code>: 统一缓存读取事务</li>
<li><code>flop_count_dp</code>: 非谓词线程执行的双精度浮点运算数（加法、乘法和乘法累加）。每个乘法累加运算对计数贡献 2。</li>
<li><code>flop_count_dp_add</code>: 非断言线程执行的双精度浮点加法运算次数</li>
<li><code>flop_count_dp_fma</code>: 非谓词线程执行的双精度浮点乘累加运算次数，每个乘法累加运算使计数加一</li>
<li><code>flop_count_dp_mul</code>: 非谓词线程执行的双精度浮点乘法运算次数</li>
<li><code>flop_count_sp</code>: 非谓词线程执行的单精度浮点运算数（加法、乘法和乘法累加），每个乘法累加运算使计数加二（不包括特殊操作）</li>
<li><code>flop_count_sp_add</code>: 非断言线程执行的单精度浮点加法运算次数</li>
<li><code>flop_count_sp_fma</code>: 非谓词线程执行的单精度浮点乘累加运算次数。每个乘法累加运算使计数加一</li>
<li><code>flop_count_sp_mul</code>: 非谓词线程执行的单精度浮点乘法运算次数</li>
<li><code>flop_count_sp_special</code>: 非谓词线程执行的单精度浮点特殊操作数</li>
<li><code>inst_executed</code>: 执行的指令数</li>
<li><code>inst_issued</code>: 发出的指令数</li>
<li><p><code>dram_utilization</code>: 设备内存利用率相对于理论峰值利用率的级别，范围为 0 到 10</p>
</li>
<li><p><code>sysmem_utilization</code>: 系统内存利用率相对于理论峰值利用率的级别</p>
</li>
<li><code>stall_inst_fetch</code>: 由于尚未获取下一条汇编指令而发生的停顿百分比</li>
<li><code>stall_exec_dependency</code>: 由于指令所需的输入尚不可用而发生的停顿百分比</li>
<li><code>stall_memory_dependency</code>: 由于所需资源不可用或未完全利用而无法执行内存操作，或者由于给定类型的太多请求未完成而导致的停顿百分比</li>
<li><code>stall_texture</code>: 由于纹理子系统被充分利用或有太多未完成的请求而发生的停顿百分比</li>
<li><code>stall_sync</code>: 由于 warp 在 __syncthreads() 调用时被阻塞而发生的停顿百分比</li>
<li><code>stall_other</code>: 由于各种原因发生的停顿百分比</li>
<li><code>stall_constant_memory_dependency</code>: 由于立即常量高速缓存未命中而发生的停顿百分比</li>
<li><code>stall_pipe_busy</code>: 由于计算管道繁忙而无法执行计算操作而发生的停顿百分比</li>
<li><code>shared_efficiency</code>: 请求的共享内存吞吐量与所需共享内存吞吐量的比率</li>
<li><code>inst_fp_32</code>: 非谓词线程（算术、比较等）执行的单精度浮点指令数</li>
<li><code>inst_fp_64</code>: 非谓词线程（算术、比较等）执行的双精度浮点指令数</li>
<li><code>inst_integer</code>: 非谓词线程执行的整数指令数</li>
<li><code>inst_bit_convert</code>: 非谓词线程执行的位转换指令数</li>
<li><code>inst_control</code>: 非谓词线程（跳转、分支等）执行的控制流指令数</li>
<li><code>inst_compute_ld_st</code>: 非谓词线程执行的计算加载/存储指令数</li>
<li><code>inst_misc</code>: 非谓词线程执行的杂项指令数</li>
<li><code>inst_inter_thread_communication</code>: 非谓词线程执行的线程间通信指令数</li>
<li><code>issue_slots</code>: 使用的问题槽数</li>
<li><code>cf_issued</code>: 发出的控制流指令数</li>
<li><code>cf_executed</code>: 执行的控制流指令数</li>
<li><code>ldst_issued</code>: 发出的本地、全局、共享和纹理内存加载和存储指令的数量</li>
<li><code>ldst_executed</code>: 执行的本地、全局、共享和纹理内存加载和存储指令的数量</li>
<li><code>atomic_transactions</code>: 全局内存原子和减少事务</li>
<li><code>atomic_transactions_per_request</code>: 为每个原子和归约指令执行的全局内存原子和归约事务的平均数量</li>
<li><code>l2_atomic_throughput</code>: 在 L2 缓存中接收到的原子和减少请求的内存读取吞吐量</li>
<li><code>l2_atomic_transactions</code>: 在 L2 缓存中接收到的内存读取事务，用于原子请求和缩减请求</li>
<li><code>l2_tex_read_transactions</code>: 在 L2 缓存中接收到的内存读取事务，用于来自纹理缓存的读取请求</li>
<li><code>stall_memory_throttle</code>: 由于内存节流而发生的停顿百分比</li>
<li><code>stall_not_selected</code>: 由于未选择 warp 而发生的停顿百分比</li>
<li><code>l2_tex_write_transactions</code>: 在 L2 缓存中接收到的内存写入事务，用于来自纹理缓存的写入请求</li>
<li><code>flop_count_hp</code>: 非谓词线程执行的半精度浮点运算数（加法、乘法和乘法累加），每个乘法累加运算使计数加二</li>
<li><code>flop_count_hp_add</code>: 非断言线程执行的半精度浮点加法运算的次数</li>
<li><code>flop_count_hp_mul</code>: 非谓词线程执行的半精度浮点乘法运算次数</li>
<li><code>flop_count_hp_fma</code>: 非谓词线程执行的半精度浮点乘累加运算次数。每个乘法累加运算使计数加一</li>
<li><code>inst_fp_16</code>: 非谓词线程（算术、比较等）执行的半精度浮点指令数</li>
<li><code>ipc</code>: 每个周期执行的指令</li>
<li><code>issued_ipc</code>: 每个周期发出的指令</li>
<li><code>issue_slot_utilization</code>: 发出至少一条指令的发布槽的百分比，在所有周期中取平均值</li>
<li><code>sm_efficiency</code>: 至少一个 warp 在特定 SM 上处于活动状态的时间百分比</li>
<li><code>achieved_occupancy</code>: 每个活动周期的平均活动 warp 与 SM 支持的最大 warp 数之比</li>
<li><code>eligible_warps_per_cycle</code>: 每个活动周期有资格发布的平均 warp 数</li>
<li><code>shared_utilization</code>: 共享内存相对于理论峰值利用率的利用率级别</li>
<li><p><code>l2_utilization</code>: L2 缓存利用率相对于理论峰值利用率的级别，范围为 0 到 10</p>
</li>
<li><p><code>tex_utilization</code>: 统一缓存利用率相对于理论峰值利用率的级别</p>
</li>
<li><code>ldst_fu_utilization</code>: 执行共享加载、共享存储和恒定加载指令的 SM 的利用率级别</li>
<li><p><code>cf_fu_utilization</code>: 执行控制流指令的 SM 的利用率级别，范围为 0 到 10</p>
</li>
<li><p><code>tex_fu_utilization</code>: 执行全局、局部和纹理内存指令的 SM 的利用率级别，范围为 0 到 10</p>
</li>
<li><p><code>special_fu_utilization</code>: 执行 sin、cos、ex2、popc、flo 和类似指令的 SM 的利用率级别，范围为 0 到 10</p>
</li>
<li><p><code>half_precision_fu_utilization</code>: 执行 16 位浮点指令和整数指令的 SM 的利用率级别，范围为 0到10</p>
</li>
<li><p><code>single_precision_fu_utilization</code>: 执行单精度浮点指令和整数指令的 SM 的利用率级别</p>
</li>
<li><code>double_precision_fu_utilization</code>: 执行双精度浮点指令的 SM 的利用率级别</li>
<li><code>flop_hp_efficiency</code>: 实现的半精度浮点运算与理论峰值的比值</li>
<li><code>flop_sp_efficiency</code>: 实现的单精度浮点运算与理论峰值的比值</li>
<li><code>flop_dp_efficiency</code>: 实现的双精度浮点运算与理论峰值的比值</li>
<li><p><code>sysmem_read_utilization</code>: 系统内存的读取利用率相对于理论峰值利用率的级别，范围为 0 到 10</p>
</li>
<li><p><code>sysmem_write_utilization</code>: 系统内存的写入利用率相对于理论峰值利用率的级别，范围为 0 到 10</p>
</li>
</ul>
<h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><div class="table-container">
<table>
<thead>
<tr>
<th>nvprof —metrics</th>
<th>ncu —metrics (&gt;= SM 7.0)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>achieved_occupancy</code></td>
<td><code>sm__warps_active.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>atomic_transactions</code></td>
<td><code>l1tex__t_set_accesses_pipe_lsu_mem_global_op_atom.sum + l1tex__t_set_accesses_pipe_lsu_mem_global_op_red.sum</code></td>
</tr>
<tr>
<td><code>atomic_transactions_per_request</code></td>
<td><code>(l1tex__t_sectors_pipe_lsu_mem_global_op_atom.sum + l1tex__t_sectors_pipe_lsu_mem_global_op_red.sum) / (l1tex__t_requests_pipe_lsu_mem_global_op_atom.sum + l1tex__t_requests_pipe_lsu_mem_global_op_red.sum)</code></td>
</tr>
<tr>
<td><code>branch_efficiency</code></td>
<td><code>smsp__sass_average_branch_targets_threads_uniform.pct</code></td>
</tr>
<tr>
<td><code>cf_executed</code></td>
<td><code>smsp__inst_executed_pipe_cbu.sum + smsp__inst_executed_pipe_adu.sum</code></td>
</tr>
<tr>
<td><code>cf_fu_utilization</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>cf_issued</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>double_precision_fu_utilization</code></td>
<td><code>smsp__inst_executed_pipe_fp64.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>dram_read_bytes</code></td>
<td><code>dram__bytes_read.sum</code></td>
</tr>
<tr>
<td><code>dram_read_throughput</code></td>
<td><code>dram__bytes_read.sum.per_second</code></td>
</tr>
<tr>
<td><code>dram_read_transactions</code></td>
<td><code>dram__sectors_read.sum</code></td>
</tr>
<tr>
<td><code>dram_utilization</code></td>
<td><code>dram__throughput.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>dram_write_bytes</code></td>
<td><code>dram__bytes_write.sum</code></td>
</tr>
<tr>
<td><code>dram_write_throughput</code></td>
<td><code>dram__bytes_write.sum.per_second</code></td>
</tr>
<tr>
<td><code>dram_write_transactions</code></td>
<td><code>dram__sectors_write.sum</code></td>
</tr>
<tr>
<td><code>eligible_warps_per_cycle</code></td>
<td><code>smsp__warps_eligible.sum.per_cycle_active</code></td>
</tr>
<tr>
<td><code>flop_count_dp</code></td>
<td><code>smsp__sass_thread_inst_executed_op_dadd_pred_on.sum + smsp__sass_thread_inst_executed_op_dmul_pred_on.sum + smsp__sass_thread_inst_executed_op_dfma_pred_on.sum * 2</code></td>
</tr>
<tr>
<td><code>flop_count_dp_add</code></td>
<td><code>smsp__sass_thread_inst_executed_op_dadd_pred_on.sum</code></td>
</tr>
<tr>
<td><code>flop_count_dp_fma</code></td>
<td><code>smsp__sass_thread_inst_executed_op_dfma_pred_on.sum</code></td>
</tr>
<tr>
<td><code>flop_count_dp_mul</code></td>
<td><code>smsp__sass_thread_inst_executed_op_dmul_pred_on.sum</code></td>
</tr>
<tr>
<td><code>flop_count_hp</code></td>
<td><code>smsp__sass_thread_inst_executed_op_hadd_pred_on.sum + smsp__sass_thread_inst_executed_op_hmul_pred_on.sum + smsp__sass_thread_inst_executed_op_hfma_pred_on.sum * 2</code></td>
</tr>
<tr>
<td><code>flop_count_hp_add</code></td>
<td><code>smsp__sass_thread_inst_executed_op_hadd_pred_on.sum</code></td>
</tr>
<tr>
<td><code>flop_count_hp_fma</code></td>
<td><code>smsp__sass_thread_inst_executed_op_hfma_pred_on.sum</code></td>
</tr>
<tr>
<td><code>flop_count_hp_mul</code></td>
<td><code>smsp__sass_thread_inst_executed_op_hmul_pred_on.sum</code></td>
</tr>
<tr>
<td><code>flop_count_sp</code></td>
<td><code>smsp__sass_thread_inst_executed_op_fadd_pred_on.sum + smsp__sass_thread_inst_executed_op_fmul_pred_on.sum + smsp__sass_thread_inst_executed_op_ffma_pred_on.sum * 2</code></td>
</tr>
<tr>
<td><code>flop_count_sp_add</code></td>
<td><code>smsp__sass_thread_inst_executed_op_fadd_pred_on.sum</code></td>
</tr>
<tr>
<td><code>flop_count_sp_fma</code></td>
<td><code>smsp__sass_thread_inst_executed_op_ffma_pred_on.sum</code></td>
</tr>
<tr>
<td><code>flop_count_sp_mul</code></td>
<td><code>smsp__sass_thread_inst_executed_op_fmul_pred_on.sum</code></td>
</tr>
<tr>
<td><code>flop_count_sp_special</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>flop_dp_efficiency</code></td>
<td><code>smsp__sass_thread_inst_executed_ops_dadd_dmul_dfma_pred_on.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>flop_hp_efficiency</code></td>
<td><code>smsp__sass_thread_inst_executed_ops_hadd_hmul_hfma_pred_on.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>flop_sp_efficiency</code></td>
<td><code>smsp__sass_thread_inst_executed_ops_fadd_fmul_ffma_pred_on.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>gld_efficiency</code></td>
<td><code>smsp__sass_average_data_bytes_per_sector_mem_global_op_ld.pct</code></td>
</tr>
<tr>
<td><code>gld_requested_throughput</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>gld_throughput</code></td>
<td><code>l1tex__t_bytes_pipe_lsu_mem_global_op_ld.sum.per_second</code></td>
</tr>
<tr>
<td><code>gld_transactions</code></td>
<td><code>l1tex__t_sectors_pipe_lsu_mem_global_op_ld.sum</code></td>
</tr>
<tr>
<td><code>gld_transactions_per_request</code></td>
<td><code>l1tex__average_t_sectors_per_request_pipe_lsu_mem_global_op_ld.ratio</code></td>
</tr>
<tr>
<td><code>global_atomic_requests</code></td>
<td><code>l1tex__t_requests_pipe_lsu_mem_global_op_atom.sum</code></td>
</tr>
<tr>
<td><code>global_hit_rate</code></td>
<td><code>(l1tex__t_sectors_pipe_lsu_mem_global_op_ld_lookup_hit.sum + l1tex__t_sectors_pipe_lsu_mem_global_op_st_lookup_hit.sum + l1tex__t_sectors_pipe_lsu_mem_global_op_red_lookup_hit.sum + l1tex__t_sectors_pipe_lsu_mem_global_op_atom_lookup_hit.sum) / (l1tex__t_sectors_pipe_lsu_mem_global_op_ld.sum + l1tex__t_sectors_pipe_lsu_mem_global_op_st.sum + l1tex__t_sectors_pipe_lsu_mem_global_op_red.sum + l1tex__t_sectors_pipe_lsu_mem_global_op_atom.sum)</code></td>
</tr>
<tr>
<td><code>global_load_requests</code></td>
<td><code>l1tex__t_requests_pipe_lsu_mem_global_op_ld.sum</code></td>
</tr>
<tr>
<td><code>global_reduction_requests</code></td>
<td><code>l1tex__t_requests_pipe_lsu_mem_global_op_red.sum</code></td>
</tr>
<tr>
<td><code>global_store_requests</code></td>
<td><code>l1tex__t_requests_pipe_lsu_mem_global_op_st.sum</code></td>
</tr>
<tr>
<td><code>gst_efficiency</code></td>
<td><code>smsp__sass_average_data_bytes_per_sector_mem_global_op_st.pct</code></td>
</tr>
<tr>
<td><code>gst_requested_throughput</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>gst_throughput</code></td>
<td><code>l1tex__t_bytes_pipe_lsu_mem_global_op_st.sum.per_second</code></td>
</tr>
<tr>
<td><code>gst_transactions</code></td>
<td><code>l1tex__t_sectors_pipe_lsu_mem_global_op_st.sum</code></td>
</tr>
<tr>
<td><code>gst_transactions_per_request</code></td>
<td><code>l1tex__average_t_sectors_per_request_pipe_lsu_mem_global_op_st.ratio</code></td>
</tr>
<tr>
<td><code>half_precision_fu_utilization</code></td>
<td><code>smsp__inst_executed_pipe_fp16.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>inst_bit_convert</code></td>
<td><code>smsp__sass_thread_inst_executed_op_conversion_pred_on.sum</code></td>
</tr>
<tr>
<td><code>inst_compute_ld_st</code></td>
<td><code>smsp__sass_thread_inst_executed_op_memory_pred_on.sum</code></td>
</tr>
<tr>
<td><code>inst_control</code></td>
<td><code>smsp__sass_thread_inst_executed_op_control_pred_on.sum</code></td>
</tr>
<tr>
<td><code>inst_executed</code></td>
<td><code>smsp__inst_executed.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_global_atomics</code></td>
<td><code>smsp__sass_inst_executed_op_global_atom.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_global_loads</code></td>
<td><code>smsp__inst_executed_op_global_ld.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_global_reductions</code></td>
<td><code>smsp__inst_executed_op_global_red.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_global_stores</code></td>
<td><code>smsp__inst_executed_op_global_st.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_local_loads</code></td>
<td><code>smsp__inst_executed_op_local_ld.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_local_stores</code></td>
<td><code>smsp__inst_executed_op_local_st.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_shared_atomics</code></td>
<td><code>smsp__inst_executed_op_shared_atom.sum + smsp__inst_executed_op_shared_atom_dot_alu.sum + smsp__inst_executed_op_shared_atom_dot_cas.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_shared_loads</code></td>
<td><code>smsp__inst_executed_op_shared_ld.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_shared_stores</code></td>
<td><code>smsp__inst_executed_op_shared_st.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_surface_atomics</code></td>
<td><code>smsp__inst_executed_op_surface_atom.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_surface_loads</code></td>
<td><code>smsp__inst_executed_op_surface_ld.sum + smsp__inst_executed_op_shared_atom_dot_alu.sum + smsp__inst_executed_op_shared_atom_dot_cas.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_surface_reductions</code></td>
<td><code>smsp__inst_executed_op_surface_red.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_surface_stores</code></td>
<td><code>smsp__inst_executed_op_surface_st.sum</code></td>
</tr>
<tr>
<td><code>inst_executed_tex_ops</code></td>
<td><code>smsp__inst_executed_op_texture.sum</code></td>
</tr>
<tr>
<td><code>inst_fp_16</code></td>
<td><code>smsp__sass_thread_inst_executed_op_fp16_pred_on.sum</code></td>
</tr>
<tr>
<td><code>inst_fp_32</code></td>
<td><code>smsp__sass_thread_inst_executed_op_fp32_pred_on.sum</code></td>
</tr>
<tr>
<td><code>inst_fp_64</code></td>
<td><code>smsp__sass_thread_inst_executed_op_fp64_pred_on.sum</code></td>
</tr>
<tr>
<td><code>inst_integer</code></td>
<td><code>smsp__sass_thread_inst_executed_op_integer_pred_on.sum</code></td>
</tr>
<tr>
<td><code>inst_inter_thread_communication</code></td>
<td><code>smsp__sass_thread_inst_executed_op_inter_thread_communication_pred_on.sum</code></td>
</tr>
<tr>
<td><code>inst_issued</code></td>
<td><code>smsp__inst_issued.sum</code></td>
</tr>
<tr>
<td><code>inst_misc</code></td>
<td><code>smsp__sass_thread_inst_executed_op_misc_pred_on.sum</code></td>
</tr>
<tr>
<td><code>inst_per_warp</code></td>
<td><code>smsp__average_inst_executed_per_warp.ratio</code></td>
</tr>
<tr>
<td><code>inst_replay_overhead</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>ipc</code></td>
<td><code>smsp__inst_executed.avg.per_cycle_active</code></td>
</tr>
<tr>
<td><code>issue_slot_utilization</code></td>
<td><code>smsp__issue_active.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>issue_slots</code></td>
<td><code>smsp__inst_issued.sum</code></td>
</tr>
<tr>
<td><code>issued_ipc</code></td>
<td><code>smsp__inst_issued.avg.per_cycle_active</code></td>
</tr>
<tr>
<td><code>l1_sm_lg_utilization</code></td>
<td><code>l1tex__lsu_writeback_active.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>l2_atomic_throughput</code></td>
<td><code>2 * ( lts__t_sectors_op_atom.sum.per_second + lts__t_sectors_op_red.sum.per_second )</code></td>
</tr>
<tr>
<td><code>l2_atomic_transactions</code></td>
<td><code>2 * ( lts__t_sectors_op_atom.sum + lts__t_sectors_op_red.sum )</code></td>
</tr>
<tr>
<td><code>l2_global_atomic_store_bytes</code></td>
<td><code>lts__t_bytes_equiv_l1sectormiss_pipe_lsu_mem_global_op_atom.sum</code></td>
</tr>
<tr>
<td><code>l2_global_load_bytes</code></td>
<td><code>lts__t_bytes_equiv_l1sectormiss_pipe_lsu_mem_global_op_ld.sum</code></td>
</tr>
<tr>
<td><code>l2_local_global_store_bytes</code></td>
<td><code>lts__t_bytes_equiv_l1sectormiss_pipe_lsu_mem_local_op_st.sum + lts__t_bytes_equiv_l1sectormiss_pipe_lsu_mem_global_op_st.sum</code></td>
</tr>
<tr>
<td><code>l2_local_load_bytes</code></td>
<td><code>lts__t_bytes_equiv_l1sectormiss_pipe_lsu_mem_local_op_ld.sum</code></td>
</tr>
<tr>
<td><code>l2_read_throughput</code></td>
<td><code>lts__t_sectors_op_read.sum.per_second + lts__t_sectors_op_atom.sum.per_second + lts__t_sectors_op_red.sum.per_second</code></td>
</tr>
<tr>
<td><code>l2_read_transactions</code></td>
<td><code>lts__t_sectors_op_read.sum + lts__t_sectors_op_atom.sum + lts__t_sectors_op_red.sum</code></td>
</tr>
<tr>
<td><code>l2_surface_load_bytes</code></td>
<td><code>lts__t_bytes_equiv_l1sectormiss_pipe_tex_mem_surface_op_ld.sum</code></td>
</tr>
<tr>
<td><code>l2_surface_store_bytes</code></td>
<td><code>lts__t_bytes_equiv_l1sectormiss_pipe_tex_mem_surface_op_st.sum</code></td>
</tr>
<tr>
<td><code>l2_tex_hit_rate</code></td>
<td><code>lts__t_sector_hit_rate.pct</code></td>
</tr>
<tr>
<td><code>l2_tex_read_hit_rate</code></td>
<td><code>lts__t_sector_op_read_hit_rate.pct</code></td>
</tr>
<tr>
<td><code>l2_tex_read_throughput</code></td>
<td><code>lts__t_sectors_srcunit_tex_op_read.sum.per_second</code></td>
</tr>
<tr>
<td><code>l2_tex_read_transactions</code></td>
<td><code>lts__t_sectors_srcunit_tex_op_read.sum</code></td>
</tr>
<tr>
<td><code>l2_tex_write_hit_rate</code></td>
<td><code>lts__t_sector_op_write_hit_rate.pct</code></td>
</tr>
<tr>
<td><code>l2_tex_write_throughput</code></td>
<td><code>lts__t_sectors_srcunit_tex_op_write.sum.per_second</code></td>
</tr>
<tr>
<td><code>l2_tex_write_transactions</code></td>
<td><code>lts__t_sectors_srcunit_tex_op_write.sum</code></td>
</tr>
<tr>
<td><code>l2_utilization</code></td>
<td><code>lts__t_sectors.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>l2_write_throughput</code></td>
<td><code>lts__t_sectors_op_write.sum.per_second + lts__t_sectors_op_atom.sum.per_second + lts__t_sectors_op_red.sum.per_second</code></td>
</tr>
<tr>
<td><code>l2_write_transactions</code></td>
<td><code>lts__t_sectors_op_write.sum + lts__t_sectors_op_atom.sum + lts__t_sectors_op_red.sum</code></td>
</tr>
<tr>
<td><code>ldst_executed</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>ldst_fu_utilization</code></td>
<td><code>smsp__inst_executed_pipe_lsu.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>ldst_issued</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>local_hit_rate</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>local_load_requests</code></td>
<td><code>l1tex__t_requests_pipe_lsu_mem_local_op_ld.sum</code></td>
</tr>
<tr>
<td><code>local_load_throughput</code></td>
<td><code>l1tex__t_bytes_pipe_lsu_mem_local_op_ld.sum.per_second</code></td>
</tr>
<tr>
<td><code>local_load_transactions</code></td>
<td><code>l1tex__t_sectors_pipe_lsu_mem_local_op_ld.sum</code></td>
</tr>
<tr>
<td><code>local_load_transactions_per_request</code></td>
<td><code>l1tex__average_t_sectors_per_request_pipe_lsu_mem_local_op_ld.ratio</code></td>
</tr>
<tr>
<td><code>local_memory_overhead</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>local_store_requests</code></td>
<td><code>l1tex__t_requests_pipe_lsu_mem_local_op_st.sum</code></td>
</tr>
<tr>
<td><code>local_store_throughput</code></td>
<td><code>l1tex__t_sectors_pipe_lsu_mem_local_op_st.sum.per_second</code></td>
</tr>
<tr>
<td><code>local_store_transactions</code></td>
<td><code>l1tex__t_sectors_pipe_lsu_mem_local_op_st.sum</code></td>
</tr>
<tr>
<td><code>local_store_transactions_per_request</code></td>
<td><code>l1tex__average_t_sectors_per_request_pipe_lsu_mem_local_op_st.ratio</code></td>
</tr>
<tr>
<td><code>nvlink_data_receive_efficiency</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>nvlink_data_transmission_efficiency</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>nvlink_overhead_data_received</code></td>
<td><code>(nvlrx__bytes_data_protocol.sum / nvlrx__bytes.sum) * 100</code></td>
</tr>
<tr>
<td><code>nvlink_overhead_data_transmitted</code></td>
<td><code>(nvltx__bytes_data_protocol.sum / nvltx__bytes.sum) * 100</code></td>
</tr>
<tr>
<td><code>nvlink_receive_throughput</code></td>
<td><code>nvlrx__bytes.sum.per_second</code></td>
</tr>
<tr>
<td><code>nvlink_total_data_received</code></td>
<td><code>nvlrx__bytes.sum</code></td>
</tr>
<tr>
<td><code>nvlink_total_data_transmitted</code></td>
<td><code>nvltx__bytes.sum</code></td>
</tr>
<tr>
<td><code>nvlink_total_nratom_data_transmitted</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>nvlink_total_ratom_data_transmitted</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>nvlink_total_response_data_received</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>nvlink_total_write_data_transmitted</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>nvlink_transmit_throughput</code></td>
<td><code>nvltx__bytes.sum.per_second</code></td>
</tr>
<tr>
<td><code>nvlink_user_data_received</code></td>
<td><code>nvlrx__bytes_data_user.sum</code></td>
</tr>
<tr>
<td><code>nvlink_user_data_transmitted</code></td>
<td><code>nvltx__bytes_data_user.sum</code></td>
</tr>
<tr>
<td><code>nvlink_user_nratom_data_transmitted</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>nvlink_user_ratom_data_transmitted</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>nvlink_user_response_data_received</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>nvlink_user_write_data_transmitted</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>pcie_total_data_received</code></td>
<td><code>pcie__read_bytes.sum</code></td>
</tr>
<tr>
<td><code>pcie_total_data_transmitted</code></td>
<td><code>pcie__write_bytes.sum</code></td>
</tr>
<tr>
<td><code>shared_efficiency</code></td>
<td><code>smsp__sass_average_data_bytes_per_wavefront_mem_shared.pct</code></td>
</tr>
<tr>
<td><code>shared_load_throughput</code></td>
<td><code>l1tex__data_pipe_lsu_wavefronts_mem_shared_op_ld.sum.per_second</code></td>
</tr>
<tr>
<td><code>shared_load_transactions</code></td>
<td><code>l1tex__data_pipe_lsu_wavefronts_mem_shared_op_ld.sum</code></td>
</tr>
<tr>
<td><code>shared_load_transactions_per_request</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>shared_store_throughput</code></td>
<td><code>l1tex__data_pipe_lsu_wavefronts_mem_shared_op_st.sum.per_second</code></td>
</tr>
<tr>
<td><code>shared_store_transactions</code></td>
<td><code>l1tex__data_pipe_lsu_wavefronts_mem_shared_op_st.sum</code></td>
</tr>
<tr>
<td><code>shared_store_transactions_per_request</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>shared_utilization</code></td>
<td><code>l1tex__data_pipe_lsu_wavefronts_mem_shared.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>single_precision_fu_utilization</code></td>
<td><code>smsp__pipe_fma_cycles_active.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>sm_efficiency</code></td>
<td><code>smsp__cycles_active.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>sm_tex_utilization</code></td>
<td><code>l1tex__texin_sm2tex_req_cycles_active.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>special_fu_utilization</code></td>
<td><code>smsp__inst_executed_pipe_xu.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>stall_constant_memory_dependency</code></td>
<td><code>smsp__warp_issue_stalled_imc_miss_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_exec_dependency</code></td>
<td><code>smsp__warp_issue_stalled_short_scoreboard_per_warp_active.pct + smsp__warp_issue_stalled_wait_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_inst_fetch</code></td>
<td><code>smsp__warp_issue_stalled_no_instruction_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_memory_dependency</code></td>
<td><code>smsp__warp_issue_stalled_long_scoreboard_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_memory_throttle</code></td>
<td><code>smsp__warp_issue_stalled_drain_per_warp_active.pct + smsp__warp_issue_stalled_lg_throttle_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_not_selected</code></td>
<td><code>smsp__warp_issue_stalled_not_selected_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_other</code></td>
<td><code>smsp__warp_issue_stalled_dispatch_stall_per_warp_active.pct + smsp__warp_issue_stalled_misc_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_pipe_busy</code></td>
<td><code>smsp__warp_issue_stalled_math_pipe_throttle_per_warp_active.pct + smsp__warp_issue_stalled_mio_throttle_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_sleeping</code></td>
<td><code>smsp__warp_issue_stalled_sleeping_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_sync</code></td>
<td><code>smsp__warp_issue_stalled_barrier_per_warp_active.pct + smsp__warp_issue_stalled_membar_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>stall_texture</code></td>
<td><code>smsp__warp_issue_stalled_tex_throttle_per_warp_active.pct</code></td>
</tr>
<tr>
<td><code>surface_atomic_requests</code></td>
<td><code>l1tex__t_requests_pipe_tex_mem_surface_op_atom.sum</code></td>
</tr>
<tr>
<td><code>surface_load_requests</code></td>
<td><code>l1tex__t_requests_pipe_tex_mem_surface_op_ld.sum</code></td>
</tr>
<tr>
<td><code>surface_reduction_requests</code></td>
<td><code>l1tex__t_requests_pipe_tex_mem_surface_op_red.sum</code></td>
</tr>
<tr>
<td><code>surface_store_requests</code></td>
<td><code>l1tex__t_requests_pipe_tex_mem_surface_op_st.sum</code></td>
</tr>
<tr>
<td><code>sysmem_read_bytes</code></td>
<td><code>lts__t_sectors_aperture_sysmem_op_read * 32</code></td>
</tr>
<tr>
<td><code>sysmem_read_throughput</code></td>
<td><code>lts__t_sectors_aperture_sysmem_op_read.sum.per_second</code></td>
</tr>
<tr>
<td><code>sysmem_read_transactions</code></td>
<td><code>lts__t_sectors_aperture_sysmem_op_read.sum</code></td>
</tr>
<tr>
<td><code>sysmem_read_utilization</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>sysmem_utilization</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>sysmem_write_bytes</code></td>
<td><code>lts__t_sectors_aperture_sysmem_op_write * 32</code></td>
</tr>
<tr>
<td><code>sysmem_write_throughput</code></td>
<td><code>lts__t_sectors_aperture_sysmem_op_write.sum.per_second</code></td>
</tr>
<tr>
<td><code>sysmem_write_transactions</code></td>
<td><code>lts__t_sectors_aperture_sysmem_op_write.sum</code></td>
</tr>
<tr>
<td><code>sysmem_write_utilization</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>tensor_precision_fu_utilization</code></td>
<td><code>sm__pipe_tensor_op_hmma_cycles_active.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>tensor_precision_int_utilization</code></td>
<td><code>sm__pipe_tensor_op_imma_cycles_active.avg.pct_of_peak_sustained_active (SM 7.2+)</code></td>
</tr>
<tr>
<td><code>tex_cache_hit_rate</code></td>
<td><code>l1tex__t_sector_hit_rate.pct</code></td>
</tr>
<tr>
<td><code>tex_cache_throughput</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>tex_cache_transactions</code></td>
<td><code>l1tex__lsu_writeback_active.avg.pct_of_peak_sustained_active + l1tex__tex_writeback_active.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>tex_fu_utilization</code></td>
<td><code>smsp__inst_executed_pipe_tex.avg.pct_of_peak_sustained_active</code></td>
</tr>
<tr>
<td><code>tex_sm_tex_utilization</code></td>
<td><code>l1tex__f_tex2sm_cycles_active.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>tex_sm_utilization</code></td>
<td><code>sm__mio2rf_writeback_active.avg.pct_of_peak_sustained_elapsed</code></td>
</tr>
<tr>
<td><code>tex_utilization</code></td>
<td><code>n/a</code></td>
</tr>
<tr>
<td><code>texture_load_requests</code></td>
<td><code>l1tex__t_requests_pipe_tex_mem_texture.sum</code></td>
</tr>
<tr>
<td><code>warp_execution_efficiency</code></td>
<td><code>smsp__thread_inst_executed_per_inst_executed.ratio</code></td>
</tr>
<tr>
<td><code>warp_nonpred_execution_efficiency</code></td>
<td><code>smsp__thread_inst_executed_per_inst_executed.pct</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://docs.nvidia.com/nsight-compute/NsightComputeCli/index.html">https://docs.nvidia.com/nsight-compute/NsightComputeCli/index.html</a></li>
<li><a href="https://gist.github.com/mrprajesh/352cbe661ee27a6b4627ae72d89479e6">https://gist.github.com/mrprajesh/352cbe661ee27a6b4627ae72d89479e6</a></li>
</ul>
]]></content>
      <categories>
        <category>CUDA 编程</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>caj文档批量转换为pdf-shell脚本多线程</title>
    <url>/2023/01/10/caj%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2%E4%B8%BApdf-shell%E8%84%9A%E6%9C%AC%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>最近看的论文有些多，但知网上的 caj 文档又卡又难做笔记，遂写了一个 caj 文档批量转换为 pdf 的 shell 脚本。</p>
<span id="more"></span>
<h2 id="caj2pdf"><a href="#caj2pdf" class="headerlink" title="caj2pdf"></a>caj2pdf</h2><p>安装 caj2pdf 命令行工具</p>
<p>github 源码: <a href="https://github.com/caj2pdf/caj2pdf">https://github.com/caj2pdf/caj2pdf</a></p>
<p>aur 用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S caj2pdf-git</span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>当前目录下所有 caj 文件批量转换为pdf，并删除原 caj 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for file in ./*.caj; do</span><br><span class="line">    caj2pdf convert &quot;$file&quot; -o &quot;$&#123;file%.*&#125;.pdf&quot; &amp;&amp; rm &quot;$file&quot; &amp;</span><br><span class="line">done</span><br><span class="line">wait</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>新年愿望</title>
    <url>/2023/01/21/%E6%96%B0%E5%B9%B4%E6%84%BF%E6%9C%9B/</url>
    <content><![CDATA[<p>写于壬寅年除夕夜</p>
<span id="more"></span>
<ul>
<li>[ ] 通过英语六级</li>
<li>[ ] 通过某高校人工智能学院研究生初试</li>
<li>[ ] 完成编写 CUDA C 并行编程系列教程（40%）</li>
<li>[ ] go 微服务部署并行编程</li>
<li>[ ] 购入高性能工作站</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>linux下中文路径命名规范化</title>
    <url>/2023/01/29/linux%E4%B8%8B%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8C%96/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>shell 中无法正常访问带空格或某些字符的目录，写了个脚本规范一下中文路径命名</p>
<span id="more"></span>
<p>将指定目录下所有子目录和文件命名中的<code>、，。()！、？：“”‘’【】《》（）</code>全部替换为<code>_</code>，去除首尾的<code>_</code>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize_chinese_path</span>(<span class="params">directory</span>):</span></span><br><span class="line">    <span class="comment"># 遍历目录</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(directory):</span><br><span class="line">        <span class="keyword">for</span> dirname <span class="keyword">in</span> dirs:</span><br><span class="line">            <span class="comment"># 利用正则表达式，将指定字符全部替换为_</span></span><br><span class="line">            new_dirname = re.sub(<span class="string">r&#x27;[\s、，。()！、？：“”‘’【】《》（）]+&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, dirname)</span><br><span class="line">            <span class="comment"># 去除首尾的_</span></span><br><span class="line">            new_dirname = new_dirname.strip(<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">            <span class="comment"># 新目录名和旧目录名不同时才进行重命名</span></span><br><span class="line">            <span class="keyword">if</span> new_dirname != dirname:</span><br><span class="line">                old_path = os.path.join(root, dirname)</span><br><span class="line">                new_path = os.path.join(root, new_dirname)</span><br><span class="line">                os.rename(old_path, new_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">            <span class="comment"># 利用正则表达式，将指定字符全部替换为_</span></span><br><span class="line">            new_filename = re.sub(<span class="string">r&#x27;[\s、，。()！？：“”‘’【】《》（）]+&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, filename)</span><br><span class="line">            <span class="comment"># 去除首尾的_</span></span><br><span class="line">            new_filename, suffix = os.path.splitext(new_filename)</span><br><span class="line">            new_filename = new_filename.strip(<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">            <span class="comment"># 新文件名和旧文件名不同时才进行重命名</span></span><br><span class="line">            <span class="keyword">if</span> new_filename != filename:</span><br><span class="line">                old_path = os.path.join(root, filename)</span><br><span class="line">                new_path = os.path.join(root, new_filename + suffix)</span><br><span class="line">                os.rename(old_path, new_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">normalize_chinese_path(<span class="string">&#x27;./03 golang微服务实战/&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
